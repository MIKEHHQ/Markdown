var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"TestPilAdc","ref":true,"files":[{"name":"TestPilAdc.c","type":"source","group":"model","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc.c\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"TestPilAdc.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"look1_iflf_binlxpw.h\"\r\n#include \"TestPilAdc_private.h\"\r\n\r\nMdlrefDW_TestPilAdc TestPilAdc_MdlrefDW;\r\n\r\n/* Block signals (default storage) */\r\nB_TestPilAdc_c TestPilAdc_B;\r\n\r\n/* Output and update for referenced model: 'TestPilAdc' */\r\nvoid TestPilAdcTID0(void)\r\n{\r\n}\r\n\r\n/* Output and update for referenced model: 'TestPilAdc' */\r\nvoid TestPilAdcTID1(real32_T *rty_Vout)\r\n{\r\n  {\r\n    uint16_t i;\r\n\r\n    /* Read regular ADC3 value */\r\n    for (i=0; i<1; i++) {\r\n      if (HAL_ADC_PollForConversion(&hadc3, G_ADC3_PollTimeOut) == HAL_OK) {\r\n        ADC3_RegularConvertedValue[i] = (uint16_t)HAL_ADC_GetValue(&hadc3);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Get regular rank1 output value from ADC3 regular value buffer */\r\n  TestPilAdc_B.ADC_Read = ADC3_RegularConvertedValue[0];\r\n\r\n  /* Re-Start ADC3 conversion */\r\n  HAL_ADC_Start(&hadc3);\r\n  *rty_Vout = look1_iflf_binlxpw(TestPilAdc_B.ADC_Read,\r\n    rtCP_uDLookupTable_bp01Data, rtCP_uDLookupTable_tableData, 4095U);\r\n}\r\n\r\n/* Model initialize function */\r\nvoid TestPilAdc_initialize(const char_T **rt_errorStatus)\r\n{\r\n  RT_MODEL_TestPilAdc *const TestPilAdc_M = &(TestPilAdc_MdlrefDW.rtm);\r\n\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatusPointer(TestPilAdc_M, rt_errorStatus);\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &TestPilAdc_B), 0,\r\n                sizeof(B_TestPilAdc_c));\r\n\r\n  {\r\n    /* user code (Initialize function Header) */\r\n    {\r\n      /* ADC3 initialization. */\r\n      /* Store ADC3 informations and its handler. */\r\n      G_ADC_Conf = &ADC3_Conf;\r\n      G_ADC_Handler = &hadc3;\r\n      ADC3_Conf.regularBuffer = ADC3_RegularConvertedValue;\r\n      ADC3_Conf.regularCount = 1;\r\n    }\r\n\r\n    /* user code (Initialize function Body) */\r\n    {\r\n      /* ADC3 Start. */\r\n      /* Start ADC3 conversion. */\r\n      HAL_ADC_Start(&hadc3);\r\n    }\r\n  }\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc.c\r\n */\r\n"},{"name":"TestPilAdc.h","type":"header","group":"model","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_TestPilAdc_h_\r\n#define RTW_HEADER_TestPilAdc_h_\r\n#ifndef TestPilAdc_COMMON_INCLUDES_\r\n#define TestPilAdc_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* TestPilAdc_COMMON_INCLUDES_ */\r\n\r\n#include \"STM32_Config.h\"\r\n#include \"TestPilAdc_External_Functions.h\"\r\n#include \"TestPilAdc_ADC.h\"\r\n#include \"TestPilAdc_types.h\"\r\n#include <string.h>\r\n\r\n/* Block signals for model 'TestPilAdc' */\r\n#ifndef TestPilAdc_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  real32_T ADC_Read;                   /* '<Root>/ADC_Read' */\r\n} B_TestPilAdc_c;\r\n\r\n#endif                                 /*TestPilAdc_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef TestPilAdc_MDLREF_HIDE_CHILD_\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_TestPilAdc {\r\n  const char_T **errorStatus;\r\n};\r\n\r\n#endif                                 /*TestPilAdc_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef TestPilAdc_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  RT_MODEL_TestPilAdc rtm;\r\n} MdlrefDW_TestPilAdc;\r\n\r\n#endif                                 /*TestPilAdc_MDLREF_HIDE_CHILD_*/\r\n\r\nextern void TestPilAdcTID0(void);\r\nextern void TestPilAdcTID1(real32_T *rty_Vout);\r\n\r\n/* Model reference registration function */\r\nextern void TestPilAdc_initialize(const char_T **rt_errorStatus);\r\n\r\n#ifndef TestPilAdc_MDLREF_HIDE_CHILD_\r\n\r\nextern MdlrefDW_TestPilAdc TestPilAdc_MdlrefDW;\r\n\r\n#endif                                 /*TestPilAdc_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef TestPilAdc_MDLREF_HIDE_CHILD_\r\n\r\n/* Block signals (default storage) */\r\nextern B_TestPilAdc_c TestPilAdc_B;\r\n\r\n#endif                                 /*TestPilAdc_MDLREF_HIDE_CHILD_*/\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'TestPilAdc'\r\n * '<S1>'   : 'TestPilAdc/Environment Controller'\r\n */\r\n#endif                                 /* RTW_HEADER_TestPilAdc_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc.h\r\n */\r\n"},{"name":"TestPilAdc_private.h","type":"header","group":"model","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc_private.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_TestPilAdc_private_h_\r\n#define RTW_HEADER_TestPilAdc_private_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         (*((rtm)->errorStatus))\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    (*((rtm)->errorStatus) = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusPointer\r\n#define rtmGetErrorStatusPointer(rtm)  (rtm)->errorStatus\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatusPointer\r\n#define rtmSetErrorStatusPointer(rtm, val) ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\nextern const real32_T rtCP_pooled_bAmThzKd4Bxs[4096];\r\nextern const real32_T rtCP_pooled_so29yfSh0d1Q[4096];\r\n\r\n#define rtCP_uDLookupTable_tableData   rtCP_pooled_bAmThzKd4Bxs  /* Computed Parameter: rtCP_uDLookupTable_tableData\r\n                                                                  * Referenced by: '<Root>/1-D Lookup Table'\r\n                                                                  */\r\n#define rtCP_uDLookupTable_bp01Data    rtCP_pooled_so29yfSh0d1Q  /* Computed Parameter: rtCP_uDLookupTable_bp01Data\r\n                                                                  * Referenced by: '<Root>/1-D Lookup Table'\r\n                                                                  */\r\n#endif                                 /* RTW_HEADER_TestPilAdc_private_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc_private.h\r\n */\r\n"},{"name":"TestPilAdc_types.h","type":"header","group":"model","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc_types.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_TestPilAdc_types_h_\r\n#define RTW_HEADER_TestPilAdc_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_TestPilAdc RT_MODEL_TestPilAdc;\r\n\r\n#endif                                 /* RTW_HEADER_TestPilAdc_types_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc_types.h\r\n */\r\n"},{"name":"const_params.c","type":"source","group":"sharedutility","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * const_params.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"TestPilAdc\".\r\n *\r\n * Model version              : 8.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Tue Jun  7 19:21:13 2022\r\n */\r\n#include \"rtwtypes.h\"\r\n\r\nextern const real32_T rtCP_pooled_bAmThzKd4Bxs[4096];\r\nconst real32_T rtCP_pooled_bAmThzKd4Bxs[4096] = { 0.0F, 0.000805860793F,\r\n  0.00161172159F, 0.00241758232F, 0.00322344317F, 0.00402930425F, 0.00483516464F,\r\n  0.00564102549F, 0.00644688634F, 0.00725274719F, 0.00805860851F, 0.00886446889F,\r\n  0.00967032928F, 0.0104761906F, 0.011282051F, 0.0120879123F, 0.0128937727F,\r\n  0.013699634F, 0.0145054944F, 0.0153113557F, 0.016117217F, 0.0169230774F,\r\n  0.0177289378F, 0.0185347982F, 0.0193406586F, 0.0201465208F, 0.0209523812F,\r\n  0.0217582416F, 0.022564102F, 0.0233699642F, 0.0241758246F, 0.024981685F,\r\n  0.0257875454F, 0.0265934058F, 0.027399268F, 0.0282051284F, 0.0290109888F,\r\n  0.0298168492F, 0.0306227114F, 0.0314285718F, 0.032234434F, 0.0330402926F,\r\n  0.0338461548F, 0.0346520133F, 0.0354578756F, 0.0362637378F, 0.0370695964F,\r\n  0.0378754586F, 0.0386813171F, 0.0394871794F, 0.0402930416F, 0.0410989F,\r\n  0.0419047624F, 0.0427106209F, 0.0435164832F, 0.0443223454F, 0.0451282039F,\r\n  0.0459340662F, 0.0467399284F, 0.0475457869F, 0.0483516492F, 0.0491575077F,\r\n  0.04996337F, 0.0507692322F, 0.0515750907F, 0.052380953F, 0.0531868115F,\r\n  0.0539926738F, 0.054798536F, 0.0556043945F, 0.0564102568F, 0.057216119F,\r\n  0.0580219775F, 0.0588278398F, 0.0596337F, 0.0604395606F, 0.0612454228F,\r\n  0.0620512813F, 0.0628571436F, 0.0636630058F, 0.0644688681F, 0.0652747229F,\r\n  0.0660805851F, 0.0668864474F, 0.0676923096F, 0.0684981719F, 0.0693040267F,\r\n  0.0701098889F, 0.0709157512F, 0.0717216134F, 0.0725274757F, 0.0733333305F,\r\n  0.0741391927F, 0.0749450549F, 0.0757509172F, 0.0765567794F, 0.0773626342F,\r\n  0.0781685F, 0.0789743587F, 0.079780221F, 0.0805860832F, 0.081391938F,\r\n  0.0821978F, 0.0830036625F, 0.0838095248F, 0.084615387F, 0.0854212418F,\r\n  0.0862271041F, 0.0870329663F, 0.0878388286F, 0.0886446908F, 0.0894505531F,\r\n  0.0902564079F, 0.0910622701F, 0.0918681324F, 0.0926739946F, 0.0934798568F,\r\n  0.0942857116F, 0.0950915739F, 0.0958974361F, 0.0967033F, 0.0975091606F,\r\n  0.0983150154F, 0.0991208777F, 0.0999267399F, 0.100732602F, 0.101538464F,\r\n  0.102344319F, 0.103150181F, 0.103956044F, 0.104761906F, 0.105567768F,\r\n  0.106373623F, 0.107179485F, 0.107985348F, 0.10879121F, 0.109597072F,\r\n  0.110402927F, 0.111208789F, 0.112014651F, 0.112820514F, 0.113626376F,\r\n  0.114432238F, 0.115238093F, 0.116043955F, 0.116849817F, 0.11765568F,\r\n  0.118461542F, 0.119267397F, 0.120073259F, 0.120879121F, 0.121684983F,\r\n  0.122490846F, 0.1232967F, 0.124102563F, 0.124908425F, 0.125714287F,\r\n  0.126520142F, 0.127326012F, 0.128131866F, 0.128937736F, 0.129743591F,\r\n  0.130549446F, 0.131355315F, 0.13216117F, 0.13296704F, 0.133772895F,\r\n  0.13457875F, 0.135384619F, 0.136190474F, 0.136996344F, 0.137802199F,\r\n  0.138608053F, 0.139413923F, 0.140219778F, 0.141025648F, 0.141831502F,\r\n  0.142637357F, 0.143443227F, 0.144249082F, 0.145054951F, 0.145860806F,\r\n  0.146666661F, 0.147472531F, 0.148278385F, 0.149084255F, 0.14989011F,\r\n  0.150695965F, 0.151501834F, 0.152307689F, 0.153113559F, 0.153919414F,\r\n  0.154725268F, 0.155531138F, 0.156337F, 0.157142863F, 0.157948717F,\r\n  0.158754572F, 0.159560442F, 0.160366297F, 0.161172166F, 0.161978021F,\r\n  0.162783876F, 0.163589746F, 0.164395601F, 0.16520147F, 0.166007325F,\r\n  0.16681318F, 0.16761905F, 0.168424904F, 0.169230774F, 0.170036629F,\r\n  0.170842484F, 0.171648353F, 0.172454208F, 0.173260078F, 0.174065933F,\r\n  0.174871787F, 0.175677657F, 0.176483512F, 0.177289382F, 0.178095236F,\r\n  0.178901106F, 0.179706961F, 0.180512816F, 0.181318685F, 0.18212454F,\r\n  0.18293041F, 0.183736265F, 0.18454212F, 0.185347989F, 0.186153844F,\r\n  0.186959714F, 0.187765568F, 0.188571423F, 0.189377293F, 0.190183148F,\r\n  0.190989017F, 0.191794872F, 0.192600727F, 0.193406597F, 0.194212452F,\r\n  0.195018321F, 0.195824176F, 0.196630031F, 0.197435901F, 0.198241755F,\r\n  0.199047625F, 0.19985348F, 0.200659335F, 0.201465204F, 0.202271059F,\r\n  0.203076929F, 0.203882784F, 0.204688638F, 0.205494508F, 0.206300363F,\r\n  0.207106233F, 0.207912087F, 0.208717942F, 0.209523812F, 0.210329667F,\r\n  0.211135536F, 0.211941391F, 0.212747246F, 0.213553116F, 0.214358971F,\r\n  0.21516484F, 0.215970695F, 0.21677655F, 0.21758242F, 0.218388274F,\r\n  0.219194144F, 0.22F, 0.220805854F, 0.221611723F, 0.222417578F, 0.223223448F,\r\n  0.224029303F, 0.224835157F, 0.225641027F, 0.226446882F, 0.227252752F,\r\n  0.228058606F, 0.228864476F, 0.229670331F, 0.230476186F, 0.231282055F,\r\n  0.23208791F, 0.23289378F, 0.233699635F, 0.234505489F, 0.235311359F,\r\n  0.236117214F, 0.236923084F, 0.237728938F, 0.238534793F, 0.239340663F,\r\n  0.240146518F, 0.240952387F, 0.241758242F, 0.242564097F, 0.243369967F,\r\n  0.244175822F, 0.244981691F, 0.245787546F, 0.246593401F, 0.247399271F,\r\n  0.248205125F, 0.249011F, 0.24981685F, 0.25062272F, 0.251428574F, 0.252234429F,\r\n  0.253040284F, 0.253846169F, 0.254652023F, 0.255457878F, 0.256263733F,\r\n  0.257069588F, 0.257875472F, 0.258681327F, 0.259487182F, 0.260293037F,\r\n  0.261098891F, 0.261904776F, 0.262710631F, 0.263516486F, 0.26432234F,\r\n  0.265128195F, 0.26593408F, 0.266739935F, 0.267545789F, 0.268351644F,\r\n  0.269157499F, 0.269963384F, 0.270769238F, 0.271575093F, 0.272380948F,\r\n  0.273186803F, 0.273992687F, 0.274798542F, 0.275604397F, 0.276410252F,\r\n  0.277216107F, 0.278022F, 0.278827846F, 0.279633701F, 0.280439556F, 0.28124541F,\r\n  0.282051295F, 0.28285715F, 0.283663F, 0.284468859F, 0.285274714F, 0.286080599F,\r\n  0.286886454F, 0.287692308F, 0.288498163F, 0.289304018F, 0.290109903F,\r\n  0.290915757F, 0.291721612F, 0.292527467F, 0.293333322F, 0.294139206F,\r\n  0.294945061F, 0.295750916F, 0.296556771F, 0.297362626F, 0.29816851F,\r\n  0.298974365F, 0.29978022F, 0.300586075F, 0.301391929F, 0.302197814F,\r\n  0.303003669F, 0.303809524F, 0.304615378F, 0.305421233F, 0.306227118F,\r\n  0.307032973F, 0.307838827F, 0.308644682F, 0.309450537F, 0.310256422F,\r\n  0.311062276F, 0.311868131F, 0.312674F, 0.313479841F, 0.314285725F, 0.31509158F,\r\n  0.315897435F, 0.31670329F, 0.317509145F, 0.318315029F, 0.319120884F,\r\n  0.319926739F, 0.320732594F, 0.321538448F, 0.322344333F, 0.323150188F,\r\n  0.323956043F, 0.324761897F, 0.325567752F, 0.326373637F, 0.327179492F,\r\n  0.327985346F, 0.328791201F, 0.329597056F, 0.330402941F, 0.331208795F,\r\n  0.33201465F, 0.332820505F, 0.33362636F, 0.334432244F, 0.335238099F,\r\n  0.336043954F, 0.336849809F, 0.337655663F, 0.338461548F, 0.339267403F,\r\n  0.340073258F, 0.340879112F, 0.341684967F, 0.342490852F, 0.343296707F,\r\n  0.344102561F, 0.344908416F, 0.345714271F, 0.346520156F, 0.347326F,\r\n  0.348131865F, 0.34893772F, 0.349743575F, 0.350549459F, 0.351355314F,\r\n  0.352161169F, 0.352967024F, 0.353772908F, 0.354578763F, 0.355384618F,\r\n  0.356190473F, 0.356996328F, 0.357802212F, 0.358608067F, 0.359413922F,\r\n  0.360219777F, 0.361025631F, 0.361831516F, 0.362637371F, 0.363443226F,\r\n  0.36424908F, 0.365054935F, 0.36586082F, 0.366666675F, 0.367472529F,\r\n  0.368278384F, 0.369084239F, 0.369890124F, 0.370695978F, 0.371501833F,\r\n  0.372307688F, 0.373113543F, 0.373919427F, 0.374725282F, 0.375531137F,\r\n  0.376337F, 0.377142847F, 0.377948731F, 0.378754586F, 0.379560441F,\r\n  0.380366296F, 0.38117215F, 0.381978035F, 0.38278389F, 0.383589745F,\r\n  0.384395599F, 0.385201454F, 0.386007339F, 0.386813194F, 0.387619048F,\r\n  0.388424903F, 0.389230758F, 0.390036643F, 0.390842497F, 0.391648352F,\r\n  0.392454207F, 0.393260062F, 0.394065946F, 0.394871801F, 0.395677656F,\r\n  0.396483511F, 0.397289366F, 0.39809525F, 0.398901105F, 0.39970696F,\r\n  0.400512815F, 0.401318669F, 0.402124554F, 0.402930409F, 0.403736264F,\r\n  0.404542118F, 0.405347973F, 0.406153858F, 0.406959713F, 0.407765567F,\r\n  0.408571422F, 0.409377277F, 0.410183161F, 0.410989016F, 0.411794871F,\r\n  0.412600726F, 0.413406581F, 0.414212465F, 0.41501832F, 0.415824175F,\r\n  0.41663003F, 0.417435884F, 0.418241769F, 0.419047624F, 0.419853479F,\r\n  0.420659333F, 0.421465188F, 0.422271073F, 0.423076928F, 0.423882782F,\r\n  0.424688637F, 0.425494492F, 0.426300377F, 0.427106231F, 0.427912086F,\r\n  0.428717941F, 0.429523796F, 0.43032968F, 0.431135535F, 0.43194139F,\r\n  0.432747245F, 0.4335531F, 0.434358984F, 0.435164839F, 0.435970694F,\r\n  0.436776549F, 0.437582403F, 0.438388288F, 0.439194143F, 0.44F, 0.440805852F,\r\n  0.441611707F, 0.442417592F, 0.443223447F, 0.444029301F, 0.444835156F,\r\n  0.445641F, 0.446446896F, 0.44725275F, 0.448058605F, 0.44886446F, 0.449670315F,\r\n  0.450476199F, 0.451282054F, 0.452087909F, 0.452893764F, 0.453699648F,\r\n  0.454505503F, 0.455311358F, 0.456117213F, 0.456923068F, 0.457728952F,\r\n  0.458534807F, 0.459340662F, 0.460146517F, 0.460952371F, 0.461758256F,\r\n  0.462564111F, 0.463369966F, 0.46417582F, 0.464981675F, 0.46578756F,\r\n  0.466593415F, 0.467399269F, 0.468205124F, 0.469010979F, 0.469816864F,\r\n  0.470622718F, 0.471428573F, 0.472234428F, 0.473040283F, 0.473846167F,\r\n  0.474652022F, 0.475457877F, 0.476263732F, 0.477069587F, 0.477875471F,\r\n  0.478681326F, 0.479487181F, 0.480293036F, 0.48109889F, 0.481904775F,\r\n  0.48271063F, 0.483516484F, 0.484322339F, 0.485128194F, 0.485934079F,\r\n  0.486739933F, 0.487545788F, 0.488351643F, 0.489157498F, 0.489963382F,\r\n  0.490769237F, 0.491575092F, 0.492380947F, 0.493186802F, 0.493992686F,\r\n  0.494798541F, 0.495604396F, 0.496410251F, 0.497216105F, 0.498022F,\r\n  0.498827845F, 0.4996337F, 0.500439584F, 0.501245439F, 0.502051294F,\r\n  0.502857149F, 0.503663F, 0.504468858F, 0.505274713F, 0.506080568F,\r\n  0.506886423F, 0.507692337F, 0.508498192F, 0.509304047F, 0.510109901F,\r\n  0.510915756F, 0.511721611F, 0.512527466F, 0.513333321F, 0.514139175F,\r\n  0.51494503F, 0.515750945F, 0.516556799F, 0.517362654F, 0.518168509F,\r\n  0.518974364F, 0.519780219F, 0.520586073F, 0.521391928F, 0.522197783F,\r\n  0.523003638F, 0.523809552F, 0.524615407F, 0.525421262F, 0.526227117F,\r\n  0.527033F, 0.527838826F, 0.528644681F, 0.529450536F, 0.530256391F,\r\n  0.531062245F, 0.53186816F, 0.532674F, 0.533479869F, 0.534285724F, 0.535091579F,\r\n  0.535897434F, 0.536703289F, 0.537509143F, 0.538315F, 0.539120853F,\r\n  0.539926767F, 0.540732622F, 0.541538477F, 0.542344332F, 0.543150187F,\r\n  0.543956041F, 0.544761896F, 0.545567751F, 0.546373606F, 0.547179461F,\r\n  0.547985375F, 0.54879123F, 0.549597085F, 0.550402939F, 0.551208794F,\r\n  0.552014649F, 0.552820504F, 0.553626359F, 0.554432213F, 0.555238068F,\r\n  0.556044F, 0.556849837F, 0.557655692F, 0.558461547F, 0.559267402F,\r\n  0.560073256F, 0.560879111F, 0.561684966F, 0.562490821F, 0.563296676F,\r\n  0.56410259F, 0.564908445F, 0.5657143F, 0.566520154F, 0.567326F, 0.568131864F,\r\n  0.568937719F, 0.569743574F, 0.570549428F, 0.571355283F, 0.572161198F,\r\n  0.572967052F, 0.573772907F, 0.574578762F, 0.575384617F, 0.576190472F,\r\n  0.576996326F, 0.577802181F, 0.578608036F, 0.579413891F, 0.580219805F,\r\n  0.58102566F, 0.581831515F, 0.58263737F, 0.583443224F, 0.584249079F,\r\n  0.585054934F, 0.585860789F, 0.586666644F, 0.587472498F, 0.588278413F,\r\n  0.589084268F, 0.589890122F, 0.590696F, 0.591501832F, 0.592307687F,\r\n  0.593113542F, 0.593919396F, 0.594725251F, 0.595531106F, 0.596337F,\r\n  0.597142875F, 0.59794873F, 0.598754585F, 0.59956044F, 0.600366294F,\r\n  0.601172149F, 0.601978F, 0.602783859F, 0.603589773F, 0.604395628F,\r\n  0.605201483F, 0.606007338F, 0.606813192F, 0.607619047F, 0.608424902F,\r\n  0.609230757F, 0.610036612F, 0.610842466F, 0.611648381F, 0.612454236F,\r\n  0.61326009F, 0.614065945F, 0.6148718F, 0.615677655F, 0.61648351F, 0.617289364F,\r\n  0.618095219F, 0.618901074F, 0.619707F, 0.620512843F, 0.621318698F,\r\n  0.622124553F, 0.622930408F, 0.623736262F, 0.624542117F, 0.625348F,\r\n  0.626153827F, 0.626959682F, 0.627765596F, 0.628571451F, 0.629377306F,\r\n  0.63018316F, 0.630989F, 0.63179487F, 0.632600725F, 0.633406579F, 0.634212434F,\r\n  0.635018289F, 0.635824203F, 0.636630058F, 0.637435913F, 0.638241768F,\r\n  0.639047623F, 0.639853477F, 0.640659332F, 0.641465187F, 0.642271042F,\r\n  0.643076897F, 0.643882811F, 0.644688666F, 0.645494521F, 0.646300375F,\r\n  0.64710623F, 0.647912085F, 0.64871794F, 0.649523795F, 0.650329649F,\r\n  0.651135504F, 0.651941419F, 0.652747273F, 0.653553128F, 0.654359F,\r\n  0.655164838F, 0.655970693F, 0.656776547F, 0.657582402F, 0.658388257F,\r\n  0.659194112F, 0.66F, 0.660805881F, 0.661611736F, 0.662417591F, 0.663223445F,\r\n  0.6640293F, 0.664835155F, 0.665641F, 0.666446865F, 0.667252719F, 0.668058634F,\r\n  0.668864489F, 0.669670343F, 0.670476198F, 0.671282053F, 0.672087908F,\r\n  0.672893763F, 0.673699617F, 0.674505472F, 0.675311327F, 0.676117241F,\r\n  0.676923096F, 0.677728951F, 0.678534806F, 0.679340661F, 0.680146515F,\r\n  0.68095237F, 0.681758225F, 0.68256408F, 0.683369935F, 0.684175849F,\r\n  0.684981704F, 0.685787559F, 0.686593413F, 0.687399268F, 0.688205123F,\r\n  0.689011F, 0.689816833F, 0.690622687F, 0.691428542F, 0.692234457F,\r\n  0.693040311F, 0.693846166F, 0.694652F, 0.695457876F, 0.696263731F,\r\n  0.697069585F, 0.69787544F, 0.698681295F, 0.69948715F, 0.700293064F,\r\n  0.701098919F, 0.701904774F, 0.702710629F, 0.703516483F, 0.704322338F,\r\n  0.705128193F, 0.705934048F, 0.706739902F, 0.707545817F, 0.708351672F,\r\n  0.709157526F, 0.709963381F, 0.710769236F, 0.711575091F, 0.712380946F,\r\n  0.7131868F, 0.713992655F, 0.71479851F, 0.715604424F, 0.716410279F,\r\n  0.717216134F, 0.718022F, 0.718827844F, 0.719633698F, 0.720439553F,\r\n  0.721245408F, 0.722051263F, 0.722857118F, 0.723663032F, 0.724468887F,\r\n  0.725274742F, 0.726080596F, 0.726886451F, 0.727692306F, 0.728498161F,\r\n  0.729304F, 0.73010987F, 0.730915725F, 0.73172164F, 0.732527494F, 0.733333349F,\r\n  0.734139204F, 0.734945059F, 0.735750914F, 0.736556768F, 0.737362623F,\r\n  0.738168478F, 0.738974333F, 0.739780247F, 0.740586102F, 0.741391957F,\r\n  0.742197812F, 0.743003666F, 0.743809521F, 0.744615376F, 0.745421231F,\r\n  0.746227086F, 0.74703294F, 0.747838855F, 0.74864471F, 0.749450564F,\r\n  0.750256419F, 0.751062274F, 0.751868129F, 0.752674F, 0.753479838F,\r\n  0.754285693F, 0.755091548F, 0.755897462F, 0.756703317F, 0.757509172F,\r\n  0.758315F, 0.759120882F, 0.759926736F, 0.760732591F, 0.761538446F,\r\n  0.762344301F, 0.763150156F, 0.76395607F, 0.764761925F, 0.76556778F,\r\n  0.766373634F, 0.767179489F, 0.767985344F, 0.768791199F, 0.769597054F,\r\n  0.770402908F, 0.771208763F, 0.772014678F, 0.772820532F, 0.773626387F,\r\n  0.774432242F, 0.775238097F, 0.776043952F, 0.776849806F, 0.777655661F,\r\n  0.778461516F, 0.779267371F, 0.780073285F, 0.78087914F, 0.781685F, 0.782490849F,\r\n  0.783296704F, 0.784102559F, 0.784908414F, 0.785714269F, 0.786520123F,\r\n  0.787326F, 0.788131893F, 0.788937747F, 0.789743602F, 0.790549457F,\r\n  0.791355312F, 0.792161167F, 0.792967F, 0.793772876F, 0.794578731F,\r\n  0.795384586F, 0.7961905F, 0.796996355F, 0.79780221F, 0.798608065F,\r\n  0.799413919F, 0.800219774F, 0.801025629F, 0.801831484F, 0.802637339F,\r\n  0.803443253F, 0.804249108F, 0.805054963F, 0.805860817F, 0.806666672F,\r\n  0.807472527F, 0.808278382F, 0.809084237F, 0.809890091F, 0.810695946F,\r\n  0.811501861F, 0.812307715F, 0.81311357F, 0.813919425F, 0.81472528F,\r\n  0.815531135F, 0.816337F, 0.817142844F, 0.817948699F, 0.818754554F,\r\n  0.819560468F, 0.820366323F, 0.821172178F, 0.821978033F, 0.822783887F,\r\n  0.823589742F, 0.824395597F, 0.825201452F, 0.826007307F, 0.826813161F,\r\n  0.827619076F, 0.828424931F, 0.829230785F, 0.83003664F, 0.830842495F,\r\n  0.83164835F, 0.832454205F, 0.833260059F, 0.834065914F, 0.834871769F,\r\n  0.835677683F, 0.836483538F, 0.837289393F, 0.838095248F, 0.838901103F,\r\n  0.839706957F, 0.840512812F, 0.841318667F, 0.842124522F, 0.842930377F,\r\n  0.843736291F, 0.844542146F, 0.845348F, 0.846153855F, 0.84695971F, 0.847765565F,\r\n  0.84857142F, 0.849377275F, 0.850183129F, 0.850989F, 0.851794899F, 0.852600753F,\r\n  0.853406608F, 0.854212463F, 0.855018318F, 0.855824172F, 0.85663F, 0.857435882F,\r\n  0.858241737F, 0.859047592F, 0.859853506F, 0.860659361F, 0.861465216F,\r\n  0.86227107F, 0.863076925F, 0.86388278F, 0.864688635F, 0.86549449F,\r\n  0.866300344F, 0.867106199F, 0.867912114F, 0.868717968F, 0.869523823F,\r\n  0.870329678F, 0.871135533F, 0.871941388F, 0.872747242F, 0.873553097F,\r\n  0.874358952F, 0.875164807F, 0.875970721F, 0.876776576F, 0.877582431F,\r\n  0.878388286F, 0.87919414F, 0.88F, 0.88080585F, 0.881611705F, 0.88241756F,\r\n  0.883223414F, 0.884029329F, 0.884835184F, 0.885641038F, 0.886446893F,\r\n  0.887252748F, 0.888058603F, 0.888864458F, 0.889670312F, 0.890476167F,\r\n  0.891282F, 0.892087936F, 0.892893791F, 0.893699646F, 0.894505501F,\r\n  0.895311356F, 0.89611721F, 0.896923065F, 0.89772892F, 0.898534775F,\r\n  0.89934063F, 0.900146544F, 0.900952399F, 0.901758254F, 0.902564108F,\r\n  0.903369963F, 0.904175818F, 0.904981673F, 0.905787528F, 0.906593382F,\r\n  0.907399297F, 0.908205152F, 0.909011F, 0.909816861F, 0.910622716F,\r\n  0.911428571F, 0.912234426F, 0.91304028F, 0.913846135F, 0.914652F, 0.915457904F,\r\n  0.916263759F, 0.917069614F, 0.917875469F, 0.918681324F, 0.919487178F,\r\n  0.920293033F, 0.921098888F, 0.921904743F, 0.922710598F, 0.923516512F,\r\n  0.924322367F, 0.925128222F, 0.925934076F, 0.926739931F, 0.927545786F,\r\n  0.928351641F, 0.929157495F, 0.92996335F, 0.930769205F, 0.931575119F, 0.932381F,\r\n  0.933186829F, 0.933992684F, 0.934798539F, 0.935604393F, 0.936410248F,\r\n  0.937216103F, 0.938021958F, 0.938827813F, 0.939633727F, 0.940439582F,\r\n  0.941245437F, 0.942051291F, 0.942857146F, 0.943663F, 0.944468856F,\r\n  0.945274711F, 0.946080565F, 0.94688642F, 0.947692335F, 0.948498189F,\r\n  0.949304044F, 0.950109899F, 0.950915754F, 0.951721609F, 0.952527463F,\r\n  0.953333318F, 0.954139173F, 0.954945F, 0.955750942F, 0.956556797F,\r\n  0.957362652F, 0.958168507F, 0.958974361F, 0.959780216F, 0.960586071F,\r\n  0.961391926F, 0.962197781F, 0.963003635F, 0.96380955F, 0.964615405F,\r\n  0.965421259F, 0.966227114F, 0.967032969F, 0.967838824F, 0.968644679F,\r\n  0.969450533F, 0.970256388F, 0.971062243F, 0.971868157F, 0.972674F,\r\n  0.973479867F, 0.974285722F, 0.975091577F, 0.975897431F, 0.976703286F,\r\n  0.977509141F, 0.978315F, 0.979120851F, 0.979926765F, 0.98073262F, 0.981538475F,\r\n  0.982344329F, 0.983150184F, 0.983956039F, 0.984761894F, 0.985567749F,\r\n  0.986373603F, 0.987179458F, 0.987985373F, 0.988791227F, 0.989597082F,\r\n  0.990402937F, 0.991208792F, 0.992014647F, 0.992820501F, 0.993626356F,\r\n  0.994432211F, 0.995238066F, 0.996044F, 0.996849835F, 0.99765569F, 0.998461545F,\r\n  0.999267399F, 1.00007331F, 1.00087917F, 1.00168502F, 1.00249088F, 1.00329673F,\r\n  1.00410259F, 1.00490844F, 1.0057143F, 1.00652015F, 1.00732601F, 1.00813186F,\r\n  1.00893772F, 1.00974357F, 1.01054943F, 1.01135528F, 1.01216114F, 1.01296699F,\r\n  1.01377285F, 1.0145787F, 1.01538467F, 1.01619053F, 1.01699638F, 1.01780224F,\r\n  1.01860809F, 1.01941395F, 1.0202198F, 1.02102566F, 1.02183151F, 1.02263737F,\r\n  1.02344322F, 1.02424908F, 1.02505493F, 1.02586079F, 1.02666664F, 1.0274725F,\r\n  1.02827835F, 1.02908421F, 1.02989006F, 1.03069592F, 1.03150189F, 1.03230774F,\r\n  1.0331136F, 1.03391945F, 1.03472531F, 1.03553116F, 1.03633702F, 1.03714287F,\r\n  1.03794873F, 1.03875458F, 1.03956044F, 1.04036629F, 1.04117215F, 1.041978F,\r\n  1.04278386F, 1.04358971F, 1.04439557F, 1.04520142F, 1.04600728F, 1.04681313F,\r\n  1.0476191F, 1.04842496F, 1.04923081F, 1.05003667F, 1.05084252F, 1.05164838F,\r\n  1.05245423F, 1.05326009F, 1.05406594F, 1.0548718F, 1.05567765F, 1.05648351F,\r\n  1.05728936F, 1.05809522F, 1.05890107F, 1.05970693F, 1.06051278F, 1.06131864F,\r\n  1.06212449F, 1.06293035F, 1.06373632F, 1.06454217F, 1.06534803F, 1.06615388F,\r\n  1.06695974F, 1.06776559F, 1.06857145F, 1.0693773F, 1.07018316F, 1.07098901F,\r\n  1.07179487F, 1.07260072F, 1.07340658F, 1.07421243F, 1.07501829F, 1.07582414F,\r\n  1.07663F, 1.07743585F, 1.07824171F, 1.07904756F, 1.07985353F, 1.08065939F,\r\n  1.08146524F, 1.0822711F, 1.08307695F, 1.08388281F, 1.08468866F, 1.08549452F,\r\n  1.08630037F, 1.08710623F, 1.08791208F, 1.08871794F, 1.08952379F, 1.09032965F,\r\n  1.0911355F, 1.09194136F, 1.09274721F, 1.09355307F, 1.09435892F, 1.09516478F,\r\n  1.09597075F, 1.0967766F, 1.09758246F, 1.09838831F, 1.09919417F, 1.1F,\r\n  1.10080588F, 1.10161173F, 1.10241759F, 1.10322344F, 1.1040293F, 1.10483515F,\r\n  1.10564101F, 1.10644686F, 1.10725272F, 1.10805857F, 1.10886443F, 1.10967028F,\r\n  1.11047614F, 1.11128211F, 1.11208797F, 1.11289382F, 1.11369967F, 1.11450553F,\r\n  1.11531138F, 1.11611724F, 1.11692309F, 1.11772895F, 1.1185348F, 1.11934066F,\r\n  1.12014651F, 1.12095237F, 1.12175822F, 1.12256408F, 1.12336993F, 1.12417579F,\r\n  1.12498164F, 1.1257875F, 1.12659335F, 1.12739933F, 1.12820518F, 1.12901103F,\r\n  1.12981689F, 1.13062274F, 1.1314286F, 1.13223445F, 1.13304031F, 1.13384616F,\r\n  1.13465202F, 1.13545787F, 1.13626373F, 1.13706958F, 1.13787544F, 1.13868129F,\r\n  1.13948715F, 1.140293F, 1.14109886F, 1.14190471F, 1.14271057F, 1.14351654F,\r\n  1.1443224F, 1.14512825F, 1.1459341F, 1.14674F, 1.14754581F, 1.14835167F,\r\n  1.14915752F, 1.14996338F, 1.15076923F, 1.15157509F, 1.15238094F, 1.1531868F,\r\n  1.15399265F, 1.15479851F, 1.15560436F, 1.15641022F, 1.15721607F, 1.15802193F,\r\n  1.15882778F, 1.15963376F, 1.16043961F, 1.16124547F, 1.16205132F, 1.16285717F,\r\n  1.16366303F, 1.16446888F, 1.16527474F, 1.16608059F, 1.16688645F, 1.1676923F,\r\n  1.16849816F, 1.16930401F, 1.17010987F, 1.17091572F, 1.17172158F, 1.17252743F,\r\n  1.17333329F, 1.17413914F, 1.174945F, 1.17575097F, 1.17655683F, 1.17736268F,\r\n  1.17816854F, 1.17897439F, 1.17978024F, 1.1805861F, 1.18139195F, 1.18219781F,\r\n  1.18300366F, 1.18380952F, 1.18461537F, 1.18542123F, 1.18622708F, 1.18703294F,\r\n  1.18783879F, 1.18864465F, 1.1894505F, 1.19025636F, 1.19106221F, 1.19186819F,\r\n  1.19267404F, 1.1934799F, 1.19428575F, 1.19509161F, 1.19589746F, 1.19670331F,\r\n  1.19750917F, 1.19831502F, 1.19912088F, 1.19992673F, 1.20073259F, 1.20153844F,\r\n  1.2023443F, 1.20315015F, 1.20395601F, 1.20476186F, 1.20556772F, 1.20637357F,\r\n  1.20717955F, 1.2079854F, 1.20879126F, 1.20959711F, 1.21040297F, 1.21120882F,\r\n  1.21201468F, 1.21282053F, 1.21362638F, 1.21443224F, 1.21523809F, 1.21604395F,\r\n  1.2168498F, 1.21765566F, 1.21846151F, 1.21926737F, 1.22007322F, 1.22087908F,\r\n  1.22168493F, 1.22249079F, 1.22329676F, 1.22410262F, 1.22490847F, 1.22571433F,\r\n  1.22652018F, 1.22732604F, 1.22813189F, 1.22893775F, 1.2297436F, 1.23054945F,\r\n  1.23135531F, 1.23216116F, 1.23296702F, 1.23377287F, 1.23457873F, 1.23538458F,\r\n  1.23619044F, 1.23699629F, 1.23780215F, 1.238608F, 1.23941398F, 1.24021983F,\r\n  1.24102569F, 1.24183154F, 1.2426374F, 1.24344325F, 1.24424911F, 1.24505496F,\r\n  1.24586082F, 1.24666667F, 1.24747252F, 1.24827838F, 1.24908423F, 1.24989009F,\r\n  1.25069594F, 1.2515018F, 1.25230765F, 1.25311351F, 1.25391936F, 1.25472522F,\r\n  1.25553119F, 1.25633705F, 1.2571429F, 1.25794876F, 1.25875461F, 1.25956047F,\r\n  1.26036632F, 1.26117218F, 1.26197803F, 1.26278389F, 1.26358974F, 1.26439559F,\r\n  1.26520145F, 1.2660073F, 1.26681316F, 1.26761901F, 1.26842487F, 1.26923072F,\r\n  1.27003658F, 1.27084243F, 1.27164841F, 1.27245426F, 1.27326012F, 1.27406597F,\r\n  1.27487183F, 1.27567768F, 1.27648354F, 1.27728939F, 1.27809525F, 1.2789011F,\r\n  1.27970695F, 1.28051281F, 1.28131866F, 1.28212452F, 1.28293037F, 1.28373623F,\r\n  1.28454208F, 1.28534794F, 1.28615379F, 1.28695965F, 1.28776562F, 1.28857148F,\r\n  1.28937733F, 1.29018319F, 1.29098904F, 1.2917949F, 1.29260075F, 1.29340661F,\r\n  1.29421246F, 1.29501832F, 1.29582417F, 1.29663F, 1.29743588F, 1.29824173F,\r\n  1.29904759F, 1.29985344F, 1.3006593F, 1.30146515F, 1.30227101F, 1.30307698F,\r\n  1.30388284F, 1.30468869F, 1.30549455F, 1.3063004F, 1.30710626F, 1.30791211F,\r\n  1.30871797F, 1.30952382F, 1.31032968F, 1.31113553F, 1.31194139F, 1.31274724F,\r\n  1.31355309F, 1.31435895F, 1.3151648F, 1.31597066F, 1.31677651F, 1.31758237F,\r\n  1.31838822F, 1.3191942F, 1.32F, 1.32080591F, 1.32161176F, 1.32241762F,\r\n  1.32322347F, 1.32402933F, 1.32483518F, 1.32564104F, 1.32644689F, 1.32725275F,\r\n  1.3280586F, 1.32886446F, 1.32967031F, 1.33047616F, 1.33128202F, 1.33208787F,\r\n  1.33289373F, 1.33369958F, 1.33450544F, 1.33531141F, 1.33611727F, 1.33692312F,\r\n  1.33772898F, 1.33853483F, 1.33934069F, 1.34014654F, 1.3409524F, 1.34175825F,\r\n  1.34256411F, 1.34337F, 1.34417582F, 1.34498167F, 1.34578753F, 1.34659338F,\r\n  1.34739923F, 1.34820509F, 1.34901094F, 1.3498168F, 1.35062265F, 1.35142863F,\r\n  1.35223448F, 1.35304034F, 1.35384619F, 1.35465205F, 1.3554579F, 1.35626376F,\r\n  1.35706961F, 1.35787547F, 1.35868132F, 1.35948718F, 1.36029303F, 1.36109889F,\r\n  1.36190474F, 1.3627106F, 1.36351645F, 1.3643223F, 1.36512816F, 1.36593401F,\r\n  1.36673987F, 1.36754584F, 1.3683517F, 1.36915755F, 1.36996341F, 1.37076926F,\r\n  1.37157512F, 1.37238097F, 1.37318683F, 1.37399268F, 1.37479854F, 1.37560439F,\r\n  1.37641025F, 1.3772161F, 1.37802196F, 1.37882781F, 1.37963367F, 1.38043952F,\r\n  1.38124537F, 1.38205123F, 1.38285708F, 1.38366306F, 1.38446891F, 1.38527477F,\r\n  1.38608062F, 1.38688648F, 1.38769233F, 1.38849819F, 1.38930404F, 1.3901099F,\r\n  1.39091575F, 1.39172161F, 1.39252746F, 1.39333332F, 1.39413917F, 1.39494503F,\r\n  1.39575088F, 1.39655674F, 1.39736259F, 1.39816844F, 1.3989743F, 1.39978027F,\r\n  1.40058613F, 1.40139198F, 1.40219784F, 1.40300369F, 1.40380955F, 1.4046154F,\r\n  1.40542126F, 1.40622711F, 1.40703297F, 1.40783882F, 1.40864468F, 1.40945053F,\r\n  1.41025639F, 1.41106224F, 1.4118681F, 1.41267395F, 1.4134798F, 1.41428566F,\r\n  1.41509163F, 1.41589749F, 1.41670334F, 1.4175092F, 1.41831505F, 1.41912091F,\r\n  1.41992676F, 1.42073262F, 1.42153847F, 1.42234433F, 1.42315018F, 1.42395604F,\r\n  1.42476189F, 1.42556775F, 1.4263736F, 1.42717946F, 1.42798531F, 1.42879117F,\r\n  1.42959702F, 1.43040287F, 1.43120885F, 1.4320147F, 1.43282056F, 1.43362641F,\r\n  1.43443227F, 1.43523812F, 1.43604398F, 1.43684983F, 1.43765569F, 1.43846154F,\r\n  1.4392674F, 1.44007325F, 1.44087911F, 1.44168496F, 1.44249082F, 1.44329667F,\r\n  1.44410253F, 1.44490838F, 1.44571424F, 1.44652009F, 1.44732606F, 1.44813192F,\r\n  1.44893777F, 1.44974363F, 1.45054948F, 1.45135534F, 1.45216119F, 1.45296705F,\r\n  1.4537729F, 1.45457876F, 1.45538461F, 1.45619047F, 1.45699632F, 1.45780218F,\r\n  1.45860803F, 1.45941389F, 1.46021974F, 1.4610256F, 1.46183145F, 1.46263731F,\r\n  1.46344328F, 1.46424913F, 1.46505499F, 1.46586084F, 1.4666667F, 1.46747255F,\r\n  1.46827841F, 1.46908426F, 1.46989012F, 1.47069597F, 1.47150183F, 1.47230768F,\r\n  1.47311354F, 1.47391939F, 1.47472525F, 1.4755311F, 1.47633696F, 1.47714281F,\r\n  1.47794867F, 1.47875452F, 1.47956049F, 1.48036635F, 1.4811722F, 1.48197806F,\r\n  1.48278391F, 1.48358977F, 1.48439562F, 1.48520148F, 1.48600733F, 1.48681319F,\r\n  1.48761904F, 1.4884249F, 1.48923075F, 1.49003661F, 1.49084246F, 1.49164832F,\r\n  1.49245417F, 1.49326F, 1.49406588F, 1.49487174F, 1.49567771F, 1.49648356F,\r\n  1.49728942F, 1.49809527F, 1.49890113F, 1.49970698F, 1.50051284F, 1.50131869F,\r\n  1.50212455F, 1.5029304F, 1.50373626F, 1.50454211F, 1.50534797F, 1.50615382F,\r\n  1.50695968F, 1.50776553F, 1.50857139F, 1.50937724F, 1.5101831F, 1.51098907F,\r\n  1.51179492F, 1.51260078F, 1.51340663F, 1.51421249F, 1.51501834F, 1.5158242F,\r\n  1.51663F, 1.51743591F, 1.51824176F, 1.51904762F, 1.51985347F, 1.52065933F,\r\n  1.52146518F, 1.52227104F, 1.52307689F, 1.52388275F, 1.5246886F, 1.52549446F,\r\n  1.52630031F, 1.52710629F, 1.52791214F, 1.52871799F, 1.52952385F, 1.5303297F,\r\n  1.53113556F, 1.53194141F, 1.53274727F, 1.53355312F, 1.53435898F, 1.53516483F,\r\n  1.53597069F, 1.53677654F, 1.5375824F, 1.53838825F, 1.53919411F, 1.54F,\r\n  1.54080582F, 1.54161167F, 1.54241753F, 1.5432235F, 1.54402936F, 1.54483521F,\r\n  1.54564106F, 1.54644692F, 1.54725277F, 1.54805863F, 1.54886448F, 1.54967034F,\r\n  1.55047619F, 1.55128205F, 1.5520879F, 1.55289376F, 1.55369961F, 1.55450547F,\r\n  1.55531132F, 1.55611718F, 1.55692303F, 1.55772889F, 1.55853474F, 1.55934072F,\r\n  1.56014657F, 1.56095243F, 1.56175828F, 1.56256413F, 1.56337F, 1.56417584F,\r\n  1.5649817F, 1.56578755F, 1.56659341F, 1.56739926F, 1.56820512F, 1.56901097F,\r\n  1.56981683F, 1.57062268F, 1.57142854F, 1.57223439F, 1.57304025F, 1.5738461F,\r\n  1.57465196F, 1.57545793F, 1.57626379F, 1.57706964F, 1.57787549F, 1.57868135F,\r\n  1.5794872F, 1.58029306F, 1.58109891F, 1.58190477F, 1.58271062F, 1.58351648F,\r\n  1.58432233F, 1.58512819F, 1.58593404F, 1.5867399F, 1.58754575F, 1.58835161F,\r\n  1.58915746F, 1.58996332F, 1.59076917F, 1.59157515F, 1.592381F, 1.59318686F,\r\n  1.59399271F, 1.59479856F, 1.59560442F, 1.59641027F, 1.59721613F, 1.59802198F,\r\n  1.59882784F, 1.59963369F, 1.60043955F, 1.6012454F, 1.60205126F, 1.60285711F,\r\n  1.60366297F, 1.60446882F, 1.60527468F, 1.60608053F, 1.60688651F, 1.60769236F,\r\n  1.60849822F, 1.60930407F, 1.61010993F, 1.61091578F, 1.61172163F, 1.61252749F,\r\n  1.61333334F, 1.6141392F, 1.61494505F, 1.61575091F, 1.61655676F, 1.61736262F,\r\n  1.61816847F, 1.61897433F, 1.61978018F, 1.62058604F, 1.62139189F, 1.62219775F,\r\n  1.62300372F, 1.62380958F, 1.62461543F, 1.62542129F, 1.62622714F, 1.627033F,\r\n  1.62783885F, 1.6286447F, 1.62945056F, 1.63025641F, 1.63106227F, 1.63186812F,\r\n  1.63267398F, 1.63347983F, 1.63428569F, 1.63509154F, 1.6358974F, 1.63670325F,\r\n  1.63750911F, 1.63831496F, 1.63912094F, 1.63992679F, 1.64073265F, 1.6415385F,\r\n  1.64234436F, 1.64315021F, 1.64395607F, 1.64476192F, 1.64556777F, 1.64637363F,\r\n  1.64717948F, 1.64798534F, 1.64879119F, 1.64959705F, 1.6504029F, 1.65120876F,\r\n  1.65201461F, 1.65282047F, 1.65362632F, 1.65443218F, 1.65523815F, 1.65604401F,\r\n  1.65684986F, 1.65765572F, 1.65846157F, 1.65926743F, 1.66007328F, 1.66087914F,\r\n  1.66168499F, 1.66249084F, 1.6632967F, 1.66410255F, 1.66490841F, 1.66571426F,\r\n  1.66652012F, 1.66732597F, 1.66813183F, 1.66893768F, 1.66974354F, 1.67054939F,\r\n  1.67135537F, 1.67216122F, 1.67296708F, 1.67377293F, 1.67457879F, 1.67538464F,\r\n  1.6761905F, 1.67699635F, 1.67780221F, 1.67860806F, 1.67941391F, 1.68021977F,\r\n  1.68102562F, 1.68183148F, 1.68263733F, 1.68344319F, 1.68424904F, 1.6850549F,\r\n  1.68586075F, 1.68666661F, 1.68747258F, 1.68827844F, 1.68908429F, 1.68989015F,\r\n  1.690696F, 1.69150186F, 1.69230771F, 1.69311357F, 1.69391942F, 1.69472528F,\r\n  1.69553113F, 1.69633698F, 1.69714284F, 1.69794869F, 1.69875455F, 1.6995604F,\r\n  1.70036626F, 1.70117211F, 1.70197797F, 1.70278394F, 1.7035898F, 1.70439565F,\r\n  1.70520151F, 1.70600736F, 1.70681322F, 1.70761907F, 1.70842493F, 1.70923078F,\r\n  1.71003664F, 1.71084249F, 1.71164834F, 1.7124542F, 1.71326F, 1.71406591F,\r\n  1.71487176F, 1.71567762F, 1.71648347F, 1.71728933F, 1.71809518F, 1.71890116F,\r\n  1.71970701F, 1.72051287F, 1.72131872F, 1.72212458F, 1.72293043F, 1.72373629F,\r\n  1.72454214F, 1.725348F, 1.72615385F, 1.72695971F, 1.72776556F, 1.72857141F,\r\n  1.72937727F, 1.73018312F, 1.73098898F, 1.73179483F, 1.73260069F, 1.73340654F,\r\n  1.7342124F, 1.73501837F, 1.73582423F, 1.73663008F, 1.73743594F, 1.73824179F,\r\n  1.73904765F, 1.7398535F, 1.74065936F, 1.74146521F, 1.74227107F, 1.74307692F,\r\n  1.74388278F, 1.74468863F, 1.74549448F, 1.74630034F, 1.74710619F, 1.74791205F,\r\n  1.7487179F, 1.74952376F, 1.75032961F, 1.75113559F, 1.75194144F, 1.7527473F,\r\n  1.75355315F, 1.75435901F, 1.75516486F, 1.75597072F, 1.75677657F, 1.75758243F,\r\n  1.75838828F, 1.75919414F, 1.76F, 1.76080585F, 1.7616117F, 1.76241755F,\r\n  1.76322341F, 1.76402926F, 1.76483512F, 1.76564097F, 1.76644683F, 1.7672528F,\r\n  1.76805866F, 1.76886451F, 1.76967037F, 1.77047622F, 1.77128208F, 1.77208793F,\r\n  1.77289379F, 1.77369964F, 1.7745055F, 1.77531135F, 1.77611721F, 1.77692306F,\r\n  1.77772892F, 1.77853477F, 1.77934062F, 1.78014648F, 1.78095233F, 1.78175819F,\r\n  1.78256404F, 1.78337F, 1.78417587F, 1.78498173F, 1.78578758F, 1.78659344F,\r\n  1.78739929F, 1.78820515F, 1.789011F, 1.78981686F, 1.79062271F, 1.79142857F,\r\n  1.79223442F, 1.79304028F, 1.79384613F, 1.79465199F, 1.79545784F, 1.79626369F,\r\n  1.79706955F, 1.7978754F, 1.79868126F, 1.79948723F, 1.80029309F, 1.80109894F,\r\n  1.8019048F, 1.80271065F, 1.80351651F, 1.80432236F, 1.80512822F, 1.80593407F,\r\n  1.80673993F, 1.80754578F, 1.80835164F, 1.80915749F, 1.80996335F, 1.8107692F,\r\n  1.81157506F, 1.81238091F, 1.81318676F, 1.81399262F, 1.81479859F, 1.81560445F,\r\n  1.8164103F, 1.81721616F, 1.81802201F, 1.81882787F, 1.81963372F, 1.82043958F,\r\n  1.82124543F, 1.82205129F, 1.82285714F, 1.823663F, 1.82446885F, 1.82527471F,\r\n  1.82608056F, 1.82688642F, 1.82769227F, 1.82849813F, 1.82930398F, 1.83010983F,\r\n  1.83091581F, 1.83172166F, 1.83252752F, 1.83333337F, 1.83413923F, 1.83494508F,\r\n  1.83575094F, 1.83655679F, 1.83736265F, 1.8381685F, 1.83897436F, 1.83978021F,\r\n  1.84058607F, 1.84139192F, 1.84219778F, 1.84300363F, 1.84380949F, 1.84461534F,\r\n  1.8454212F, 1.84622705F, 1.84703302F, 1.84783888F, 1.84864473F, 1.84945059F,\r\n  1.85025644F, 1.8510623F, 1.85186815F, 1.85267401F, 1.85347986F, 1.85428572F,\r\n  1.85509157F, 1.85589743F, 1.85670328F, 1.85750914F, 1.85831499F, 1.85912085F,\r\n  1.8599267F, 1.86073256F, 1.86153841F, 1.86234426F, 1.86315024F, 1.86395609F,\r\n  1.86476195F, 1.8655678F, 1.86637366F, 1.86717951F, 1.86798537F, 1.86879122F,\r\n  1.86959708F, 1.87040293F, 1.87120879F, 1.87201464F, 1.8728205F, 1.87362635F,\r\n  1.87443221F, 1.87523806F, 1.87604392F, 1.87684977F, 1.87765563F, 1.87846148F,\r\n  1.87926745F, 1.88007331F, 1.88087916F, 1.88168502F, 1.88249087F, 1.88329673F,\r\n  1.88410258F, 1.88490844F, 1.88571429F, 1.88652015F, 1.887326F, 1.88813186F,\r\n  1.88893771F, 1.88974357F, 1.89054942F, 1.89135528F, 1.89216113F, 1.89296699F,\r\n  1.89377284F, 1.8945787F, 1.89538467F, 1.89619052F, 1.89699638F, 1.89780223F,\r\n  1.89860809F, 1.89941394F, 1.9002198F, 1.90102565F, 1.90183151F, 1.90263736F,\r\n  1.90344322F, 1.90424907F, 1.90505493F, 1.90586078F, 1.90666664F, 1.90747249F,\r\n  1.90827835F, 1.9090842F, 1.90989F, 1.91069603F, 1.91150188F, 1.91230774F,\r\n  1.91311359F, 1.91391945F, 1.9147253F, 1.91553116F, 1.91633701F, 1.91714287F,\r\n  1.91794872F, 1.91875458F, 1.91956043F, 1.92036629F, 1.92117214F, 1.921978F,\r\n  1.92278385F, 1.92358971F, 1.92439556F, 1.92520142F, 1.92600727F, 1.92681324F,\r\n  1.9276191F, 1.92842495F, 1.92923081F, 1.93003666F, 1.93084252F, 1.93164837F,\r\n  1.93245423F, 1.93326008F, 1.93406594F, 1.93487179F, 1.93567765F, 1.9364835F,\r\n  1.93728936F, 1.93809521F, 1.93890107F, 1.93970692F, 1.94051278F, 1.94131863F,\r\n  1.94212449F, 1.94293046F, 1.94373631F, 1.94454217F, 1.94534802F, 1.94615388F,\r\n  1.94695973F, 1.94776559F, 1.94857144F, 1.9493773F, 1.95018315F, 1.95098901F,\r\n  1.95179486F, 1.95260072F, 1.95340657F, 1.95421243F, 1.95501828F, 1.95582414F,\r\n  1.95663F, 1.95743585F, 1.9582417F, 1.95904768F, 1.95985353F, 1.96065938F,\r\n  1.96146524F, 1.96227109F, 1.96307695F, 1.9638828F, 1.96468866F, 1.96549451F,\r\n  1.96630037F, 1.96710622F, 1.96791208F, 1.96871793F, 1.96952379F, 1.97032964F,\r\n  1.9711355F, 1.97194135F, 1.97274721F, 1.97355306F, 1.97435892F, 1.97516489F,\r\n  1.97597075F, 1.9767766F, 1.97758245F, 1.97838831F, 1.97919416F, 1.98F,\r\n  1.98080587F, 1.98161173F, 1.98241758F, 1.98322344F, 1.98402929F, 1.98483515F,\r\n  1.985641F, 1.98644686F, 1.98725271F, 1.98805857F, 1.98886442F, 1.98967028F,\r\n  1.99047613F, 1.99128211F, 1.99208796F, 1.99289382F, 1.99369967F, 1.99450552F,\r\n  1.99531138F, 1.99611723F, 1.99692309F, 1.99772894F, 1.9985348F, 1.99934065F,\r\n  2.00014663F, 2.00095248F, 2.00175834F, 2.00256419F, 2.00337F, 2.0041759F,\r\n  2.00498176F, 2.00578761F, 2.00659347F, 2.00739932F, 2.00820518F, 2.00901103F,\r\n  2.00981688F, 2.01062274F, 2.01142859F, 2.01223445F, 2.0130403F, 2.01384616F,\r\n  2.01465201F, 2.01545787F, 2.01626372F, 2.01706958F, 2.01787543F, 2.01868129F,\r\n  2.01948714F, 2.020293F, 2.02109885F, 2.02190471F, 2.02271056F, 2.02351642F,\r\n  2.02432227F, 2.02512813F, 2.02593398F, 2.02673984F, 2.02754569F, 2.02835155F,\r\n  2.0291574F, 2.02996325F, 2.03076935F, 2.0315752F, 2.03238106F, 2.03318691F,\r\n  2.03399277F, 2.03479862F, 2.03560448F, 2.03641033F, 2.03721619F, 2.03802204F,\r\n  2.0388279F, 2.03963375F, 2.04043961F, 2.04124546F, 2.04205132F, 2.04285717F,\r\n  2.04366302F, 2.04446888F, 2.04527473F, 2.04608059F, 2.04688644F, 2.0476923F,\r\n  2.04849815F, 2.04930401F, 2.05010986F, 2.05091572F, 2.05172157F, 2.05252743F,\r\n  2.05333328F, 2.05413914F, 2.05494499F, 2.05575085F, 2.0565567F, 2.05736256F,\r\n  2.05816841F, 2.05897427F, 2.05978012F, 2.06058598F, 2.06139183F, 2.06219769F,\r\n  2.06300378F, 2.06380963F, 2.06461549F, 2.06542134F, 2.0662272F, 2.06703305F,\r\n  2.06783891F, 2.06864476F, 2.06945062F, 2.07025647F, 2.07106233F, 2.07186818F,\r\n  2.07267404F, 2.07348F, 2.07428575F, 2.0750916F, 2.07589746F, 2.07670331F,\r\n  2.07750916F, 2.07831502F, 2.07912087F, 2.07992673F, 2.08073258F, 2.08153844F,\r\n  2.08234429F, 2.08315015F, 2.083956F, 2.08476186F, 2.08556771F, 2.08637357F,\r\n  2.08717942F, 2.08798528F, 2.08879113F, 2.08959699F, 2.09040284F, 2.0912087F,\r\n  2.09201455F, 2.09282041F, 2.09362626F, 2.09443212F, 2.09523821F, 2.09604406F,\r\n  2.09685F, 2.09765577F, 2.09846163F, 2.09926748F, 2.10007334F, 2.10087919F,\r\n  2.10168505F, 2.1024909F, 2.10329676F, 2.10410261F, 2.10490847F, 2.10571432F,\r\n  2.10652018F, 2.10732603F, 2.10813189F, 2.10893774F, 2.1097436F, 2.11054945F,\r\n  2.1113553F, 2.11216116F, 2.11296701F, 2.11377287F, 2.11457872F, 2.11538458F,\r\n  2.11619043F, 2.11699629F, 2.11780214F, 2.118608F, 2.11941385F, 2.12021971F,\r\n  2.12102556F, 2.12183142F, 2.12263727F, 2.12344313F, 2.12424898F, 2.12505484F,\r\n  2.12586069F, 2.12666678F, 2.12747264F, 2.12827849F, 2.12908435F, 2.1298902F,\r\n  2.13069606F, 2.13150191F, 2.13230777F, 2.13311362F, 2.13391948F, 2.13472533F,\r\n  2.13553119F, 2.13633704F, 2.1371429F, 2.13794875F, 2.13875461F, 2.13956046F,\r\n  2.14036632F, 2.14117217F, 2.14197803F, 2.14278388F, 2.14358974F, 2.14439559F,\r\n  2.14520144F, 2.1460073F, 2.14681315F, 2.14761901F, 2.14842486F, 2.14923072F,\r\n  2.15003657F, 2.15084243F, 2.15164828F, 2.15245414F, 2.15326F, 2.15406585F,\r\n  2.1548717F, 2.15567756F, 2.15648341F, 2.15728927F, 2.15809512F, 2.15890121F,\r\n  2.15970707F, 2.16051292F, 2.16131878F, 2.16212463F, 2.16293049F, 2.16373634F,\r\n  2.1645422F, 2.16534805F, 2.16615391F, 2.16695976F, 2.16776562F, 2.16857147F,\r\n  2.16937733F, 2.17018318F, 2.17098904F, 2.17179489F, 2.17260075F, 2.1734066F,\r\n  2.17421246F, 2.17501831F, 2.17582417F, 2.17663F, 2.17743587F, 2.17824173F,\r\n  2.17904758F, 2.17985344F, 2.18065929F, 2.18146515F, 2.182271F, 2.18307686F,\r\n  2.18388271F, 2.18468857F, 2.18549442F, 2.18630028F, 2.18710613F, 2.18791199F,\r\n  2.18871784F, 2.1895237F, 2.19032955F, 2.19113564F, 2.1919415F, 2.19274735F,\r\n  2.19355321F, 2.19435906F, 2.19516492F, 2.19597077F, 2.19677663F, 2.19758248F,\r\n  2.19838834F, 2.19919419F, 2.2F, 2.2008059F, 2.20161176F, 2.20241761F,\r\n  2.20322347F, 2.20402932F, 2.20483518F, 2.20564103F, 2.20644689F, 2.20725274F,\r\n  2.2080586F, 2.20886445F, 2.20967031F, 2.21047616F, 2.21128201F, 2.21208787F,\r\n  2.21289372F, 2.21369958F, 2.21450543F, 2.21531129F, 2.21611714F, 2.216923F,\r\n  2.21772885F, 2.21853471F, 2.21934056F, 2.22014642F, 2.22095227F, 2.22175813F,\r\n  2.22256422F, 2.22337F, 2.22417593F, 2.22498178F, 2.22578764F, 2.22659349F,\r\n  2.22739935F, 2.2282052F, 2.22901106F, 2.22981691F, 2.23062277F, 2.23142862F,\r\n  2.23223448F, 2.23304033F, 2.23384619F, 2.23465204F, 2.2354579F, 2.23626375F,\r\n  2.23706961F, 2.23787546F, 2.23868132F, 2.23948717F, 2.24029303F, 2.24109888F,\r\n  2.24190474F, 2.24271059F, 2.24351645F, 2.2443223F, 2.24512815F, 2.24593401F,\r\n  2.24673986F, 2.24754572F, 2.24835157F, 2.24915743F, 2.24996328F, 2.25076914F,\r\n  2.25157499F, 2.25238085F, 2.2531867F, 2.25399256F, 2.25479865F, 2.25560451F,\r\n  2.25641036F, 2.25721622F, 2.25802207F, 2.25882792F, 2.25963378F, 2.26043963F,\r\n  2.26124549F, 2.26205134F, 2.2628572F, 2.26366305F, 2.26446891F, 2.26527476F,\r\n  2.26608062F, 2.26688647F, 2.26769233F, 2.26849818F, 2.26930404F, 2.27011F,\r\n  2.27091575F, 2.2717216F, 2.27252746F, 2.27333331F, 2.27413917F, 2.27494502F,\r\n  2.27575088F, 2.27655673F, 2.27736259F, 2.27816844F, 2.27897429F, 2.27978015F,\r\n  2.280586F, 2.28139186F, 2.28219771F, 2.28300357F, 2.28380942F, 2.28461528F,\r\n  2.28542113F, 2.28622699F, 2.28703308F, 2.28783894F, 2.28864479F, 2.28945065F,\r\n  2.2902565F, 2.29106236F, 2.29186821F, 2.29267406F, 2.29348F, 2.29428577F,\r\n  2.29509163F, 2.29589748F, 2.29670334F, 2.29750919F, 2.29831505F, 2.2991209F,\r\n  2.29992676F, 2.30073261F, 2.30153847F, 2.30234432F, 2.30315018F, 2.30395603F,\r\n  2.30476189F, 2.30556774F, 2.3063736F, 2.30717945F, 2.30798531F, 2.30879116F,\r\n  2.30959702F, 2.31040287F, 2.31120872F, 2.31201458F, 2.31282043F, 2.31362629F,\r\n  2.31443214F, 2.315238F, 2.31604385F, 2.31684971F, 2.31765556F, 2.31846166F,\r\n  2.31926751F, 2.32007337F, 2.32087922F, 2.32168508F, 2.32249093F, 2.32329679F,\r\n  2.32410264F, 2.32490849F, 2.32571435F, 2.3265202F, 2.32732606F, 2.32813191F,\r\n  2.32893777F, 2.32974362F, 2.33054948F, 2.33135533F, 2.33216119F, 2.33296704F,\r\n  2.3337729F, 2.33457875F, 2.33538461F, 2.33619046F, 2.33699632F, 2.33780217F,\r\n  2.33860803F, 2.33941388F, 2.34021974F, 2.34102559F, 2.34183145F, 2.3426373F,\r\n  2.34344316F, 2.34424901F, 2.34505486F, 2.34586072F, 2.34666657F, 2.34747243F,\r\n  2.34827828F, 2.34908414F, 2.34989F, 2.35069609F, 2.35150194F, 2.3523078F,\r\n  2.35311365F, 2.35391951F, 2.35472536F, 2.35553122F, 2.35633707F, 2.35714293F,\r\n  2.35794878F, 2.35875463F, 2.35956049F, 2.36036634F, 2.3611722F, 2.36197805F,\r\n  2.36278391F, 2.36358976F, 2.36439562F, 2.36520147F, 2.36600733F, 2.36681318F,\r\n  2.36761904F, 2.36842489F, 2.36923075F, 2.3700366F, 2.37084246F, 2.37164831F,\r\n  2.37245417F, 2.37326F, 2.37406588F, 2.37487173F, 2.37567759F, 2.37648344F,\r\n  2.3772893F, 2.37809515F, 2.378901F, 2.37970686F, 2.38051271F, 2.38131857F,\r\n  2.38212442F, 2.38293052F, 2.38373637F, 2.38454223F, 2.38534808F, 2.38615394F,\r\n  2.38695979F, 2.38776565F, 2.3885715F, 2.38937736F, 2.39018321F, 2.39098907F,\r\n  2.39179492F, 2.39260077F, 2.39340663F, 2.39421248F, 2.39501834F, 2.39582419F,\r\n  2.39663F, 2.3974359F, 2.39824176F, 2.39904761F, 2.39985347F, 2.40065932F,\r\n  2.40146518F, 2.40227103F, 2.40307689F, 2.40388274F, 2.4046886F, 2.40549445F,\r\n  2.40630031F, 2.40710616F, 2.40791202F, 2.40871787F, 2.40952373F, 2.41032958F,\r\n  2.41113544F, 2.41194129F, 2.41274714F, 2.413553F, 2.41435909F, 2.41516495F,\r\n  2.4159708F, 2.41677666F, 2.41758251F, 2.41838837F, 2.41919422F, 2.42F,\r\n  2.42080593F, 2.42161179F, 2.42241764F, 2.4232235F, 2.42402935F, 2.42483521F,\r\n  2.42564106F, 2.42644691F, 2.42725277F, 2.42805862F, 2.42886448F, 2.42967033F,\r\n  2.43047619F, 2.43128204F, 2.4320879F, 2.43289375F, 2.43369961F, 2.43450546F,\r\n  2.43531132F, 2.43611717F, 2.43692303F, 2.43772888F, 2.43853474F, 2.43934059F,\r\n  2.44014645F, 2.4409523F, 2.44175816F, 2.44256401F, 2.44336987F, 2.44417572F,\r\n  2.44498158F, 2.44578743F, 2.44659352F, 2.44739938F, 2.44820523F, 2.44901109F,\r\n  2.44981694F, 2.4506228F, 2.45142865F, 2.45223451F, 2.45304036F, 2.45384622F,\r\n  2.45465207F, 2.45545793F, 2.45626378F, 2.45706964F, 2.45787549F, 2.45868134F,\r\n  2.4594872F, 2.46029305F, 2.46109891F, 2.46190476F, 2.46271062F, 2.46351647F,\r\n  2.46432233F, 2.46512818F, 2.46593404F, 2.46674F, 2.46754575F, 2.4683516F,\r\n  2.46915746F, 2.46996331F, 2.47076917F, 2.47157502F, 2.47238088F, 2.47318673F,\r\n  2.47399259F, 2.47479844F, 2.4756043F, 2.47641015F, 2.47721601F, 2.47802186F,\r\n  2.47882795F, 2.47963381F, 2.48043966F, 2.48124552F, 2.48205137F, 2.48285723F,\r\n  2.48366308F, 2.48446894F, 2.48527479F, 2.48608065F, 2.4868865F, 2.48769236F,\r\n  2.48849821F, 2.48930407F, 2.49011F, 2.49091578F, 2.49172163F, 2.49252748F,\r\n  2.49333334F, 2.49413919F, 2.49494505F, 2.4957509F, 2.49655676F, 2.49736261F,\r\n  2.49816847F, 2.49897432F, 2.49978018F, 2.50058603F, 2.50139189F, 2.50219774F,\r\n  2.5030036F, 2.50380945F, 2.50461531F, 2.50542116F, 2.50622702F, 2.50703287F,\r\n  2.50783873F, 2.50864458F, 2.50945044F, 2.51025653F, 2.51106238F, 2.51186824F,\r\n  2.51267409F, 2.51348F, 2.5142858F, 2.51509166F, 2.51589751F, 2.51670337F,\r\n  2.51750922F, 2.51831508F, 2.51912093F, 2.51992679F, 2.52073264F, 2.5215385F,\r\n  2.52234435F, 2.52315021F, 2.52395606F, 2.52476192F, 2.52556777F, 2.52637362F,\r\n  2.52717948F, 2.52798533F, 2.52879119F, 2.52959704F, 2.5304029F, 2.53120875F,\r\n  2.53201461F, 2.53282046F, 2.53362632F, 2.53443217F, 2.53523803F, 2.53604388F,\r\n  2.53684974F, 2.53765559F, 2.53846145F, 2.5392673F, 2.54007316F, 2.54087901F,\r\n  2.54168487F, 2.54249096F, 2.54329681F, 2.54410267F, 2.54490852F, 2.54571438F,\r\n  2.54652023F, 2.54732609F, 2.54813194F, 2.5489378F, 2.54974365F, 2.55054951F,\r\n  2.55135536F, 2.55216122F, 2.55296707F, 2.55377293F, 2.55457878F, 2.55538464F,\r\n  2.55619049F, 2.55699635F, 2.5578022F, 2.55860806F, 2.55941391F, 2.56021976F,\r\n  2.56102562F, 2.56183147F, 2.56263733F, 2.56344318F, 2.56424904F, 2.56505489F,\r\n  2.56586075F, 2.5666666F, 2.56747246F, 2.56827831F, 2.56908417F, 2.56989F,\r\n  2.57069588F, 2.57150173F, 2.57230759F, 2.57311344F, 2.5739193F, 2.57472539F,\r\n  2.57553124F, 2.5763371F, 2.57714295F, 2.57794881F, 2.57875466F, 2.57956052F,\r\n  2.58036637F, 2.58117223F, 2.58197808F, 2.58278394F, 2.58358979F, 2.58439565F,\r\n  2.5852015F, 2.58600736F, 2.58681321F, 2.58761907F, 2.58842492F, 2.58923078F,\r\n  2.59003663F, 2.59084249F, 2.59164834F, 2.5924542F, 2.59326F, 2.5940659F,\r\n  2.59487176F, 2.59567761F, 2.59648347F, 2.59728932F, 2.59809518F, 2.59890103F,\r\n  2.59970689F, 2.60051274F, 2.6013186F, 2.60212445F, 2.60293031F, 2.60373616F,\r\n  2.60454202F, 2.60534787F, 2.60615396F, 2.60695982F, 2.60776567F, 2.60857153F,\r\n  2.60937738F, 2.61018324F, 2.61098909F, 2.61179495F, 2.6126008F, 2.61340666F,\r\n  2.61421251F, 2.61501837F, 2.61582422F, 2.61663F, 2.61743593F, 2.61824179F,\r\n  2.61904764F, 2.6198535F, 2.62065935F, 2.62146521F, 2.62227106F, 2.62307692F,\r\n  2.62388277F, 2.62468863F, 2.62549448F, 2.62630033F, 2.62710619F, 2.62791204F,\r\n  2.6287179F, 2.62952375F, 2.63032961F, 2.63113546F, 2.63194132F, 2.63274717F,\r\n  2.63355303F, 2.63435888F, 2.63516474F, 2.63597059F, 2.63677645F, 2.6375823F,\r\n  2.6383884F, 2.63919425F, 2.64F, 2.64080596F, 2.64161181F, 2.64241767F,\r\n  2.64322352F, 2.64402938F, 2.64483523F, 2.64564109F, 2.64644694F, 2.6472528F,\r\n  2.64805865F, 2.64886451F, 2.64967036F, 2.65047622F, 2.65128207F, 2.65208793F,\r\n  2.65289378F, 2.65369964F, 2.65450549F, 2.65531135F, 2.6561172F, 2.65692306F,\r\n  2.65772891F, 2.65853477F, 2.65934062F, 2.66014647F, 2.66095233F, 2.66175818F,\r\n  2.66256404F, 2.66337F, 2.66417575F, 2.6649816F, 2.66578746F, 2.66659331F,\r\n  2.66739917F, 2.66820502F, 2.66901088F, 2.66981673F, 2.67062283F, 2.67142868F,\r\n  2.67223454F, 2.67304039F, 2.67384624F, 2.6746521F, 2.67545795F, 2.67626381F,\r\n  2.67706966F, 2.67787552F, 2.67868137F, 2.67948723F, 2.68029308F, 2.68109894F,\r\n  2.68190479F, 2.68271065F, 2.6835165F, 2.68432236F, 2.68512821F, 2.68593407F,\r\n  2.68674F, 2.68754578F, 2.68835163F, 2.68915749F, 2.68996334F, 2.6907692F,\r\n  2.69157505F, 2.69238091F, 2.69318676F, 2.69399261F, 2.69479847F, 2.69560432F,\r\n  2.69641018F, 2.69721603F, 2.69802189F, 2.69882774F, 2.6996336F, 2.70043945F,\r\n  2.70124531F, 2.7020514F, 2.70285726F, 2.70366311F, 2.70446897F, 2.70527482F,\r\n  2.70608068F, 2.70688653F, 2.70769238F, 2.70849824F, 2.70930409F, 2.71011F,\r\n  2.7109158F, 2.71172166F, 2.71252751F, 2.71333337F, 2.71413922F, 2.71494508F,\r\n  2.71575093F, 2.71655679F, 2.71736264F, 2.7181685F, 2.71897435F, 2.71978021F,\r\n  2.72058606F, 2.72139192F, 2.72219777F, 2.72300363F, 2.72380948F, 2.72461534F,\r\n  2.72542119F, 2.72622705F, 2.7270329F, 2.72783875F, 2.72864461F, 2.72945046F,\r\n  2.73025632F, 2.73106217F, 2.73186803F, 2.73267388F, 2.73347974F, 2.73428583F,\r\n  2.73509169F, 2.73589754F, 2.7367034F, 2.73750925F, 2.73831511F, 2.73912096F,\r\n  2.73992682F, 2.74073267F, 2.74153852F, 2.74234438F, 2.74315023F, 2.74395609F,\r\n  2.74476194F, 2.7455678F, 2.74637365F, 2.74717951F, 2.74798536F, 2.74879122F,\r\n  2.74959707F, 2.75040293F, 2.75120878F, 2.75201464F, 2.75282049F, 2.75362635F,\r\n  2.7544322F, 2.75523806F, 2.75604391F, 2.75684977F, 2.75765562F, 2.75846148F,\r\n  2.75926733F, 2.76007318F, 2.76087904F, 2.76168489F, 2.76249075F, 2.7632966F,\r\n  2.76410246F, 2.76490831F, 2.76571417F, 2.76652026F, 2.76732612F, 2.76813197F,\r\n  2.76893783F, 2.76974368F, 2.77054954F, 2.77135539F, 2.77216125F, 2.7729671F,\r\n  2.77377295F, 2.77457881F, 2.77538466F, 2.77619052F, 2.77699637F, 2.77780223F,\r\n  2.77860808F, 2.77941394F, 2.78021979F, 2.78102565F, 2.7818315F, 2.78263736F,\r\n  2.78344321F, 2.78424907F, 2.78505492F, 2.78586078F, 2.78666663F, 2.78747249F,\r\n  2.78827834F, 2.7890842F, 2.78989F, 2.79069591F, 2.79150176F, 2.79230762F,\r\n  2.79311347F, 2.79391932F, 2.79472518F, 2.79553103F, 2.79633689F, 2.79714274F,\r\n  2.7979486F, 2.79875469F, 2.79956055F, 2.8003664F, 2.80117226F, 2.80197811F,\r\n  2.80278397F, 2.80358982F, 2.80439568F, 2.80520153F, 2.80600739F, 2.80681324F,\r\n  2.80761909F, 2.80842495F, 2.8092308F, 2.81003666F, 2.81084251F, 2.81164837F,\r\n  2.81245422F, 2.81326F, 2.81406593F, 2.81487179F, 2.81567764F, 2.8164835F,\r\n  2.81728935F, 2.81809521F, 2.81890106F, 2.81970692F, 2.82051277F, 2.82131863F,\r\n  2.82212448F, 2.82293034F, 2.82373619F, 2.82454205F, 2.8253479F, 2.82615376F,\r\n  2.82695961F, 2.82776546F, 2.82857132F, 2.82937717F, 2.83018327F, 2.83098912F,\r\n  2.83179498F, 2.83260083F, 2.83340669F, 2.83421254F, 2.8350184F, 2.83582425F,\r\n  2.83663F, 2.83743596F, 2.83824182F, 2.83904767F, 2.83985353F, 2.84065938F,\r\n  2.84146523F, 2.84227109F, 2.84307694F, 2.8438828F, 2.84468865F, 2.84549451F,\r\n  2.84630036F, 2.84710622F, 2.84791207F, 2.84871793F, 2.84952378F, 2.85032964F,\r\n  2.85113549F, 2.85194135F, 2.8527472F, 2.85355306F, 2.85435891F, 2.85516477F,\r\n  2.85597062F, 2.85677648F, 2.85758233F, 2.85838819F, 2.85919404F, 2.86F,\r\n  2.86080575F, 2.8616116F, 2.8624177F, 2.86322355F, 2.86402941F, 2.86483526F,\r\n  2.86564112F, 2.86644697F, 2.86725283F, 2.86805868F, 2.86886454F, 2.86967039F,\r\n  2.87047625F, 2.8712821F, 2.87208796F, 2.87289381F, 2.87369967F, 2.87450552F,\r\n  2.87531137F, 2.87611723F, 2.87692308F, 2.87772894F, 2.87853479F, 2.87934065F,\r\n  2.8801465F, 2.88095236F, 2.88175821F, 2.88256407F, 2.88337F, 2.88417578F,\r\n  2.88498163F, 2.88578749F, 2.88659334F, 2.8873992F, 2.88820505F, 2.88901091F,\r\n  2.88981676F, 2.89062262F, 2.89142847F, 2.89223433F, 2.89304018F, 2.89384604F,\r\n  2.89465213F, 2.89545798F, 2.89626384F, 2.89706969F, 2.89787555F, 2.8986814F,\r\n  2.89948726F, 2.90029311F, 2.90109897F, 2.90190482F, 2.90271068F, 2.90351653F,\r\n  2.90432239F, 2.90512824F, 2.9059341F, 2.90674F, 2.9075458F, 2.90835166F,\r\n  2.90915751F, 2.90996337F, 2.91076922F, 2.91157508F, 2.91238093F, 2.91318679F,\r\n  2.91399264F, 2.9147985F, 2.91560435F, 2.91641021F, 2.91721606F, 2.91802192F,\r\n  2.91882777F, 2.91963363F, 2.92043948F, 2.92124534F, 2.92205119F, 2.92285705F,\r\n  2.9236629F, 2.92446876F, 2.92527461F, 2.9260807F, 2.92688656F, 2.92769241F,\r\n  2.92849827F, 2.92930412F, 2.93011F, 2.93091583F, 2.93172169F, 2.93252754F,\r\n  2.9333334F, 2.93413925F, 2.93494511F, 2.93575096F, 2.93655682F, 2.93736267F,\r\n  2.93816853F, 2.93897438F, 2.93978024F, 2.94058609F, 2.94139194F, 2.9421978F,\r\n  2.94300365F, 2.94380951F, 2.94461536F, 2.94542122F, 2.94622707F, 2.94703293F,\r\n  2.94783878F, 2.94864464F, 2.94945049F, 2.95025635F, 2.9510622F, 2.95186806F,\r\n  2.95267391F, 2.95347977F, 2.95428562F, 2.95509148F, 2.95589733F, 2.95670319F,\r\n  2.95750904F, 2.95831513F, 2.95912099F, 2.95992684F, 2.9607327F, 2.96153855F,\r\n  2.96234441F, 2.96315026F, 2.96395612F, 2.96476197F, 2.96556783F, 2.96637368F,\r\n  2.96717954F, 2.96798539F, 2.96879125F, 2.9695971F, 2.97040296F, 2.97120881F,\r\n  2.97201467F, 2.97282052F, 2.97362638F, 2.97443223F, 2.97523808F, 2.97604394F,\r\n  2.97684979F, 2.97765565F, 2.9784615F, 2.97926736F, 2.98007321F, 2.98087907F,\r\n  2.98168492F, 2.98249078F, 2.98329663F, 2.98410249F, 2.98490834F, 2.9857142F,\r\n  2.98652F, 2.98732591F, 2.98813176F, 2.98893762F, 2.98974347F, 2.99054956F,\r\n  2.99135542F, 2.99216127F, 2.99296713F, 2.99377298F, 2.99457884F, 2.99538469F,\r\n  2.99619055F, 2.9969964F, 2.99780226F, 2.99860811F, 2.99941397F, 3.00021982F,\r\n  3.00102568F, 3.00183153F, 3.00263739F, 3.00344324F, 3.0042491F, 3.00505495F,\r\n  3.00586081F, 3.00666666F, 3.00747252F, 3.00827837F, 3.00908422F, 3.00989F,\r\n  3.01069593F, 3.01150179F, 3.01230764F, 3.0131135F, 3.01391935F, 3.01472521F,\r\n  3.01553106F, 3.01633692F, 3.01714277F, 3.01794863F, 3.01875448F, 3.01956034F,\r\n  3.02036619F, 3.02117205F, 3.02197814F, 3.02278399F, 3.02358985F, 3.0243957F,\r\n  3.02520156F, 3.02600741F, 3.02681327F, 3.02761912F, 3.02842498F, 3.02923083F,\r\n  3.03003669F, 3.03084254F, 3.0316484F, 3.03245425F, 3.03326F, 3.03406596F,\r\n  3.03487182F, 3.03567767F, 3.03648353F, 3.03728938F, 3.03809524F, 3.03890109F,\r\n  3.03970695F, 3.0405128F, 3.04131866F, 3.04212451F, 3.04293036F, 3.04373622F,\r\n  3.04454207F, 3.04534793F, 3.04615378F, 3.04695964F, 3.04776549F, 3.04857135F,\r\n  3.0493772F, 3.05018306F, 3.05098891F, 3.05179477F, 3.05260062F, 3.05340648F,\r\n  3.05421257F, 3.05501842F, 3.05582428F, 3.05663013F, 3.05743599F, 3.05824184F,\r\n  3.0590477F, 3.05985355F, 3.06065941F, 3.06146526F, 3.06227112F, 3.06307697F,\r\n  3.06388283F, 3.06468868F, 3.06549454F, 3.06630039F, 3.06710625F, 3.0679121F,\r\n  3.06871796F, 3.06952381F, 3.07032967F, 3.07113552F, 3.07194138F, 3.07274723F,\r\n  3.07355309F, 3.07435894F, 3.07516479F, 3.07597065F, 3.0767765F, 3.07758236F,\r\n  3.07838821F, 3.07919407F, 3.08F, 3.08080578F, 3.08161163F, 3.08241749F,\r\n  3.08322334F, 3.0840292F, 3.08483505F, 3.08564091F, 3.086447F, 3.08725286F,\r\n  3.08805871F, 3.08886456F, 3.08967042F, 3.09047627F, 3.09128213F, 3.09208798F,\r\n  3.09289384F, 3.09369969F, 3.09450555F, 3.0953114F, 3.09611726F, 3.09692311F,\r\n  3.09772897F, 3.09853482F, 3.09934068F, 3.10014653F, 3.10095239F, 3.10175824F,\r\n  3.1025641F, 3.10337F, 3.10417581F, 3.10498166F, 3.10578752F, 3.10659337F,\r\n  3.10739923F, 3.10820508F, 3.10901093F, 3.10981679F, 3.11062264F, 3.1114285F,\r\n  3.11223435F, 3.11304021F, 3.11384606F, 3.11465192F, 3.11545777F, 3.11626363F,\r\n  3.11706948F, 3.11787558F, 3.11868143F, 3.11948729F, 3.12029314F, 3.121099F,\r\n  3.12190485F, 3.1227107F, 3.12351656F, 3.12432241F, 3.12512827F, 3.12593412F,\r\n  3.12674F, 3.12754583F, 3.12835169F, 3.12915754F, 3.1299634F, 3.13076925F,\r\n  3.13157511F, 3.13238096F, 3.13318682F, 3.13399267F, 3.13479853F, 3.13560438F,\r\n  3.13641024F, 3.13721609F, 3.13802195F, 3.1388278F, 3.13963366F, 3.14043951F,\r\n  3.14124537F, 3.14205122F, 3.14285707F, 3.14366293F, 3.14446878F, 3.14527464F,\r\n  3.14608049F, 3.14688635F, 3.1476922F, 3.14849806F, 3.14930391F, 3.15011F,\r\n  3.15091586F, 3.15172172F, 3.15252757F, 3.15333343F, 3.15413928F, 3.15494514F,\r\n  3.15575099F, 3.15655684F, 3.1573627F, 3.15816855F, 3.15897441F, 3.15978026F,\r\n  3.16058612F, 3.16139197F, 3.16219783F, 3.16300368F, 3.16380954F, 3.16461539F,\r\n  3.16542125F, 3.1662271F, 3.16703296F, 3.16783881F, 3.16864467F, 3.16945052F,\r\n  3.17025638F, 3.17106223F, 3.17186809F, 3.17267394F, 3.1734798F, 3.17428565F,\r\n  3.17509151F, 3.17589736F, 3.17670321F, 3.17750907F, 3.17831492F, 3.17912078F,\r\n  3.17992663F, 3.18073249F, 3.18153834F, 3.18234444F, 3.18315029F, 3.18395615F,\r\n  3.184762F, 3.18556786F, 3.18637371F, 3.18717957F, 3.18798542F, 3.18879128F,\r\n  3.18959713F, 3.19040298F, 3.19120884F, 3.19201469F, 3.19282055F, 3.1936264F,\r\n  3.19443226F, 3.19523811F, 3.19604397F, 3.19684982F, 3.19765568F, 3.19846153F,\r\n  3.19926739F, 3.20007324F, 3.2008791F, 3.20168495F, 3.20249081F, 3.20329666F,\r\n  3.20410252F, 3.20490837F, 3.20571423F, 3.20652F, 3.20732594F, 3.20813179F,\r\n  3.20893764F, 3.2097435F, 3.21054935F, 3.21135521F, 3.21216106F, 3.21296692F,\r\n  3.21377301F, 3.21457887F, 3.21538472F, 3.21619058F, 3.21699643F, 3.21780229F,\r\n  3.21860814F, 3.219414F, 3.22021985F, 3.22102571F, 3.22183156F, 3.22263741F,\r\n  3.22344327F, 3.22424912F, 3.22505498F, 3.22586083F, 3.22666669F, 3.22747254F,\r\n  3.2282784F, 3.22908425F, 3.22989F, 3.23069596F, 3.23150182F, 3.23230767F,\r\n  3.23311353F, 3.23391938F, 3.23472524F, 3.23553109F, 3.23633695F, 3.2371428F,\r\n  3.23794866F, 3.23875451F, 3.23956037F, 3.24036622F, 3.24117208F, 3.24197793F,\r\n  3.24278378F, 3.24358964F, 3.24439549F, 3.24520135F, 3.24600744F, 3.2468133F,\r\n  3.24761915F, 3.24842501F, 3.24923086F, 3.25003672F, 3.25084257F, 3.25164843F,\r\n  3.25245428F, 3.25326014F, 3.25406599F, 3.25487185F, 3.2556777F, 3.25648355F,\r\n  3.25728941F, 3.25809526F, 3.25890112F, 3.25970697F, 3.26051283F, 3.26131868F,\r\n  3.26212454F, 3.26293039F, 3.26373625F, 3.2645421F, 3.26534796F, 3.26615381F,\r\n  3.26695967F, 3.26776552F, 3.26857138F, 3.26937723F, 3.27018309F, 3.27098894F,\r\n  3.2717948F, 3.27260065F, 3.27340651F, 3.27421236F, 3.27501822F, 3.27582407F,\r\n  3.27663F, 3.27743578F, 3.27824187F, 3.27904773F, 3.27985358F, 3.28065944F,\r\n  3.28146529F, 3.28227115F, 3.283077F, 3.28388286F, 3.28468871F, 3.28549457F,\r\n  3.28630042F, 3.28710628F, 3.28791213F, 3.28871799F, 3.28952384F, 3.29032969F,\r\n  3.29113555F, 3.2919414F, 3.29274726F, 3.29355311F, 3.29435897F, 3.29516482F,\r\n  3.29597068F, 3.29677653F, 3.29758239F, 3.29838824F, 3.2991941F, 3.3F } ;\r\n\r\nextern const real32_T rtCP_pooled_so29yfSh0d1Q[4096];\r\nconst real32_T rtCP_pooled_so29yfSh0d1Q[4096] = { 0.0F, 1.0F, 2.0F, 3.0F, 4.0F,\r\n  5.0F, 6.0F, 7.0F, 8.0F, 9.0F, 10.0F, 11.0F, 12.0F, 13.0F, 14.0F, 15.0F, 16.0F,\r\n  17.0F, 18.0F, 19.0F, 20.0F, 21.0F, 22.0F, 23.0F, 24.0F, 25.0F, 26.0F, 27.0F,\r\n  28.0F, 29.0F, 30.0F, 31.0F, 32.0F, 33.0F, 34.0F, 35.0F, 36.0F, 37.0F, 38.0F,\r\n  39.0F, 40.0F, 41.0F, 42.0F, 43.0F, 44.0F, 45.0F, 46.0F, 47.0F, 48.0F, 49.0F,\r\n  50.0F, 51.0F, 52.0F, 53.0F, 54.0F, 55.0F, 56.0F, 57.0F, 58.0F, 59.0F, 60.0F,\r\n  61.0F, 62.0F, 63.0F, 64.0F, 65.0F, 66.0F, 67.0F, 68.0F, 69.0F, 70.0F, 71.0F,\r\n  72.0F, 73.0F, 74.0F, 75.0F, 76.0F, 77.0F, 78.0F, 79.0F, 80.0F, 81.0F, 82.0F,\r\n  83.0F, 84.0F, 85.0F, 86.0F, 87.0F, 88.0F, 89.0F, 90.0F, 91.0F, 92.0F, 93.0F,\r\n  94.0F, 95.0F, 96.0F, 97.0F, 98.0F, 99.0F, 100.0F, 101.0F, 102.0F, 103.0F,\r\n  104.0F, 105.0F, 106.0F, 107.0F, 108.0F, 109.0F, 110.0F, 111.0F, 112.0F, 113.0F,\r\n  114.0F, 115.0F, 116.0F, 117.0F, 118.0F, 119.0F, 120.0F, 121.0F, 122.0F, 123.0F,\r\n  124.0F, 125.0F, 126.0F, 127.0F, 128.0F, 129.0F, 130.0F, 131.0F, 132.0F, 133.0F,\r\n  134.0F, 135.0F, 136.0F, 137.0F, 138.0F, 139.0F, 140.0F, 141.0F, 142.0F, 143.0F,\r\n  144.0F, 145.0F, 146.0F, 147.0F, 148.0F, 149.0F, 150.0F, 151.0F, 152.0F, 153.0F,\r\n  154.0F, 155.0F, 156.0F, 157.0F, 158.0F, 159.0F, 160.0F, 161.0F, 162.0F, 163.0F,\r\n  164.0F, 165.0F, 166.0F, 167.0F, 168.0F, 169.0F, 170.0F, 171.0F, 172.0F, 173.0F,\r\n  174.0F, 175.0F, 176.0F, 177.0F, 178.0F, 179.0F, 180.0F, 181.0F, 182.0F, 183.0F,\r\n  184.0F, 185.0F, 186.0F, 187.0F, 188.0F, 189.0F, 190.0F, 191.0F, 192.0F, 193.0F,\r\n  194.0F, 195.0F, 196.0F, 197.0F, 198.0F, 199.0F, 200.0F, 201.0F, 202.0F, 203.0F,\r\n  204.0F, 205.0F, 206.0F, 207.0F, 208.0F, 209.0F, 210.0F, 211.0F, 212.0F, 213.0F,\r\n  214.0F, 215.0F, 216.0F, 217.0F, 218.0F, 219.0F, 220.0F, 221.0F, 222.0F, 223.0F,\r\n  224.0F, 225.0F, 226.0F, 227.0F, 228.0F, 229.0F, 230.0F, 231.0F, 232.0F, 233.0F,\r\n  234.0F, 235.0F, 236.0F, 237.0F, 238.0F, 239.0F, 240.0F, 241.0F, 242.0F, 243.0F,\r\n  244.0F, 245.0F, 246.0F, 247.0F, 248.0F, 249.0F, 250.0F, 251.0F, 252.0F, 253.0F,\r\n  254.0F, 255.0F, 256.0F, 257.0F, 258.0F, 259.0F, 260.0F, 261.0F, 262.0F, 263.0F,\r\n  264.0F, 265.0F, 266.0F, 267.0F, 268.0F, 269.0F, 270.0F, 271.0F, 272.0F, 273.0F,\r\n  274.0F, 275.0F, 276.0F, 277.0F, 278.0F, 279.0F, 280.0F, 281.0F, 282.0F, 283.0F,\r\n  284.0F, 285.0F, 286.0F, 287.0F, 288.0F, 289.0F, 290.0F, 291.0F, 292.0F, 293.0F,\r\n  294.0F, 295.0F, 296.0F, 297.0F, 298.0F, 299.0F, 300.0F, 301.0F, 302.0F, 303.0F,\r\n  304.0F, 305.0F, 306.0F, 307.0F, 308.0F, 309.0F, 310.0F, 311.0F, 312.0F, 313.0F,\r\n  314.0F, 315.0F, 316.0F, 317.0F, 318.0F, 319.0F, 320.0F, 321.0F, 322.0F, 323.0F,\r\n  324.0F, 325.0F, 326.0F, 327.0F, 328.0F, 329.0F, 330.0F, 331.0F, 332.0F, 333.0F,\r\n  334.0F, 335.0F, 336.0F, 337.0F, 338.0F, 339.0F, 340.0F, 341.0F, 342.0F, 343.0F,\r\n  344.0F, 345.0F, 346.0F, 347.0F, 348.0F, 349.0F, 350.0F, 351.0F, 352.0F, 353.0F,\r\n  354.0F, 355.0F, 356.0F, 357.0F, 358.0F, 359.0F, 360.0F, 361.0F, 362.0F, 363.0F,\r\n  364.0F, 365.0F, 366.0F, 367.0F, 368.0F, 369.0F, 370.0F, 371.0F, 372.0F, 373.0F,\r\n  374.0F, 375.0F, 376.0F, 377.0F, 378.0F, 379.0F, 380.0F, 381.0F, 382.0F, 383.0F,\r\n  384.0F, 385.0F, 386.0F, 387.0F, 388.0F, 389.0F, 390.0F, 391.0F, 392.0F, 393.0F,\r\n  394.0F, 395.0F, 396.0F, 397.0F, 398.0F, 399.0F, 400.0F, 401.0F, 402.0F, 403.0F,\r\n  404.0F, 405.0F, 406.0F, 407.0F, 408.0F, 409.0F, 410.0F, 411.0F, 412.0F, 413.0F,\r\n  414.0F, 415.0F, 416.0F, 417.0F, 418.0F, 419.0F, 420.0F, 421.0F, 422.0F, 423.0F,\r\n  424.0F, 425.0F, 426.0F, 427.0F, 428.0F, 429.0F, 430.0F, 431.0F, 432.0F, 433.0F,\r\n  434.0F, 435.0F, 436.0F, 437.0F, 438.0F, 439.0F, 440.0F, 441.0F, 442.0F, 443.0F,\r\n  444.0F, 445.0F, 446.0F, 447.0F, 448.0F, 449.0F, 450.0F, 451.0F, 452.0F, 453.0F,\r\n  454.0F, 455.0F, 456.0F, 457.0F, 458.0F, 459.0F, 460.0F, 461.0F, 462.0F, 463.0F,\r\n  464.0F, 465.0F, 466.0F, 467.0F, 468.0F, 469.0F, 470.0F, 471.0F, 472.0F, 473.0F,\r\n  474.0F, 475.0F, 476.0F, 477.0F, 478.0F, 479.0F, 480.0F, 481.0F, 482.0F, 483.0F,\r\n  484.0F, 485.0F, 486.0F, 487.0F, 488.0F, 489.0F, 490.0F, 491.0F, 492.0F, 493.0F,\r\n  494.0F, 495.0F, 496.0F, 497.0F, 498.0F, 499.0F, 500.0F, 501.0F, 502.0F, 503.0F,\r\n  504.0F, 505.0F, 506.0F, 507.0F, 508.0F, 509.0F, 510.0F, 511.0F, 512.0F, 513.0F,\r\n  514.0F, 515.0F, 516.0F, 517.0F, 518.0F, 519.0F, 520.0F, 521.0F, 522.0F, 523.0F,\r\n  524.0F, 525.0F, 526.0F, 527.0F, 528.0F, 529.0F, 530.0F, 531.0F, 532.0F, 533.0F,\r\n  534.0F, 535.0F, 536.0F, 537.0F, 538.0F, 539.0F, 540.0F, 541.0F, 542.0F, 543.0F,\r\n  544.0F, 545.0F, 546.0F, 547.0F, 548.0F, 549.0F, 550.0F, 551.0F, 552.0F, 553.0F,\r\n  554.0F, 555.0F, 556.0F, 557.0F, 558.0F, 559.0F, 560.0F, 561.0F, 562.0F, 563.0F,\r\n  564.0F, 565.0F, 566.0F, 567.0F, 568.0F, 569.0F, 570.0F, 571.0F, 572.0F, 573.0F,\r\n  574.0F, 575.0F, 576.0F, 577.0F, 578.0F, 579.0F, 580.0F, 581.0F, 582.0F, 583.0F,\r\n  584.0F, 585.0F, 586.0F, 587.0F, 588.0F, 589.0F, 590.0F, 591.0F, 592.0F, 593.0F,\r\n  594.0F, 595.0F, 596.0F, 597.0F, 598.0F, 599.0F, 600.0F, 601.0F, 602.0F, 603.0F,\r\n  604.0F, 605.0F, 606.0F, 607.0F, 608.0F, 609.0F, 610.0F, 611.0F, 612.0F, 613.0F,\r\n  614.0F, 615.0F, 616.0F, 617.0F, 618.0F, 619.0F, 620.0F, 621.0F, 622.0F, 623.0F,\r\n  624.0F, 625.0F, 626.0F, 627.0F, 628.0F, 629.0F, 630.0F, 631.0F, 632.0F, 633.0F,\r\n  634.0F, 635.0F, 636.0F, 637.0F, 638.0F, 639.0F, 640.0F, 641.0F, 642.0F, 643.0F,\r\n  644.0F, 645.0F, 646.0F, 647.0F, 648.0F, 649.0F, 650.0F, 651.0F, 652.0F, 653.0F,\r\n  654.0F, 655.0F, 656.0F, 657.0F, 658.0F, 659.0F, 660.0F, 661.0F, 662.0F, 663.0F,\r\n  664.0F, 665.0F, 666.0F, 667.0F, 668.0F, 669.0F, 670.0F, 671.0F, 672.0F, 673.0F,\r\n  674.0F, 675.0F, 676.0F, 677.0F, 678.0F, 679.0F, 680.0F, 681.0F, 682.0F, 683.0F,\r\n  684.0F, 685.0F, 686.0F, 687.0F, 688.0F, 689.0F, 690.0F, 691.0F, 692.0F, 693.0F,\r\n  694.0F, 695.0F, 696.0F, 697.0F, 698.0F, 699.0F, 700.0F, 701.0F, 702.0F, 703.0F,\r\n  704.0F, 705.0F, 706.0F, 707.0F, 708.0F, 709.0F, 710.0F, 711.0F, 712.0F, 713.0F,\r\n  714.0F, 715.0F, 716.0F, 717.0F, 718.0F, 719.0F, 720.0F, 721.0F, 722.0F, 723.0F,\r\n  724.0F, 725.0F, 726.0F, 727.0F, 728.0F, 729.0F, 730.0F, 731.0F, 732.0F, 733.0F,\r\n  734.0F, 735.0F, 736.0F, 737.0F, 738.0F, 739.0F, 740.0F, 741.0F, 742.0F, 743.0F,\r\n  744.0F, 745.0F, 746.0F, 747.0F, 748.0F, 749.0F, 750.0F, 751.0F, 752.0F, 753.0F,\r\n  754.0F, 755.0F, 756.0F, 757.0F, 758.0F, 759.0F, 760.0F, 761.0F, 762.0F, 763.0F,\r\n  764.0F, 765.0F, 766.0F, 767.0F, 768.0F, 769.0F, 770.0F, 771.0F, 772.0F, 773.0F,\r\n  774.0F, 775.0F, 776.0F, 777.0F, 778.0F, 779.0F, 780.0F, 781.0F, 782.0F, 783.0F,\r\n  784.0F, 785.0F, 786.0F, 787.0F, 788.0F, 789.0F, 790.0F, 791.0F, 792.0F, 793.0F,\r\n  794.0F, 795.0F, 796.0F, 797.0F, 798.0F, 799.0F, 800.0F, 801.0F, 802.0F, 803.0F,\r\n  804.0F, 805.0F, 806.0F, 807.0F, 808.0F, 809.0F, 810.0F, 811.0F, 812.0F, 813.0F,\r\n  814.0F, 815.0F, 816.0F, 817.0F, 818.0F, 819.0F, 820.0F, 821.0F, 822.0F, 823.0F,\r\n  824.0F, 825.0F, 826.0F, 827.0F, 828.0F, 829.0F, 830.0F, 831.0F, 832.0F, 833.0F,\r\n  834.0F, 835.0F, 836.0F, 837.0F, 838.0F, 839.0F, 840.0F, 841.0F, 842.0F, 843.0F,\r\n  844.0F, 845.0F, 846.0F, 847.0F, 848.0F, 849.0F, 850.0F, 851.0F, 852.0F, 853.0F,\r\n  854.0F, 855.0F, 856.0F, 857.0F, 858.0F, 859.0F, 860.0F, 861.0F, 862.0F, 863.0F,\r\n  864.0F, 865.0F, 866.0F, 867.0F, 868.0F, 869.0F, 870.0F, 871.0F, 872.0F, 873.0F,\r\n  874.0F, 875.0F, 876.0F, 877.0F, 878.0F, 879.0F, 880.0F, 881.0F, 882.0F, 883.0F,\r\n  884.0F, 885.0F, 886.0F, 887.0F, 888.0F, 889.0F, 890.0F, 891.0F, 892.0F, 893.0F,\r\n  894.0F, 895.0F, 896.0F, 897.0F, 898.0F, 899.0F, 900.0F, 901.0F, 902.0F, 903.0F,\r\n  904.0F, 905.0F, 906.0F, 907.0F, 908.0F, 909.0F, 910.0F, 911.0F, 912.0F, 913.0F,\r\n  914.0F, 915.0F, 916.0F, 917.0F, 918.0F, 919.0F, 920.0F, 921.0F, 922.0F, 923.0F,\r\n  924.0F, 925.0F, 926.0F, 927.0F, 928.0F, 929.0F, 930.0F, 931.0F, 932.0F, 933.0F,\r\n  934.0F, 935.0F, 936.0F, 937.0F, 938.0F, 939.0F, 940.0F, 941.0F, 942.0F, 943.0F,\r\n  944.0F, 945.0F, 946.0F, 947.0F, 948.0F, 949.0F, 950.0F, 951.0F, 952.0F, 953.0F,\r\n  954.0F, 955.0F, 956.0F, 957.0F, 958.0F, 959.0F, 960.0F, 961.0F, 962.0F, 963.0F,\r\n  964.0F, 965.0F, 966.0F, 967.0F, 968.0F, 969.0F, 970.0F, 971.0F, 972.0F, 973.0F,\r\n  974.0F, 975.0F, 976.0F, 977.0F, 978.0F, 979.0F, 980.0F, 981.0F, 982.0F, 983.0F,\r\n  984.0F, 985.0F, 986.0F, 987.0F, 988.0F, 989.0F, 990.0F, 991.0F, 992.0F, 993.0F,\r\n  994.0F, 995.0F, 996.0F, 997.0F, 998.0F, 999.0F, 1000.0F, 1001.0F, 1002.0F,\r\n  1003.0F, 1004.0F, 1005.0F, 1006.0F, 1007.0F, 1008.0F, 1009.0F, 1010.0F,\r\n  1011.0F, 1012.0F, 1013.0F, 1014.0F, 1015.0F, 1016.0F, 1017.0F, 1018.0F,\r\n  1019.0F, 1020.0F, 1021.0F, 1022.0F, 1023.0F, 1024.0F, 1025.0F, 1026.0F,\r\n  1027.0F, 1028.0F, 1029.0F, 1030.0F, 1031.0F, 1032.0F, 1033.0F, 1034.0F,\r\n  1035.0F, 1036.0F, 1037.0F, 1038.0F, 1039.0F, 1040.0F, 1041.0F, 1042.0F,\r\n  1043.0F, 1044.0F, 1045.0F, 1046.0F, 1047.0F, 1048.0F, 1049.0F, 1050.0F,\r\n  1051.0F, 1052.0F, 1053.0F, 1054.0F, 1055.0F, 1056.0F, 1057.0F, 1058.0F,\r\n  1059.0F, 1060.0F, 1061.0F, 1062.0F, 1063.0F, 1064.0F, 1065.0F, 1066.0F,\r\n  1067.0F, 1068.0F, 1069.0F, 1070.0F, 1071.0F, 1072.0F, 1073.0F, 1074.0F,\r\n  1075.0F, 1076.0F, 1077.0F, 1078.0F, 1079.0F, 1080.0F, 1081.0F, 1082.0F,\r\n  1083.0F, 1084.0F, 1085.0F, 1086.0F, 1087.0F, 1088.0F, 1089.0F, 1090.0F,\r\n  1091.0F, 1092.0F, 1093.0F, 1094.0F, 1095.0F, 1096.0F, 1097.0F, 1098.0F,\r\n  1099.0F, 1100.0F, 1101.0F, 1102.0F, 1103.0F, 1104.0F, 1105.0F, 1106.0F,\r\n  1107.0F, 1108.0F, 1109.0F, 1110.0F, 1111.0F, 1112.0F, 1113.0F, 1114.0F,\r\n  1115.0F, 1116.0F, 1117.0F, 1118.0F, 1119.0F, 1120.0F, 1121.0F, 1122.0F,\r\n  1123.0F, 1124.0F, 1125.0F, 1126.0F, 1127.0F, 1128.0F, 1129.0F, 1130.0F,\r\n  1131.0F, 1132.0F, 1133.0F, 1134.0F, 1135.0F, 1136.0F, 1137.0F, 1138.0F,\r\n  1139.0F, 1140.0F, 1141.0F, 1142.0F, 1143.0F, 1144.0F, 1145.0F, 1146.0F,\r\n  1147.0F, 1148.0F, 1149.0F, 1150.0F, 1151.0F, 1152.0F, 1153.0F, 1154.0F,\r\n  1155.0F, 1156.0F, 1157.0F, 1158.0F, 1159.0F, 1160.0F, 1161.0F, 1162.0F,\r\n  1163.0F, 1164.0F, 1165.0F, 1166.0F, 1167.0F, 1168.0F, 1169.0F, 1170.0F,\r\n  1171.0F, 1172.0F, 1173.0F, 1174.0F, 1175.0F, 1176.0F, 1177.0F, 1178.0F,\r\n  1179.0F, 1180.0F, 1181.0F, 1182.0F, 1183.0F, 1184.0F, 1185.0F, 1186.0F,\r\n  1187.0F, 1188.0F, 1189.0F, 1190.0F, 1191.0F, 1192.0F, 1193.0F, 1194.0F,\r\n  1195.0F, 1196.0F, 1197.0F, 1198.0F, 1199.0F, 1200.0F, 1201.0F, 1202.0F,\r\n  1203.0F, 1204.0F, 1205.0F, 1206.0F, 1207.0F, 1208.0F, 1209.0F, 1210.0F,\r\n  1211.0F, 1212.0F, 1213.0F, 1214.0F, 1215.0F, 1216.0F, 1217.0F, 1218.0F,\r\n  1219.0F, 1220.0F, 1221.0F, 1222.0F, 1223.0F, 1224.0F, 1225.0F, 1226.0F,\r\n  1227.0F, 1228.0F, 1229.0F, 1230.0F, 1231.0F, 1232.0F, 1233.0F, 1234.0F,\r\n  1235.0F, 1236.0F, 1237.0F, 1238.0F, 1239.0F, 1240.0F, 1241.0F, 1242.0F,\r\n  1243.0F, 1244.0F, 1245.0F, 1246.0F, 1247.0F, 1248.0F, 1249.0F, 1250.0F,\r\n  1251.0F, 1252.0F, 1253.0F, 1254.0F, 1255.0F, 1256.0F, 1257.0F, 1258.0F,\r\n  1259.0F, 1260.0F, 1261.0F, 1262.0F, 1263.0F, 1264.0F, 1265.0F, 1266.0F,\r\n  1267.0F, 1268.0F, 1269.0F, 1270.0F, 1271.0F, 1272.0F, 1273.0F, 1274.0F,\r\n  1275.0F, 1276.0F, 1277.0F, 1278.0F, 1279.0F, 1280.0F, 1281.0F, 1282.0F,\r\n  1283.0F, 1284.0F, 1285.0F, 1286.0F, 1287.0F, 1288.0F, 1289.0F, 1290.0F,\r\n  1291.0F, 1292.0F, 1293.0F, 1294.0F, 1295.0F, 1296.0F, 1297.0F, 1298.0F,\r\n  1299.0F, 1300.0F, 1301.0F, 1302.0F, 1303.0F, 1304.0F, 1305.0F, 1306.0F,\r\n  1307.0F, 1308.0F, 1309.0F, 1310.0F, 1311.0F, 1312.0F, 1313.0F, 1314.0F,\r\n  1315.0F, 1316.0F, 1317.0F, 1318.0F, 1319.0F, 1320.0F, 1321.0F, 1322.0F,\r\n  1323.0F, 1324.0F, 1325.0F, 1326.0F, 1327.0F, 1328.0F, 1329.0F, 1330.0F,\r\n  1331.0F, 1332.0F, 1333.0F, 1334.0F, 1335.0F, 1336.0F, 1337.0F, 1338.0F,\r\n  1339.0F, 1340.0F, 1341.0F, 1342.0F, 1343.0F, 1344.0F, 1345.0F, 1346.0F,\r\n  1347.0F, 1348.0F, 1349.0F, 1350.0F, 1351.0F, 1352.0F, 1353.0F, 1354.0F,\r\n  1355.0F, 1356.0F, 1357.0F, 1358.0F, 1359.0F, 1360.0F, 1361.0F, 1362.0F,\r\n  1363.0F, 1364.0F, 1365.0F, 1366.0F, 1367.0F, 1368.0F, 1369.0F, 1370.0F,\r\n  1371.0F, 1372.0F, 1373.0F, 1374.0F, 1375.0F, 1376.0F, 1377.0F, 1378.0F,\r\n  1379.0F, 1380.0F, 1381.0F, 1382.0F, 1383.0F, 1384.0F, 1385.0F, 1386.0F,\r\n  1387.0F, 1388.0F, 1389.0F, 1390.0F, 1391.0F, 1392.0F, 1393.0F, 1394.0F,\r\n  1395.0F, 1396.0F, 1397.0F, 1398.0F, 1399.0F, 1400.0F, 1401.0F, 1402.0F,\r\n  1403.0F, 1404.0F, 1405.0F, 1406.0F, 1407.0F, 1408.0F, 1409.0F, 1410.0F,\r\n  1411.0F, 1412.0F, 1413.0F, 1414.0F, 1415.0F, 1416.0F, 1417.0F, 1418.0F,\r\n  1419.0F, 1420.0F, 1421.0F, 1422.0F, 1423.0F, 1424.0F, 1425.0F, 1426.0F,\r\n  1427.0F, 1428.0F, 1429.0F, 1430.0F, 1431.0F, 1432.0F, 1433.0F, 1434.0F,\r\n  1435.0F, 1436.0F, 1437.0F, 1438.0F, 1439.0F, 1440.0F, 1441.0F, 1442.0F,\r\n  1443.0F, 1444.0F, 1445.0F, 1446.0F, 1447.0F, 1448.0F, 1449.0F, 1450.0F,\r\n  1451.0F, 1452.0F, 1453.0F, 1454.0F, 1455.0F, 1456.0F, 1457.0F, 1458.0F,\r\n  1459.0F, 1460.0F, 1461.0F, 1462.0F, 1463.0F, 1464.0F, 1465.0F, 1466.0F,\r\n  1467.0F, 1468.0F, 1469.0F, 1470.0F, 1471.0F, 1472.0F, 1473.0F, 1474.0F,\r\n  1475.0F, 1476.0F, 1477.0F, 1478.0F, 1479.0F, 1480.0F, 1481.0F, 1482.0F,\r\n  1483.0F, 1484.0F, 1485.0F, 1486.0F, 1487.0F, 1488.0F, 1489.0F, 1490.0F,\r\n  1491.0F, 1492.0F, 1493.0F, 1494.0F, 1495.0F, 1496.0F, 1497.0F, 1498.0F,\r\n  1499.0F, 1500.0F, 1501.0F, 1502.0F, 1503.0F, 1504.0F, 1505.0F, 1506.0F,\r\n  1507.0F, 1508.0F, 1509.0F, 1510.0F, 1511.0F, 1512.0F, 1513.0F, 1514.0F,\r\n  1515.0F, 1516.0F, 1517.0F, 1518.0F, 1519.0F, 1520.0F, 1521.0F, 1522.0F,\r\n  1523.0F, 1524.0F, 1525.0F, 1526.0F, 1527.0F, 1528.0F, 1529.0F, 1530.0F,\r\n  1531.0F, 1532.0F, 1533.0F, 1534.0F, 1535.0F, 1536.0F, 1537.0F, 1538.0F,\r\n  1539.0F, 1540.0F, 1541.0F, 1542.0F, 1543.0F, 1544.0F, 1545.0F, 1546.0F,\r\n  1547.0F, 1548.0F, 1549.0F, 1550.0F, 1551.0F, 1552.0F, 1553.0F, 1554.0F,\r\n  1555.0F, 1556.0F, 1557.0F, 1558.0F, 1559.0F, 1560.0F, 1561.0F, 1562.0F,\r\n  1563.0F, 1564.0F, 1565.0F, 1566.0F, 1567.0F, 1568.0F, 1569.0F, 1570.0F,\r\n  1571.0F, 1572.0F, 1573.0F, 1574.0F, 1575.0F, 1576.0F, 1577.0F, 1578.0F,\r\n  1579.0F, 1580.0F, 1581.0F, 1582.0F, 1583.0F, 1584.0F, 1585.0F, 1586.0F,\r\n  1587.0F, 1588.0F, 1589.0F, 1590.0F, 1591.0F, 1592.0F, 1593.0F, 1594.0F,\r\n  1595.0F, 1596.0F, 1597.0F, 1598.0F, 1599.0F, 1600.0F, 1601.0F, 1602.0F,\r\n  1603.0F, 1604.0F, 1605.0F, 1606.0F, 1607.0F, 1608.0F, 1609.0F, 1610.0F,\r\n  1611.0F, 1612.0F, 1613.0F, 1614.0F, 1615.0F, 1616.0F, 1617.0F, 1618.0F,\r\n  1619.0F, 1620.0F, 1621.0F, 1622.0F, 1623.0F, 1624.0F, 1625.0F, 1626.0F,\r\n  1627.0F, 1628.0F, 1629.0F, 1630.0F, 1631.0F, 1632.0F, 1633.0F, 1634.0F,\r\n  1635.0F, 1636.0F, 1637.0F, 1638.0F, 1639.0F, 1640.0F, 1641.0F, 1642.0F,\r\n  1643.0F, 1644.0F, 1645.0F, 1646.0F, 1647.0F, 1648.0F, 1649.0F, 1650.0F,\r\n  1651.0F, 1652.0F, 1653.0F, 1654.0F, 1655.0F, 1656.0F, 1657.0F, 1658.0F,\r\n  1659.0F, 1660.0F, 1661.0F, 1662.0F, 1663.0F, 1664.0F, 1665.0F, 1666.0F,\r\n  1667.0F, 1668.0F, 1669.0F, 1670.0F, 1671.0F, 1672.0F, 1673.0F, 1674.0F,\r\n  1675.0F, 1676.0F, 1677.0F, 1678.0F, 1679.0F, 1680.0F, 1681.0F, 1682.0F,\r\n  1683.0F, 1684.0F, 1685.0F, 1686.0F, 1687.0F, 1688.0F, 1689.0F, 1690.0F,\r\n  1691.0F, 1692.0F, 1693.0F, 1694.0F, 1695.0F, 1696.0F, 1697.0F, 1698.0F,\r\n  1699.0F, 1700.0F, 1701.0F, 1702.0F, 1703.0F, 1704.0F, 1705.0F, 1706.0F,\r\n  1707.0F, 1708.0F, 1709.0F, 1710.0F, 1711.0F, 1712.0F, 1713.0F, 1714.0F,\r\n  1715.0F, 1716.0F, 1717.0F, 1718.0F, 1719.0F, 1720.0F, 1721.0F, 1722.0F,\r\n  1723.0F, 1724.0F, 1725.0F, 1726.0F, 1727.0F, 1728.0F, 1729.0F, 1730.0F,\r\n  1731.0F, 1732.0F, 1733.0F, 1734.0F, 1735.0F, 1736.0F, 1737.0F, 1738.0F,\r\n  1739.0F, 1740.0F, 1741.0F, 1742.0F, 1743.0F, 1744.0F, 1745.0F, 1746.0F,\r\n  1747.0F, 1748.0F, 1749.0F, 1750.0F, 1751.0F, 1752.0F, 1753.0F, 1754.0F,\r\n  1755.0F, 1756.0F, 1757.0F, 1758.0F, 1759.0F, 1760.0F, 1761.0F, 1762.0F,\r\n  1763.0F, 1764.0F, 1765.0F, 1766.0F, 1767.0F, 1768.0F, 1769.0F, 1770.0F,\r\n  1771.0F, 1772.0F, 1773.0F, 1774.0F, 1775.0F, 1776.0F, 1777.0F, 1778.0F,\r\n  1779.0F, 1780.0F, 1781.0F, 1782.0F, 1783.0F, 1784.0F, 1785.0F, 1786.0F,\r\n  1787.0F, 1788.0F, 1789.0F, 1790.0F, 1791.0F, 1792.0F, 1793.0F, 1794.0F,\r\n  1795.0F, 1796.0F, 1797.0F, 1798.0F, 1799.0F, 1800.0F, 1801.0F, 1802.0F,\r\n  1803.0F, 1804.0F, 1805.0F, 1806.0F, 1807.0F, 1808.0F, 1809.0F, 1810.0F,\r\n  1811.0F, 1812.0F, 1813.0F, 1814.0F, 1815.0F, 1816.0F, 1817.0F, 1818.0F,\r\n  1819.0F, 1820.0F, 1821.0F, 1822.0F, 1823.0F, 1824.0F, 1825.0F, 1826.0F,\r\n  1827.0F, 1828.0F, 1829.0F, 1830.0F, 1831.0F, 1832.0F, 1833.0F, 1834.0F,\r\n  1835.0F, 1836.0F, 1837.0F, 1838.0F, 1839.0F, 1840.0F, 1841.0F, 1842.0F,\r\n  1843.0F, 1844.0F, 1845.0F, 1846.0F, 1847.0F, 1848.0F, 1849.0F, 1850.0F,\r\n  1851.0F, 1852.0F, 1853.0F, 1854.0F, 1855.0F, 1856.0F, 1857.0F, 1858.0F,\r\n  1859.0F, 1860.0F, 1861.0F, 1862.0F, 1863.0F, 1864.0F, 1865.0F, 1866.0F,\r\n  1867.0F, 1868.0F, 1869.0F, 1870.0F, 1871.0F, 1872.0F, 1873.0F, 1874.0F,\r\n  1875.0F, 1876.0F, 1877.0F, 1878.0F, 1879.0F, 1880.0F, 1881.0F, 1882.0F,\r\n  1883.0F, 1884.0F, 1885.0F, 1886.0F, 1887.0F, 1888.0F, 1889.0F, 1890.0F,\r\n  1891.0F, 1892.0F, 1893.0F, 1894.0F, 1895.0F, 1896.0F, 1897.0F, 1898.0F,\r\n  1899.0F, 1900.0F, 1901.0F, 1902.0F, 1903.0F, 1904.0F, 1905.0F, 1906.0F,\r\n  1907.0F, 1908.0F, 1909.0F, 1910.0F, 1911.0F, 1912.0F, 1913.0F, 1914.0F,\r\n  1915.0F, 1916.0F, 1917.0F, 1918.0F, 1919.0F, 1920.0F, 1921.0F, 1922.0F,\r\n  1923.0F, 1924.0F, 1925.0F, 1926.0F, 1927.0F, 1928.0F, 1929.0F, 1930.0F,\r\n  1931.0F, 1932.0F, 1933.0F, 1934.0F, 1935.0F, 1936.0F, 1937.0F, 1938.0F,\r\n  1939.0F, 1940.0F, 1941.0F, 1942.0F, 1943.0F, 1944.0F, 1945.0F, 1946.0F,\r\n  1947.0F, 1948.0F, 1949.0F, 1950.0F, 1951.0F, 1952.0F, 1953.0F, 1954.0F,\r\n  1955.0F, 1956.0F, 1957.0F, 1958.0F, 1959.0F, 1960.0F, 1961.0F, 1962.0F,\r\n  1963.0F, 1964.0F, 1965.0F, 1966.0F, 1967.0F, 1968.0F, 1969.0F, 1970.0F,\r\n  1971.0F, 1972.0F, 1973.0F, 1974.0F, 1975.0F, 1976.0F, 1977.0F, 1978.0F,\r\n  1979.0F, 1980.0F, 1981.0F, 1982.0F, 1983.0F, 1984.0F, 1985.0F, 1986.0F,\r\n  1987.0F, 1988.0F, 1989.0F, 1990.0F, 1991.0F, 1992.0F, 1993.0F, 1994.0F,\r\n  1995.0F, 1996.0F, 1997.0F, 1998.0F, 1999.0F, 2000.0F, 2001.0F, 2002.0F,\r\n  2003.0F, 2004.0F, 2005.0F, 2006.0F, 2007.0F, 2008.0F, 2009.0F, 2010.0F,\r\n  2011.0F, 2012.0F, 2013.0F, 2014.0F, 2015.0F, 2016.0F, 2017.0F, 2018.0F,\r\n  2019.0F, 2020.0F, 2021.0F, 2022.0F, 2023.0F, 2024.0F, 2025.0F, 2026.0F,\r\n  2027.0F, 2028.0F, 2029.0F, 2030.0F, 2031.0F, 2032.0F, 2033.0F, 2034.0F,\r\n  2035.0F, 2036.0F, 2037.0F, 2038.0F, 2039.0F, 2040.0F, 2041.0F, 2042.0F,\r\n  2043.0F, 2044.0F, 2045.0F, 2046.0F, 2047.0F, 2048.0F, 2049.0F, 2050.0F,\r\n  2051.0F, 2052.0F, 2053.0F, 2054.0F, 2055.0F, 2056.0F, 2057.0F, 2058.0F,\r\n  2059.0F, 2060.0F, 2061.0F, 2062.0F, 2063.0F, 2064.0F, 2065.0F, 2066.0F,\r\n  2067.0F, 2068.0F, 2069.0F, 2070.0F, 2071.0F, 2072.0F, 2073.0F, 2074.0F,\r\n  2075.0F, 2076.0F, 2077.0F, 2078.0F, 2079.0F, 2080.0F, 2081.0F, 2082.0F,\r\n  2083.0F, 2084.0F, 2085.0F, 2086.0F, 2087.0F, 2088.0F, 2089.0F, 2090.0F,\r\n  2091.0F, 2092.0F, 2093.0F, 2094.0F, 2095.0F, 2096.0F, 2097.0F, 2098.0F,\r\n  2099.0F, 2100.0F, 2101.0F, 2102.0F, 2103.0F, 2104.0F, 2105.0F, 2106.0F,\r\n  2107.0F, 2108.0F, 2109.0F, 2110.0F, 2111.0F, 2112.0F, 2113.0F, 2114.0F,\r\n  2115.0F, 2116.0F, 2117.0F, 2118.0F, 2119.0F, 2120.0F, 2121.0F, 2122.0F,\r\n  2123.0F, 2124.0F, 2125.0F, 2126.0F, 2127.0F, 2128.0F, 2129.0F, 2130.0F,\r\n  2131.0F, 2132.0F, 2133.0F, 2134.0F, 2135.0F, 2136.0F, 2137.0F, 2138.0F,\r\n  2139.0F, 2140.0F, 2141.0F, 2142.0F, 2143.0F, 2144.0F, 2145.0F, 2146.0F,\r\n  2147.0F, 2148.0F, 2149.0F, 2150.0F, 2151.0F, 2152.0F, 2153.0F, 2154.0F,\r\n  2155.0F, 2156.0F, 2157.0F, 2158.0F, 2159.0F, 2160.0F, 2161.0F, 2162.0F,\r\n  2163.0F, 2164.0F, 2165.0F, 2166.0F, 2167.0F, 2168.0F, 2169.0F, 2170.0F,\r\n  2171.0F, 2172.0F, 2173.0F, 2174.0F, 2175.0F, 2176.0F, 2177.0F, 2178.0F,\r\n  2179.0F, 2180.0F, 2181.0F, 2182.0F, 2183.0F, 2184.0F, 2185.0F, 2186.0F,\r\n  2187.0F, 2188.0F, 2189.0F, 2190.0F, 2191.0F, 2192.0F, 2193.0F, 2194.0F,\r\n  2195.0F, 2196.0F, 2197.0F, 2198.0F, 2199.0F, 2200.0F, 2201.0F, 2202.0F,\r\n  2203.0F, 2204.0F, 2205.0F, 2206.0F, 2207.0F, 2208.0F, 2209.0F, 2210.0F,\r\n  2211.0F, 2212.0F, 2213.0F, 2214.0F, 2215.0F, 2216.0F, 2217.0F, 2218.0F,\r\n  2219.0F, 2220.0F, 2221.0F, 2222.0F, 2223.0F, 2224.0F, 2225.0F, 2226.0F,\r\n  2227.0F, 2228.0F, 2229.0F, 2230.0F, 2231.0F, 2232.0F, 2233.0F, 2234.0F,\r\n  2235.0F, 2236.0F, 2237.0F, 2238.0F, 2239.0F, 2240.0F, 2241.0F, 2242.0F,\r\n  2243.0F, 2244.0F, 2245.0F, 2246.0F, 2247.0F, 2248.0F, 2249.0F, 2250.0F,\r\n  2251.0F, 2252.0F, 2253.0F, 2254.0F, 2255.0F, 2256.0F, 2257.0F, 2258.0F,\r\n  2259.0F, 2260.0F, 2261.0F, 2262.0F, 2263.0F, 2264.0F, 2265.0F, 2266.0F,\r\n  2267.0F, 2268.0F, 2269.0F, 2270.0F, 2271.0F, 2272.0F, 2273.0F, 2274.0F,\r\n  2275.0F, 2276.0F, 2277.0F, 2278.0F, 2279.0F, 2280.0F, 2281.0F, 2282.0F,\r\n  2283.0F, 2284.0F, 2285.0F, 2286.0F, 2287.0F, 2288.0F, 2289.0F, 2290.0F,\r\n  2291.0F, 2292.0F, 2293.0F, 2294.0F, 2295.0F, 2296.0F, 2297.0F, 2298.0F,\r\n  2299.0F, 2300.0F, 2301.0F, 2302.0F, 2303.0F, 2304.0F, 2305.0F, 2306.0F,\r\n  2307.0F, 2308.0F, 2309.0F, 2310.0F, 2311.0F, 2312.0F, 2313.0F, 2314.0F,\r\n  2315.0F, 2316.0F, 2317.0F, 2318.0F, 2319.0F, 2320.0F, 2321.0F, 2322.0F,\r\n  2323.0F, 2324.0F, 2325.0F, 2326.0F, 2327.0F, 2328.0F, 2329.0F, 2330.0F,\r\n  2331.0F, 2332.0F, 2333.0F, 2334.0F, 2335.0F, 2336.0F, 2337.0F, 2338.0F,\r\n  2339.0F, 2340.0F, 2341.0F, 2342.0F, 2343.0F, 2344.0F, 2345.0F, 2346.0F,\r\n  2347.0F, 2348.0F, 2349.0F, 2350.0F, 2351.0F, 2352.0F, 2353.0F, 2354.0F,\r\n  2355.0F, 2356.0F, 2357.0F, 2358.0F, 2359.0F, 2360.0F, 2361.0F, 2362.0F,\r\n  2363.0F, 2364.0F, 2365.0F, 2366.0F, 2367.0F, 2368.0F, 2369.0F, 2370.0F,\r\n  2371.0F, 2372.0F, 2373.0F, 2374.0F, 2375.0F, 2376.0F, 2377.0F, 2378.0F,\r\n  2379.0F, 2380.0F, 2381.0F, 2382.0F, 2383.0F, 2384.0F, 2385.0F, 2386.0F,\r\n  2387.0F, 2388.0F, 2389.0F, 2390.0F, 2391.0F, 2392.0F, 2393.0F, 2394.0F,\r\n  2395.0F, 2396.0F, 2397.0F, 2398.0F, 2399.0F, 2400.0F, 2401.0F, 2402.0F,\r\n  2403.0F, 2404.0F, 2405.0F, 2406.0F, 2407.0F, 2408.0F, 2409.0F, 2410.0F,\r\n  2411.0F, 2412.0F, 2413.0F, 2414.0F, 2415.0F, 2416.0F, 2417.0F, 2418.0F,\r\n  2419.0F, 2420.0F, 2421.0F, 2422.0F, 2423.0F, 2424.0F, 2425.0F, 2426.0F,\r\n  2427.0F, 2428.0F, 2429.0F, 2430.0F, 2431.0F, 2432.0F, 2433.0F, 2434.0F,\r\n  2435.0F, 2436.0F, 2437.0F, 2438.0F, 2439.0F, 2440.0F, 2441.0F, 2442.0F,\r\n  2443.0F, 2444.0F, 2445.0F, 2446.0F, 2447.0F, 2448.0F, 2449.0F, 2450.0F,\r\n  2451.0F, 2452.0F, 2453.0F, 2454.0F, 2455.0F, 2456.0F, 2457.0F, 2458.0F,\r\n  2459.0F, 2460.0F, 2461.0F, 2462.0F, 2463.0F, 2464.0F, 2465.0F, 2466.0F,\r\n  2467.0F, 2468.0F, 2469.0F, 2470.0F, 2471.0F, 2472.0F, 2473.0F, 2474.0F,\r\n  2475.0F, 2476.0F, 2477.0F, 2478.0F, 2479.0F, 2480.0F, 2481.0F, 2482.0F,\r\n  2483.0F, 2484.0F, 2485.0F, 2486.0F, 2487.0F, 2488.0F, 2489.0F, 2490.0F,\r\n  2491.0F, 2492.0F, 2493.0F, 2494.0F, 2495.0F, 2496.0F, 2497.0F, 2498.0F,\r\n  2499.0F, 2500.0F, 2501.0F, 2502.0F, 2503.0F, 2504.0F, 2505.0F, 2506.0F,\r\n  2507.0F, 2508.0F, 2509.0F, 2510.0F, 2511.0F, 2512.0F, 2513.0F, 2514.0F,\r\n  2515.0F, 2516.0F, 2517.0F, 2518.0F, 2519.0F, 2520.0F, 2521.0F, 2522.0F,\r\n  2523.0F, 2524.0F, 2525.0F, 2526.0F, 2527.0F, 2528.0F, 2529.0F, 2530.0F,\r\n  2531.0F, 2532.0F, 2533.0F, 2534.0F, 2535.0F, 2536.0F, 2537.0F, 2538.0F,\r\n  2539.0F, 2540.0F, 2541.0F, 2542.0F, 2543.0F, 2544.0F, 2545.0F, 2546.0F,\r\n  2547.0F, 2548.0F, 2549.0F, 2550.0F, 2551.0F, 2552.0F, 2553.0F, 2554.0F,\r\n  2555.0F, 2556.0F, 2557.0F, 2558.0F, 2559.0F, 2560.0F, 2561.0F, 2562.0F,\r\n  2563.0F, 2564.0F, 2565.0F, 2566.0F, 2567.0F, 2568.0F, 2569.0F, 2570.0F,\r\n  2571.0F, 2572.0F, 2573.0F, 2574.0F, 2575.0F, 2576.0F, 2577.0F, 2578.0F,\r\n  2579.0F, 2580.0F, 2581.0F, 2582.0F, 2583.0F, 2584.0F, 2585.0F, 2586.0F,\r\n  2587.0F, 2588.0F, 2589.0F, 2590.0F, 2591.0F, 2592.0F, 2593.0F, 2594.0F,\r\n  2595.0F, 2596.0F, 2597.0F, 2598.0F, 2599.0F, 2600.0F, 2601.0F, 2602.0F,\r\n  2603.0F, 2604.0F, 2605.0F, 2606.0F, 2607.0F, 2608.0F, 2609.0F, 2610.0F,\r\n  2611.0F, 2612.0F, 2613.0F, 2614.0F, 2615.0F, 2616.0F, 2617.0F, 2618.0F,\r\n  2619.0F, 2620.0F, 2621.0F, 2622.0F, 2623.0F, 2624.0F, 2625.0F, 2626.0F,\r\n  2627.0F, 2628.0F, 2629.0F, 2630.0F, 2631.0F, 2632.0F, 2633.0F, 2634.0F,\r\n  2635.0F, 2636.0F, 2637.0F, 2638.0F, 2639.0F, 2640.0F, 2641.0F, 2642.0F,\r\n  2643.0F, 2644.0F, 2645.0F, 2646.0F, 2647.0F, 2648.0F, 2649.0F, 2650.0F,\r\n  2651.0F, 2652.0F, 2653.0F, 2654.0F, 2655.0F, 2656.0F, 2657.0F, 2658.0F,\r\n  2659.0F, 2660.0F, 2661.0F, 2662.0F, 2663.0F, 2664.0F, 2665.0F, 2666.0F,\r\n  2667.0F, 2668.0F, 2669.0F, 2670.0F, 2671.0F, 2672.0F, 2673.0F, 2674.0F,\r\n  2675.0F, 2676.0F, 2677.0F, 2678.0F, 2679.0F, 2680.0F, 2681.0F, 2682.0F,\r\n  2683.0F, 2684.0F, 2685.0F, 2686.0F, 2687.0F, 2688.0F, 2689.0F, 2690.0F,\r\n  2691.0F, 2692.0F, 2693.0F, 2694.0F, 2695.0F, 2696.0F, 2697.0F, 2698.0F,\r\n  2699.0F, 2700.0F, 2701.0F, 2702.0F, 2703.0F, 2704.0F, 2705.0F, 2706.0F,\r\n  2707.0F, 2708.0F, 2709.0F, 2710.0F, 2711.0F, 2712.0F, 2713.0F, 2714.0F,\r\n  2715.0F, 2716.0F, 2717.0F, 2718.0F, 2719.0F, 2720.0F, 2721.0F, 2722.0F,\r\n  2723.0F, 2724.0F, 2725.0F, 2726.0F, 2727.0F, 2728.0F, 2729.0F, 2730.0F,\r\n  2731.0F, 2732.0F, 2733.0F, 2734.0F, 2735.0F, 2736.0F, 2737.0F, 2738.0F,\r\n  2739.0F, 2740.0F, 2741.0F, 2742.0F, 2743.0F, 2744.0F, 2745.0F, 2746.0F,\r\n  2747.0F, 2748.0F, 2749.0F, 2750.0F, 2751.0F, 2752.0F, 2753.0F, 2754.0F,\r\n  2755.0F, 2756.0F, 2757.0F, 2758.0F, 2759.0F, 2760.0F, 2761.0F, 2762.0F,\r\n  2763.0F, 2764.0F, 2765.0F, 2766.0F, 2767.0F, 2768.0F, 2769.0F, 2770.0F,\r\n  2771.0F, 2772.0F, 2773.0F, 2774.0F, 2775.0F, 2776.0F, 2777.0F, 2778.0F,\r\n  2779.0F, 2780.0F, 2781.0F, 2782.0F, 2783.0F, 2784.0F, 2785.0F, 2786.0F,\r\n  2787.0F, 2788.0F, 2789.0F, 2790.0F, 2791.0F, 2792.0F, 2793.0F, 2794.0F,\r\n  2795.0F, 2796.0F, 2797.0F, 2798.0F, 2799.0F, 2800.0F, 2801.0F, 2802.0F,\r\n  2803.0F, 2804.0F, 2805.0F, 2806.0F, 2807.0F, 2808.0F, 2809.0F, 2810.0F,\r\n  2811.0F, 2812.0F, 2813.0F, 2814.0F, 2815.0F, 2816.0F, 2817.0F, 2818.0F,\r\n  2819.0F, 2820.0F, 2821.0F, 2822.0F, 2823.0F, 2824.0F, 2825.0F, 2826.0F,\r\n  2827.0F, 2828.0F, 2829.0F, 2830.0F, 2831.0F, 2832.0F, 2833.0F, 2834.0F,\r\n  2835.0F, 2836.0F, 2837.0F, 2838.0F, 2839.0F, 2840.0F, 2841.0F, 2842.0F,\r\n  2843.0F, 2844.0F, 2845.0F, 2846.0F, 2847.0F, 2848.0F, 2849.0F, 2850.0F,\r\n  2851.0F, 2852.0F, 2853.0F, 2854.0F, 2855.0F, 2856.0F, 2857.0F, 2858.0F,\r\n  2859.0F, 2860.0F, 2861.0F, 2862.0F, 2863.0F, 2864.0F, 2865.0F, 2866.0F,\r\n  2867.0F, 2868.0F, 2869.0F, 2870.0F, 2871.0F, 2872.0F, 2873.0F, 2874.0F,\r\n  2875.0F, 2876.0F, 2877.0F, 2878.0F, 2879.0F, 2880.0F, 2881.0F, 2882.0F,\r\n  2883.0F, 2884.0F, 2885.0F, 2886.0F, 2887.0F, 2888.0F, 2889.0F, 2890.0F,\r\n  2891.0F, 2892.0F, 2893.0F, 2894.0F, 2895.0F, 2896.0F, 2897.0F, 2898.0F,\r\n  2899.0F, 2900.0F, 2901.0F, 2902.0F, 2903.0F, 2904.0F, 2905.0F, 2906.0F,\r\n  2907.0F, 2908.0F, 2909.0F, 2910.0F, 2911.0F, 2912.0F, 2913.0F, 2914.0F,\r\n  2915.0F, 2916.0F, 2917.0F, 2918.0F, 2919.0F, 2920.0F, 2921.0F, 2922.0F,\r\n  2923.0F, 2924.0F, 2925.0F, 2926.0F, 2927.0F, 2928.0F, 2929.0F, 2930.0F,\r\n  2931.0F, 2932.0F, 2933.0F, 2934.0F, 2935.0F, 2936.0F, 2937.0F, 2938.0F,\r\n  2939.0F, 2940.0F, 2941.0F, 2942.0F, 2943.0F, 2944.0F, 2945.0F, 2946.0F,\r\n  2947.0F, 2948.0F, 2949.0F, 2950.0F, 2951.0F, 2952.0F, 2953.0F, 2954.0F,\r\n  2955.0F, 2956.0F, 2957.0F, 2958.0F, 2959.0F, 2960.0F, 2961.0F, 2962.0F,\r\n  2963.0F, 2964.0F, 2965.0F, 2966.0F, 2967.0F, 2968.0F, 2969.0F, 2970.0F,\r\n  2971.0F, 2972.0F, 2973.0F, 2974.0F, 2975.0F, 2976.0F, 2977.0F, 2978.0F,\r\n  2979.0F, 2980.0F, 2981.0F, 2982.0F, 2983.0F, 2984.0F, 2985.0F, 2986.0F,\r\n  2987.0F, 2988.0F, 2989.0F, 2990.0F, 2991.0F, 2992.0F, 2993.0F, 2994.0F,\r\n  2995.0F, 2996.0F, 2997.0F, 2998.0F, 2999.0F, 3000.0F, 3001.0F, 3002.0F,\r\n  3003.0F, 3004.0F, 3005.0F, 3006.0F, 3007.0F, 3008.0F, 3009.0F, 3010.0F,\r\n  3011.0F, 3012.0F, 3013.0F, 3014.0F, 3015.0F, 3016.0F, 3017.0F, 3018.0F,\r\n  3019.0F, 3020.0F, 3021.0F, 3022.0F, 3023.0F, 3024.0F, 3025.0F, 3026.0F,\r\n  3027.0F, 3028.0F, 3029.0F, 3030.0F, 3031.0F, 3032.0F, 3033.0F, 3034.0F,\r\n  3035.0F, 3036.0F, 3037.0F, 3038.0F, 3039.0F, 3040.0F, 3041.0F, 3042.0F,\r\n  3043.0F, 3044.0F, 3045.0F, 3046.0F, 3047.0F, 3048.0F, 3049.0F, 3050.0F,\r\n  3051.0F, 3052.0F, 3053.0F, 3054.0F, 3055.0F, 3056.0F, 3057.0F, 3058.0F,\r\n  3059.0F, 3060.0F, 3061.0F, 3062.0F, 3063.0F, 3064.0F, 3065.0F, 3066.0F,\r\n  3067.0F, 3068.0F, 3069.0F, 3070.0F, 3071.0F, 3072.0F, 3073.0F, 3074.0F,\r\n  3075.0F, 3076.0F, 3077.0F, 3078.0F, 3079.0F, 3080.0F, 3081.0F, 3082.0F,\r\n  3083.0F, 3084.0F, 3085.0F, 3086.0F, 3087.0F, 3088.0F, 3089.0F, 3090.0F,\r\n  3091.0F, 3092.0F, 3093.0F, 3094.0F, 3095.0F, 3096.0F, 3097.0F, 3098.0F,\r\n  3099.0F, 3100.0F, 3101.0F, 3102.0F, 3103.0F, 3104.0F, 3105.0F, 3106.0F,\r\n  3107.0F, 3108.0F, 3109.0F, 3110.0F, 3111.0F, 3112.0F, 3113.0F, 3114.0F,\r\n  3115.0F, 3116.0F, 3117.0F, 3118.0F, 3119.0F, 3120.0F, 3121.0F, 3122.0F,\r\n  3123.0F, 3124.0F, 3125.0F, 3126.0F, 3127.0F, 3128.0F, 3129.0F, 3130.0F,\r\n  3131.0F, 3132.0F, 3133.0F, 3134.0F, 3135.0F, 3136.0F, 3137.0F, 3138.0F,\r\n  3139.0F, 3140.0F, 3141.0F, 3142.0F, 3143.0F, 3144.0F, 3145.0F, 3146.0F,\r\n  3147.0F, 3148.0F, 3149.0F, 3150.0F, 3151.0F, 3152.0F, 3153.0F, 3154.0F,\r\n  3155.0F, 3156.0F, 3157.0F, 3158.0F, 3159.0F, 3160.0F, 3161.0F, 3162.0F,\r\n  3163.0F, 3164.0F, 3165.0F, 3166.0F, 3167.0F, 3168.0F, 3169.0F, 3170.0F,\r\n  3171.0F, 3172.0F, 3173.0F, 3174.0F, 3175.0F, 3176.0F, 3177.0F, 3178.0F,\r\n  3179.0F, 3180.0F, 3181.0F, 3182.0F, 3183.0F, 3184.0F, 3185.0F, 3186.0F,\r\n  3187.0F, 3188.0F, 3189.0F, 3190.0F, 3191.0F, 3192.0F, 3193.0F, 3194.0F,\r\n  3195.0F, 3196.0F, 3197.0F, 3198.0F, 3199.0F, 3200.0F, 3201.0F, 3202.0F,\r\n  3203.0F, 3204.0F, 3205.0F, 3206.0F, 3207.0F, 3208.0F, 3209.0F, 3210.0F,\r\n  3211.0F, 3212.0F, 3213.0F, 3214.0F, 3215.0F, 3216.0F, 3217.0F, 3218.0F,\r\n  3219.0F, 3220.0F, 3221.0F, 3222.0F, 3223.0F, 3224.0F, 3225.0F, 3226.0F,\r\n  3227.0F, 3228.0F, 3229.0F, 3230.0F, 3231.0F, 3232.0F, 3233.0F, 3234.0F,\r\n  3235.0F, 3236.0F, 3237.0F, 3238.0F, 3239.0F, 3240.0F, 3241.0F, 3242.0F,\r\n  3243.0F, 3244.0F, 3245.0F, 3246.0F, 3247.0F, 3248.0F, 3249.0F, 3250.0F,\r\n  3251.0F, 3252.0F, 3253.0F, 3254.0F, 3255.0F, 3256.0F, 3257.0F, 3258.0F,\r\n  3259.0F, 3260.0F, 3261.0F, 3262.0F, 3263.0F, 3264.0F, 3265.0F, 3266.0F,\r\n  3267.0F, 3268.0F, 3269.0F, 3270.0F, 3271.0F, 3272.0F, 3273.0F, 3274.0F,\r\n  3275.0F, 3276.0F, 3277.0F, 3278.0F, 3279.0F, 3280.0F, 3281.0F, 3282.0F,\r\n  3283.0F, 3284.0F, 3285.0F, 3286.0F, 3287.0F, 3288.0F, 3289.0F, 3290.0F,\r\n  3291.0F, 3292.0F, 3293.0F, 3294.0F, 3295.0F, 3296.0F, 3297.0F, 3298.0F,\r\n  3299.0F, 3300.0F, 3301.0F, 3302.0F, 3303.0F, 3304.0F, 3305.0F, 3306.0F,\r\n  3307.0F, 3308.0F, 3309.0F, 3310.0F, 3311.0F, 3312.0F, 3313.0F, 3314.0F,\r\n  3315.0F, 3316.0F, 3317.0F, 3318.0F, 3319.0F, 3320.0F, 3321.0F, 3322.0F,\r\n  3323.0F, 3324.0F, 3325.0F, 3326.0F, 3327.0F, 3328.0F, 3329.0F, 3330.0F,\r\n  3331.0F, 3332.0F, 3333.0F, 3334.0F, 3335.0F, 3336.0F, 3337.0F, 3338.0F,\r\n  3339.0F, 3340.0F, 3341.0F, 3342.0F, 3343.0F, 3344.0F, 3345.0F, 3346.0F,\r\n  3347.0F, 3348.0F, 3349.0F, 3350.0F, 3351.0F, 3352.0F, 3353.0F, 3354.0F,\r\n  3355.0F, 3356.0F, 3357.0F, 3358.0F, 3359.0F, 3360.0F, 3361.0F, 3362.0F,\r\n  3363.0F, 3364.0F, 3365.0F, 3366.0F, 3367.0F, 3368.0F, 3369.0F, 3370.0F,\r\n  3371.0F, 3372.0F, 3373.0F, 3374.0F, 3375.0F, 3376.0F, 3377.0F, 3378.0F,\r\n  3379.0F, 3380.0F, 3381.0F, 3382.0F, 3383.0F, 3384.0F, 3385.0F, 3386.0F,\r\n  3387.0F, 3388.0F, 3389.0F, 3390.0F, 3391.0F, 3392.0F, 3393.0F, 3394.0F,\r\n  3395.0F, 3396.0F, 3397.0F, 3398.0F, 3399.0F, 3400.0F, 3401.0F, 3402.0F,\r\n  3403.0F, 3404.0F, 3405.0F, 3406.0F, 3407.0F, 3408.0F, 3409.0F, 3410.0F,\r\n  3411.0F, 3412.0F, 3413.0F, 3414.0F, 3415.0F, 3416.0F, 3417.0F, 3418.0F,\r\n  3419.0F, 3420.0F, 3421.0F, 3422.0F, 3423.0F, 3424.0F, 3425.0F, 3426.0F,\r\n  3427.0F, 3428.0F, 3429.0F, 3430.0F, 3431.0F, 3432.0F, 3433.0F, 3434.0F,\r\n  3435.0F, 3436.0F, 3437.0F, 3438.0F, 3439.0F, 3440.0F, 3441.0F, 3442.0F,\r\n  3443.0F, 3444.0F, 3445.0F, 3446.0F, 3447.0F, 3448.0F, 3449.0F, 3450.0F,\r\n  3451.0F, 3452.0F, 3453.0F, 3454.0F, 3455.0F, 3456.0F, 3457.0F, 3458.0F,\r\n  3459.0F, 3460.0F, 3461.0F, 3462.0F, 3463.0F, 3464.0F, 3465.0F, 3466.0F,\r\n  3467.0F, 3468.0F, 3469.0F, 3470.0F, 3471.0F, 3472.0F, 3473.0F, 3474.0F,\r\n  3475.0F, 3476.0F, 3477.0F, 3478.0F, 3479.0F, 3480.0F, 3481.0F, 3482.0F,\r\n  3483.0F, 3484.0F, 3485.0F, 3486.0F, 3487.0F, 3488.0F, 3489.0F, 3490.0F,\r\n  3491.0F, 3492.0F, 3493.0F, 3494.0F, 3495.0F, 3496.0F, 3497.0F, 3498.0F,\r\n  3499.0F, 3500.0F, 3501.0F, 3502.0F, 3503.0F, 3504.0F, 3505.0F, 3506.0F,\r\n  3507.0F, 3508.0F, 3509.0F, 3510.0F, 3511.0F, 3512.0F, 3513.0F, 3514.0F,\r\n  3515.0F, 3516.0F, 3517.0F, 3518.0F, 3519.0F, 3520.0F, 3521.0F, 3522.0F,\r\n  3523.0F, 3524.0F, 3525.0F, 3526.0F, 3527.0F, 3528.0F, 3529.0F, 3530.0F,\r\n  3531.0F, 3532.0F, 3533.0F, 3534.0F, 3535.0F, 3536.0F, 3537.0F, 3538.0F,\r\n  3539.0F, 3540.0F, 3541.0F, 3542.0F, 3543.0F, 3544.0F, 3545.0F, 3546.0F,\r\n  3547.0F, 3548.0F, 3549.0F, 3550.0F, 3551.0F, 3552.0F, 3553.0F, 3554.0F,\r\n  3555.0F, 3556.0F, 3557.0F, 3558.0F, 3559.0F, 3560.0F, 3561.0F, 3562.0F,\r\n  3563.0F, 3564.0F, 3565.0F, 3566.0F, 3567.0F, 3568.0F, 3569.0F, 3570.0F,\r\n  3571.0F, 3572.0F, 3573.0F, 3574.0F, 3575.0F, 3576.0F, 3577.0F, 3578.0F,\r\n  3579.0F, 3580.0F, 3581.0F, 3582.0F, 3583.0F, 3584.0F, 3585.0F, 3586.0F,\r\n  3587.0F, 3588.0F, 3589.0F, 3590.0F, 3591.0F, 3592.0F, 3593.0F, 3594.0F,\r\n  3595.0F, 3596.0F, 3597.0F, 3598.0F, 3599.0F, 3600.0F, 3601.0F, 3602.0F,\r\n  3603.0F, 3604.0F, 3605.0F, 3606.0F, 3607.0F, 3608.0F, 3609.0F, 3610.0F,\r\n  3611.0F, 3612.0F, 3613.0F, 3614.0F, 3615.0F, 3616.0F, 3617.0F, 3618.0F,\r\n  3619.0F, 3620.0F, 3621.0F, 3622.0F, 3623.0F, 3624.0F, 3625.0F, 3626.0F,\r\n  3627.0F, 3628.0F, 3629.0F, 3630.0F, 3631.0F, 3632.0F, 3633.0F, 3634.0F,\r\n  3635.0F, 3636.0F, 3637.0F, 3638.0F, 3639.0F, 3640.0F, 3641.0F, 3642.0F,\r\n  3643.0F, 3644.0F, 3645.0F, 3646.0F, 3647.0F, 3648.0F, 3649.0F, 3650.0F,\r\n  3651.0F, 3652.0F, 3653.0F, 3654.0F, 3655.0F, 3656.0F, 3657.0F, 3658.0F,\r\n  3659.0F, 3660.0F, 3661.0F, 3662.0F, 3663.0F, 3664.0F, 3665.0F, 3666.0F,\r\n  3667.0F, 3668.0F, 3669.0F, 3670.0F, 3671.0F, 3672.0F, 3673.0F, 3674.0F,\r\n  3675.0F, 3676.0F, 3677.0F, 3678.0F, 3679.0F, 3680.0F, 3681.0F, 3682.0F,\r\n  3683.0F, 3684.0F, 3685.0F, 3686.0F, 3687.0F, 3688.0F, 3689.0F, 3690.0F,\r\n  3691.0F, 3692.0F, 3693.0F, 3694.0F, 3695.0F, 3696.0F, 3697.0F, 3698.0F,\r\n  3699.0F, 3700.0F, 3701.0F, 3702.0F, 3703.0F, 3704.0F, 3705.0F, 3706.0F,\r\n  3707.0F, 3708.0F, 3709.0F, 3710.0F, 3711.0F, 3712.0F, 3713.0F, 3714.0F,\r\n  3715.0F, 3716.0F, 3717.0F, 3718.0F, 3719.0F, 3720.0F, 3721.0F, 3722.0F,\r\n  3723.0F, 3724.0F, 3725.0F, 3726.0F, 3727.0F, 3728.0F, 3729.0F, 3730.0F,\r\n  3731.0F, 3732.0F, 3733.0F, 3734.0F, 3735.0F, 3736.0F, 3737.0F, 3738.0F,\r\n  3739.0F, 3740.0F, 3741.0F, 3742.0F, 3743.0F, 3744.0F, 3745.0F, 3746.0F,\r\n  3747.0F, 3748.0F, 3749.0F, 3750.0F, 3751.0F, 3752.0F, 3753.0F, 3754.0F,\r\n  3755.0F, 3756.0F, 3757.0F, 3758.0F, 3759.0F, 3760.0F, 3761.0F, 3762.0F,\r\n  3763.0F, 3764.0F, 3765.0F, 3766.0F, 3767.0F, 3768.0F, 3769.0F, 3770.0F,\r\n  3771.0F, 3772.0F, 3773.0F, 3774.0F, 3775.0F, 3776.0F, 3777.0F, 3778.0F,\r\n  3779.0F, 3780.0F, 3781.0F, 3782.0F, 3783.0F, 3784.0F, 3785.0F, 3786.0F,\r\n  3787.0F, 3788.0F, 3789.0F, 3790.0F, 3791.0F, 3792.0F, 3793.0F, 3794.0F,\r\n  3795.0F, 3796.0F, 3797.0F, 3798.0F, 3799.0F, 3800.0F, 3801.0F, 3802.0F,\r\n  3803.0F, 3804.0F, 3805.0F, 3806.0F, 3807.0F, 3808.0F, 3809.0F, 3810.0F,\r\n  3811.0F, 3812.0F, 3813.0F, 3814.0F, 3815.0F, 3816.0F, 3817.0F, 3818.0F,\r\n  3819.0F, 3820.0F, 3821.0F, 3822.0F, 3823.0F, 3824.0F, 3825.0F, 3826.0F,\r\n  3827.0F, 3828.0F, 3829.0F, 3830.0F, 3831.0F, 3832.0F, 3833.0F, 3834.0F,\r\n  3835.0F, 3836.0F, 3837.0F, 3838.0F, 3839.0F, 3840.0F, 3841.0F, 3842.0F,\r\n  3843.0F, 3844.0F, 3845.0F, 3846.0F, 3847.0F, 3848.0F, 3849.0F, 3850.0F,\r\n  3851.0F, 3852.0F, 3853.0F, 3854.0F, 3855.0F, 3856.0F, 3857.0F, 3858.0F,\r\n  3859.0F, 3860.0F, 3861.0F, 3862.0F, 3863.0F, 3864.0F, 3865.0F, 3866.0F,\r\n  3867.0F, 3868.0F, 3869.0F, 3870.0F, 3871.0F, 3872.0F, 3873.0F, 3874.0F,\r\n  3875.0F, 3876.0F, 3877.0F, 3878.0F, 3879.0F, 3880.0F, 3881.0F, 3882.0F,\r\n  3883.0F, 3884.0F, 3885.0F, 3886.0F, 3887.0F, 3888.0F, 3889.0F, 3890.0F,\r\n  3891.0F, 3892.0F, 3893.0F, 3894.0F, 3895.0F, 3896.0F, 3897.0F, 3898.0F,\r\n  3899.0F, 3900.0F, 3901.0F, 3902.0F, 3903.0F, 3904.0F, 3905.0F, 3906.0F,\r\n  3907.0F, 3908.0F, 3909.0F, 3910.0F, 3911.0F, 3912.0F, 3913.0F, 3914.0F,\r\n  3915.0F, 3916.0F, 3917.0F, 3918.0F, 3919.0F, 3920.0F, 3921.0F, 3922.0F,\r\n  3923.0F, 3924.0F, 3925.0F, 3926.0F, 3927.0F, 3928.0F, 3929.0F, 3930.0F,\r\n  3931.0F, 3932.0F, 3933.0F, 3934.0F, 3935.0F, 3936.0F, 3937.0F, 3938.0F,\r\n  3939.0F, 3940.0F, 3941.0F, 3942.0F, 3943.0F, 3944.0F, 3945.0F, 3946.0F,\r\n  3947.0F, 3948.0F, 3949.0F, 3950.0F, 3951.0F, 3952.0F, 3953.0F, 3954.0F,\r\n  3955.0F, 3956.0F, 3957.0F, 3958.0F, 3959.0F, 3960.0F, 3961.0F, 3962.0F,\r\n  3963.0F, 3964.0F, 3965.0F, 3966.0F, 3967.0F, 3968.0F, 3969.0F, 3970.0F,\r\n  3971.0F, 3972.0F, 3973.0F, 3974.0F, 3975.0F, 3976.0F, 3977.0F, 3978.0F,\r\n  3979.0F, 3980.0F, 3981.0F, 3982.0F, 3983.0F, 3984.0F, 3985.0F, 3986.0F,\r\n  3987.0F, 3988.0F, 3989.0F, 3990.0F, 3991.0F, 3992.0F, 3993.0F, 3994.0F,\r\n  3995.0F, 3996.0F, 3997.0F, 3998.0F, 3999.0F, 4000.0F, 4001.0F, 4002.0F,\r\n  4003.0F, 4004.0F, 4005.0F, 4006.0F, 4007.0F, 4008.0F, 4009.0F, 4010.0F,\r\n  4011.0F, 4012.0F, 4013.0F, 4014.0F, 4015.0F, 4016.0F, 4017.0F, 4018.0F,\r\n  4019.0F, 4020.0F, 4021.0F, 4022.0F, 4023.0F, 4024.0F, 4025.0F, 4026.0F,\r\n  4027.0F, 4028.0F, 4029.0F, 4030.0F, 4031.0F, 4032.0F, 4033.0F, 4034.0F,\r\n  4035.0F, 4036.0F, 4037.0F, 4038.0F, 4039.0F, 4040.0F, 4041.0F, 4042.0F,\r\n  4043.0F, 4044.0F, 4045.0F, 4046.0F, 4047.0F, 4048.0F, 4049.0F, 4050.0F,\r\n  4051.0F, 4052.0F, 4053.0F, 4054.0F, 4055.0F, 4056.0F, 4057.0F, 4058.0F,\r\n  4059.0F, 4060.0F, 4061.0F, 4062.0F, 4063.0F, 4064.0F, 4065.0F, 4066.0F,\r\n  4067.0F, 4068.0F, 4069.0F, 4070.0F, 4071.0F, 4072.0F, 4073.0F, 4074.0F,\r\n  4075.0F, 4076.0F, 4077.0F, 4078.0F, 4079.0F, 4080.0F, 4081.0F, 4082.0F,\r\n  4083.0F, 4084.0F, 4085.0F, 4086.0F, 4087.0F, 4088.0F, 4089.0F, 4090.0F,\r\n  4091.0F, 4092.0F, 4093.0F, 4094.0F, 4095.0F } ;\r\n"},{"name":"look1_iflf_binlxpw.c","type":"source","group":"sharedutility","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: look1_iflf_binlxpw.c\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"look1_iflf_binlxpw.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nreal32_T look1_iflf_binlxpw(real32_T u0, const real32_T bp0[], const real32_T\r\n  table[], uint32_T maxIndex)\r\n{\r\n  real32_T frac;\r\n  real32_T yL_0d0;\r\n  uint32_T iLeft;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'off'\r\n     Interpolation method: 'Linear point-slope'\r\n     Extrapolation method: 'Linear'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Linear'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n\r\n    /* Binary Search */\r\n    bpIdx = (maxIndex >> 1U);\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while ((iRght - iLeft) > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = ((iRght + iLeft) >> 1U);\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  yL_0d0 = table[iLeft];\r\n  return ((table[iLeft + 1U] - yL_0d0) * frac) + yL_0d0;\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] look1_iflf_binlxpw.c\r\n */\r\n"},{"name":"look1_iflf_binlxpw.h","type":"header","group":"sharedutility","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: look1_iflf_binlxpw.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_look1_iflf_binlxpw_h_\r\n#define RTW_HEADER_look1_iflf_binlxpw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real32_T look1_iflf_binlxpw(real32_T u0, const real32_T bp0[], const\r\n  real32_T table[], uint32_T maxIndex);\r\n\r\n#endif                                 /* RTW_HEADER_look1_iflf_binlxpw_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] look1_iflf_binlxpw.h\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: STMicroelectronics->STM32 32-bit Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtwtypes.h\r\n */\r\n"},{"name":"STM32_Config.h","type":"header","group":"","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: STM32_Config.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_STM32_Config_h_\r\n#define RTW_HEADER_STM32_Config_h_\r\n#include \"stm32h7xx.h\"\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/* For Error_Handler() declaration. */\r\n#include \"main.h\"\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* RTW_HEADER_STM32_Config_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] STM32_Config.h\r\n */\r\n"},{"name":"TestPilAdc_ADC.c","type":"source","group":"","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc_ADC.c\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"TestPilAdc.h\"\r\n#include \"TestPilAdc_ADC.h\"\r\n\r\n/* Pointer to ADC informations. */\r\nADC_ConfTypeDef* G_ADC_Conf;\r\n\r\n/* Pointer to ADC handler. */\r\nADC_HandleTypeDef* G_ADC_Handler;\r\n\r\n/* ADC3 Regular channel Converted value buffer */\r\nuint16_t ADC3_RegularConvertedValue[1];\r\n\r\n/* ADC3 informations. */\r\nADC_ConfTypeDef ADC3_Conf = {\r\n  /* Regular channels. */\r\n  NULL, 0, 0,\r\n\r\n  /* Injected channels. */\r\n  NULL, 0, ADC_INJECTED_RANK_1,\r\n\r\n  /* Dma. */\r\n  0, false,\r\n\r\n  /* End of conversion. */\r\n  false,\r\n\r\n  /* Interrupts callbacks. */\r\n  NULL, NULL, NULL, NULL, NULL, NULL\r\n};\r\n\r\n/* ADC3 polling timeout value. Number of Solver loop. (can be changed)*/\r\nuint32_t G_ADC3_PollTimeOut = 10;\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc_ADC.c\r\n */\r\n"},{"name":"TestPilAdc_ADC.h","type":"header","group":"","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc_ADC.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_TestPilAdc_ADC_h_\r\n#define RTW_HEADER_TestPilAdc_ADC_h_\r\n#include \"STM32_Config.h\"\r\n#define ADC3_DMA_BUFF_SIZE             0\r\n\r\n/**\r\n * @brief  ADC information\r\n */\r\ntypedef struct {\r\n  uint16_t* regularBuffer;           /*!< Regular buffer for converted value. */\r\n  uint32_t regularCount;               /*!< Number of regular channel. */\r\n  uint32_t regularRank;                /*!< Regular current rank. */\r\n  uint16_t* injectedBuffer;         /*!< Injected buffer for converted value. */\r\n  uint32_t injectedCount;              /*!< Number of injected channel. */\r\n  uint32_t injectedRank;               /*!< Injected current rank. */\r\n  uint32_t dmaBuffSize;                /*!< Buffer size for DMA acquisition. */\r\n  uint8_t dmaUsed;                     /*!< DMA acquisition mode. */\r\n  uint8_t IntEndOfAllConv;       /*!< EOS/JEOS Int at end of all conversions. */\r\n  void (* ItEOCFcn)(void);\r\n  void (* ItJEOCFcn)(void);\r\n  void (* ItAWDFcn)(void);\r\n  void (* ItOVRFcn)(void);\r\n  void (* ItDMAFullFcn)(void);\r\n  void (* ItDMAHalfFullFcn)(void);\r\n} ADC_ConfTypeDef;\r\n\r\n/* Pointer to ADC informations. */\r\nextern ADC_ConfTypeDef* G_ADC_Conf;\r\n\r\n/* Pointer to ADC handler. */\r\nextern ADC_HandleTypeDef* G_ADC_Handler;\r\n\r\n/* ADC3 handler. */\r\nextern ADC_HandleTypeDef hadc3;\r\n\r\n/* ADC3 Regular channel Converted value buffer */\r\nextern uint16_t ADC3_RegularConvertedValue[1];\r\n\r\n/* ADC3 informations. */\r\nextern ADC_ConfTypeDef ADC3_Conf;\r\n\r\n/* ADC3 polling timeout value. Number of Solver loop. (can be changed)*/\r\nextern uint32_t G_ADC3_PollTimeOut;\r\n\r\n#endif                                 /* RTW_HEADER_TestPilAdc_ADC_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc_ADC.h\r\n */\r\n"},{"name":"TestPilAdc_External_Functions.h","type":"header","group":"","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: TestPilAdc_External_Functions.h\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_TestPilAdc_External_Functions_h_\r\n#define RTW_HEADER_TestPilAdc_External_Functions_h_\r\n\r\n/* Generated by STM32_Config.*/\r\n/***** External Imported Functions *****/\r\n#endif                         /* RTW_HEADER_TestPilAdc_External_Functions_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] TestPilAdc_External_Functions.h\r\n */\r\n"},{"name":"main.c","type":"source","group":"","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: main.c\r\n *\r\n * Code generated for Simulink model :TestPilAdc.\r\n *\r\n * Model version      : 8.0\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Apr  7 2022)\r\n * C/C++ source code generated on  : Tue Jun  7 19:21:13 2022\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: STMicroelectronics->STM32 32-bit Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n *    3. MISRA C:2012 guidelines\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n/* This section of code is going to be merged by the STM32CubeMX tool. */\r\n/* USER CODE BEGIN 0 */\r\n/* Add include files for PIL processing. */\r\n#include <stdio.h>\r\n#include \"xil_interface_lib.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"STM32SerialRtiostream-ProfilerTimer.h\"\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n * @brief  The application entry point.\r\n * @retval int\r\n */\r\nint main(void)\r\n{\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 1 */\r\n  XIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\r\n  int errorOccurred = 0;\r\n\r\n  /* Avoid warnings about infinite loops */\r\n  volatile int loop = 1;\r\n\r\n  /* USER CODE END 1 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 2 */\r\n  /* Profiling settings: set reload SysTick timer to max value 0x00FFFFFF */\r\n  profileTimerInit();\r\n\r\n  /* XIL initialization */\r\n  const int argc = 0;\r\n  void * argv = (void *) 0;\r\n  errorCode = xilInit(argc, argv);\r\n  errorOccurred = (errorCode != XIL_INTERFACE_LIB_SUCCESS);\r\n\r\n  /* USER CODE END 2 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN WHILE */\r\n  /* main XIL loop */\r\n  while (loop && !errorOccurred) {\r\n    errorCode = xilRun();\r\n    if (errorCode != XIL_INTERFACE_LIB_SUCCESS) {\r\n      if (errorCode == XIL_INTERFACE_LIB_TERMINATE) {\r\n        /* orderly shutdown of rtiostream */\r\n        errorOccurred = (xilTerminateComms() != XIL_INTERFACE_LIB_SUCCESS);\r\n      } else {\r\n        errorOccurred = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* trap error with infinite loop */\r\n  if (errorOccurred)\r\n    while (loop) {\r\n    }\r\n\r\n  /* USER CODE END WHILE */\r\n\r\n  /* USER CODE BEGIN 3 */\r\n  /* USER CODE END 3 */\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] main.c\r\n */\r\n"},{"name":"CodeInstrTgtAppSvc.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\extern\\include\\coder\\connectivity\\CodeInstrTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef CodeInstrTgtAppSvc_h\n#define CodeInstrTgtAppSvc_h\n\n#include \"CodeInstrTgtAppSvc_spec.h\"\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_CODEINSTRTGTAPPSVC)\n       \n    typedef uint8_T IOUnit_T;   \n#else\n   \n    #include \"xilcomms_rtiostream.h\"\n#endif\n       \nstatic const boolean_T CODEINSTRTGTAPPSVC_ERROR = 0;\nstatic const boolean_T CODEINSTRTGTAPPSVC_SUCCESS = 1;\n\n#define CODEINSTR_RTIOSTREAM_BASED_SERVICE_ID 2\n             \n#endif\n"},{"name":"CodeInstrTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\extern\\include\\coder\\connectivity\\CodeInstrTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef CodeInstrTgtAppSvc_CInterface_h\n#define CodeInstrTgtAppSvc_CInterface_h\n\n#include \"CodeInstrTgtAppSvc.h\"\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcCreate(void);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C void codeInstrTgtAppSvcDestroy(void);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C IOUnit_T* codeInstrTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint8_T codeInstrTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nCODEINSTRTGTAPPSVC_API_EXTERN_C uint16_T codeInstrTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"CoderAssumpTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\extern\\include\\coder\\connectivity\\CoderAssumpTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#ifndef CoderAssumpTgtAppSvc_CInterface_h\n#define CoderAssumpTgtAppSvc_CInterface_h\n\n#include \"CoderAssumpTgtAppSvc_spec.h\"\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_CODERASSUMPTGTAPPSVC) \n    typedef uint8_T IOUnit_T;  \n#else\n    #include \"xilcomms_rtiostream.h\"\n#endif\n\n#define CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID 3\n\n#ifdef USE_CODERASSUMPTGTAPPSVC_ERROR\n    static const uint8_T CODERASSUMPTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_CODERASSUMPTGTAPPSVC_SUCCESS\n    static const uint8_T CODERASSUMPTGTAPPSVC_SUCCESS = 1;\n#endif\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcCreate(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C void coderAssumpTgtAppSvcDestroy(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C IOUnit_T* coderAssumpTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint16_T coderAssumpTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"STM32SerialRtiostream-ProfilerTimer.c","type":"source","group":"SILPIL","path":"D:\\STM32-MAT\\STM32\\pil\\stm32SerialRtiostream","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* STM32SerialRtiostream-ProfilerTimer.c\n *\n * Specifies profile timer access functions\n *\n * Copyright 2011 The MathWorks, Inc.\n */\n\n#include \"STM32SerialRtiostream-ProfilerTimer.h\"\n#include \"STM32SerialRtiostream_Config.h\"\n\n\nvoid profileTimerInit(void)\n{\n    /* SysTick called every time currentVal 1 to 0. Then reloaded with reload val. */\n    SysTick->LOAD = 0x00FFFFFF;\n    SysTick->VAL  = 0x00000000;\n    SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;\n}\n\n\nunsigned int profileTimerRead(unsigned int initTimer)\n{\n    static unsigned char initTimerDone = 0;\n    unsigned int timerVal;\n\n    if (initTimer == 0)\n    {\n        /* When initTimer is null, it is xilProfilingSectionStart */\n        SysTick->VAL = 0x00FFFFFF;\n        timerVal = 0x00FFFFFF;\n        initTimerDone = 1;\n    }\n    else\n    {\n        /*When initTimer is NOT null, it is xilProfilingSectionEnd if init has been done initTimerDone == 1 */\n        if (initTimerDone == 1)\n        {\n            timerVal = SysTick->VAL;\n            initTimerDone = 0;\n        }\n        else\n        {\n            initTimerDone = 1;\n            SysTick->VAL = 0x00FFFFFF;\n            timerVal = 0x00FFFFFF;\n        }\n    }\n\n    return timerVal;\n}\n"},{"name":"STM32SerialRtiostream-ProfilerTimer.h","type":"header","group":"SILPIL","path":"D:\\STM32-MAT\\STM32\\pil\\stm32SerialRtiostream","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* STM32SerialRtiostream-ProfilerTimer.h\n *\n * Specifies function prototypes for profile timer access functions\n *\n * Copyright 2011 The MathWorks, Inc.\n*/\n\n#ifndef _PROFILERTIMER_H\n#define _PROFILERTIMER_H\n\nvoid profileTimerInit(void);\nunsigned int profileTimerRead(unsigned int initTimer);\n#endif\n\n\n"},{"name":"STM32SerialRtiostream-Rtiostream.c","type":"source","group":"SILPIL","path":"D:\\STM32-MAT\\STM32\\pil\\stm32SerialRtiostream","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* STM32SerialRtiostream-Rtiostream.c\n *\n * Specifies rtiostream functions to implement serial PIL\n *\n * NOTES:\n *  - Baud rate is specified in UART_PIL_Configuration();\n *  - rtIOStreamSend & rtIOStreamRecv functions send and receive\n *    8-bit characters.\n *\n * Copyright 2011 The MathWorks, Inc.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n\n#include \"STM32SerialRtiostream-Rtiostream.h\"\n/* STM32SerialRtiostream_Config.h is generated with definitions\ndepending on USART selection */\n#include \"STM32SerialRtiostream_Config.h\"\n\nstatic volatile uint8_t RxCplt = 0;\nstatic volatile uint8_t TxCplt = 0;\n\n\n/* Function: rtIOStreamOpen ================================================= */\n/* Configuration of USART for rtIOStream =====================================*/\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    (void)argc;\n    (void)argv;\n\n    return SERVER_STREAM_ID;\n}\n\n\n/* Function: rtIOStreamClose ================================================ */\nint rtIOStreamClose(int streamID)\n{\n    (void)streamID;\n\n    return RTIOSTREAM_NO_ERROR;\n}\n\n\n/* Function: rtIOStreamSend ================================================ */\nint rtIOStreamSend(int streamID, const void * src, size_t size, size_t * sizeSent)\n{\n    (void)streamID;\n\n    TxCplt = 0;\n\n    HAL_UART_Transmit_IT(PIL_USART_HANDLE, (uint8_t *)src, (uint16_t)size);\n\n    /* Wait for end of Tx */\n    while (!TxCplt);\n\n    *sizeSent = size;\n\n    return RTIOSTREAM_NO_ERROR;\n}\n\n\n/* Function: rtIOStreamRecv ================================================ */\nint rtIOStreamRecv(int streamID, void * dst, size_t size, size_t * sizeRecv)\n{\n    (void)streamID;\n\n    /* Rx not complete */\n    RxCplt = 0;\n\n    /* Start Rx interrupt. */\n    HAL_UART_Receive_IT(PIL_USART_HANDLE, (uint8_t *)dst, (uint16_t)size);\n\n    /* Wait for end of Rx */\n    while (!RxCplt);\n\n    *sizeRecv = size;\n\n    return RTIOSTREAM_NO_ERROR;\n}\n\n\n/*******************************************************************************\n* Function Name  : HAL_UART_RxCpltCallback\n* Description    : Rx Transfer completed callbacks.\n* Input          : UART handle\n*******************************************************************************/\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef * huart)\n{\n    (void)huart;\n\n    /* Rx complete */\n    RxCplt = 1;\n}\n\n/*******************************************************************************\n* Function Name  : HAL_UART_TxCpltCallback\n* Description    : Tx Transfer completed callbacks.\n* Input          : UART handle\n*******************************************************************************/\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef * huart)\n{\n    (void)huart;\n\n    /* Tx complete */\n    TxCplt = 1;\n}\n"},{"name":"TestPilAdc_psf.c","type":"source","group":"SILPIL","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc\\pil","tag":"In-the-Loop:Host","groupDisplay":"SIL/PIL files","code":"/*\r\n * TestPilAdc_psf.c\r\n *\r\n * Automatically generated s-function with I/O interface for:\r\n * Component: TestPilAdc\r\n * Component Simulink Path: TestPilAdc\r\n * Simulation Mode: PIL\r\n *\r\n */\r\n\r\n#define S_FUNCTION_NAME                TestPilAdc_psf\r\n#define S_FUNCTION_LEVEL               2\r\n#if !defined(RTW_GENERATED_S_FUNCTION)\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include \"simstruc.h\"\r\n#include \"simtarget/slMdlrefSimTargetCoreHeaders.h\"\r\n#include \"simtarget/slMdlrefSimTargetInstrumentationHeaders.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"coder/connectivity_core/xilutils/xilutils.h\"\r\n#include \"coder/simulinkcoder/xilutils_sl/xilutils_sl.h\"\r\n#include \"rtiostream_utils.h\"\r\n#include \"coder/connectivity/xilcomms_rtiostream/xilcomms_rtiostream.h\"\r\n#include \"coder/connectivity/XILHostAppSvc/XILHostAppSvc_CInterface.h\"\r\n#include \"messages/slMessagesSfcnBridge.h\"\r\n#include \"strings/slStringSfcnAPI.h\"\r\n#include \"mwstringutil.h\"\r\n#include \"coder/connectivity/CodeInstrHostAppSvc/CodeInstrHostAppSvc_CInterface.h\"\r\n#include \"coder/connectivity/CoderAssumpHostAppSvc/CoderAssumpHostAppSvc_CInterface.h\"\r\n\r\nstatic real_T rtInf;\r\nstatic real_T rtMinusInf;\r\n\r\n/* Response case labels */\r\nenum ResponseIDs {\r\n  RESPONSE_ERROR = 0,\r\n  RESPONSE_OUTPUT_PRE_DATA = 1,\r\n  RESPONSE_OUTPUT_DATA = 2,\r\n  RESPONSE_PRINTF = 3,\r\n  RESPONSE_FOPEN = 4,\r\n  RESPONSE_FPRINTF = 5,\r\n  RESPONSE_SIGNAL_RAISED = 6\r\n};\r\n\r\ntypedef struct {\r\n  FILE ** Fd;\r\n  mwSize size;\r\n  int32_T fidOffset;\r\n} targetIOFd_T;\r\n\r\ntypedef enum {\r\n  XIL_INIT_COMMAND = 0,\r\n  XIL_INITIALIZE_COMMAND,\r\n  XIL_SYSTEM_INITIALIZE_COMMAND,\r\n  XIL_OUTPUT_COMMAND,\r\n  XIL_TERMINATE_COMMAND,\r\n  XIL_ENABLE_COMMAND,\r\n  XIL_DISABLE_COMMAND,\r\n  XIL_CONST_OUTPUT_COMMAND,\r\n  XIL_PROCESS_PARAMS_COMMAND,\r\n  XIL_CLIENT_SERVER_COMMAND,\r\n  XIL_SHUTDOWN_COMMAND,\r\n  XIL_UPDATE_COMMAND,\r\n  XIL_SYSTEM_RESET_COMMAND,\r\n  XIL_PAUSE_COMMAND\r\n}\r\n  XIL_COMMAND_TYPE_ENUM;\r\n\r\nstatic RegMdlInfo rtMdlInfo_TestPilAdc[1] = { \"\",\r\n  MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT, 0, 0, NULL };\r\n\r\nstatic char * getSimulinkBlockPath(SimStruct *S)\r\n{\r\n  char * simulinkBlockPath = NULL;\r\n  const char * origBlockPath = ssGetPath(S);\r\n  const char * searchString = \"TmpSFcnForModelReference_\";\r\n  const char * searchPtr;\r\n  size_t origLength, searchAndNameLength, copyAmount;\r\n  char * secondPart;\r\n  size_t nameLength;\r\n  origLength = strlen(origBlockPath);\r\n  searchPtr = strstr(origBlockPath, searchString);\r\n  if (searchPtr == NULL) {\r\n    return simulinkBlockPath;\r\n  }\r\n\r\n  searchAndNameLength = strlen(searchPtr);\r\n  copyAmount = origLength - searchAndNameLength;\r\n  simulinkBlockPath = (char *) mxCalloc((mwSize) (origLength + 1), sizeof(char));\r\n  simulinkBlockPath = strncpy(simulinkBlockPath, origBlockPath, copyAmount);\r\n  simulinkBlockPath[copyAmount] = '\\0';\r\n  nameLength = searchAndNameLength - strlen(searchString);\r\n  secondPart = &simulinkBlockPath[copyAmount];\r\n  secondPart = strncpy(secondPart, &origBlockPath[origLength - nameLength],\r\n                       nameLength);\r\n  secondPart[nameLength] = '\\0';\r\n  return simulinkBlockPath;\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S);\r\nstatic void mdlTerminate(SimStruct *S);\r\n\r\n/* grow the buffer for target I/O Fd array\r\n * targetIOFd->Fd is NULL on failure */\r\nstatic void growTargetIOFd(SimStruct *S, targetIOFd_T * IOFd, mwSize\r\n  requiredSize)\r\n{\r\n  if (IOFd->size < requiredSize) {\r\n    IOFd->Fd = (FILE**)mxRealloc(IOFd->Fd, requiredSize * sizeof(FILE*));\r\n    if (IOFd->Fd == NULL) {\r\n      ssSetErrorStatus( S,\"growTargetIOFd: mxRealloc failed.\");\r\n    } else {\r\n      mexMakeMemoryPersistent(IOFd->Fd);\r\n      IOFd->size = requiredSize;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic void closeAndFreeTargetIOFd(SimStruct *S)\r\n{\r\n  int i;\r\n  if (ssGetPWork(S) != NULL) {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        for (i=0; i<targetIOFdPtr->size; i++) {\r\n          if (targetIOFdPtr->Fd[i] != NULL) {\r\n            fclose(targetIOFdPtr->Fd[i]);\r\n          }                            /* if */\r\n        }                              /* for */\r\n\r\n        mxFree(targetIOFdPtr->Fd);\r\n      }                                /* if */\r\n\r\n      mxFree(targetIOFdPtr);\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 3, NULL);\r\n  }                                    /* if */\r\n}\r\n\r\n/* receive one packet of data and dispatch to owning application */\r\nstatic boolean_T recvData(SimStruct *S, void* pComms)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  if (pXILUtils == NULL) {\r\n    ssSetErrorStatus( S,\"pXILUtils is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilCommsRun(pComms, pXILUtils) !=\r\n    XILCOMMS_RTIOSTREAM_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* send data via xil comms */\r\nstatic boolean_T sendData(SimStruct *S, void* pXILService, XIL_IOBuffer_T\r\n  * IOBuffer, mwSize sendSize)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilHostAppSvcSend(pXILService, IOBuffer->data, sendSize)\r\n    != XILHOSTAPPSVC_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* implements command dispatch */\r\nstatic boolean_T commandDispatch(SimStruct *S, XIL_IOBuffer_T* IOBuffer, mwSize\r\n  dataOutSize)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  /* send the data */\r\n  if (sendData(S, pXILService, IOBuffer, dataOutSize) != XILHOSTAPPSVC_SUCCESS)\r\n  {\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\n/* implements command response */\r\nstatic boolean_T commandResponse(SimStruct *S, mwSize* dataInSize,\r\n  XILCommandResponseType* commandType)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  {\r\n    /* receive the response data */\r\n    uint8_T COMMAND_COMPLETE = 0;\r\n    void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n    if (pComms == NULL) {\r\n      ssSetErrorStatus( S,\"pComms is NULL!\");\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }                                  /* if */\r\n\r\n    while (!COMMAND_COMPLETE) {\r\n      xilHostAppSvcSetIsResponseComplete(pXILService, 0);\r\n      if (recvData(S, pComms) != XILHOSTAPPSVC_SUCCESS) {\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }                                /* if */\r\n\r\n      COMMAND_COMPLETE = xilHostAppSvcGetIsResponseComplete(pXILService);\r\n    }                                  /* while */\r\n\r\n    /* determine command response type */\r\n    *commandType = (XILCommandResponseType) COMMAND_COMPLETE;\r\n    *dataInSize = xilHostAppSvcGetPayloadSizeForOneStep(pXILService);\r\n    return XILHOSTAPPSVC_SUCCESS;\r\n  }\r\n}\r\n\r\nstatic void copyIOData(void * const dstPtr, void * const srcPtr, uint8_T **\r\n  const tgtPtrPtr, size_t numElements, size_t cTypeSize)\r\n{\r\n  size_t maxBytesConsumed = numElements * cTypeSize;\r\n  memcpy(dstPtr, srcPtr, maxBytesConsumed);\r\n  (*tgtPtrPtr)+=(maxBytesConsumed/sizeof(**tgtPtrPtr));\r\n}\r\n\r\nstatic void copyStringIOData(void * const dstPtr, void * const srcPtr, uint8_T **\r\n  const tgtPtrPtr, size_t numElements, size_t cTypeSize, uint8_T isInput)\r\n{\r\n  size_t maxBytesConsumed = numElements * cTypeSize;\r\n  if (isInput) {\r\n    suWriteSILStringInput((char *)dstPtr, (int32_T)numElements, srcPtr);\r\n  } else {\r\n    suWriteSILStringOutput(dstPtr, (char *)srcPtr, (int32_T)numElements);\r\n  }                                    /* if */\r\n\r\n  (*tgtPtrPtr)+=(maxBytesConsumed/sizeof(**tgtPtrPtr));\r\n}\r\n\r\n/* returns data needed by code instrumentation service */\r\nstatic CodeInstrServiceData_T* codeInstrServiceData(SimStruct *S, uint8_T\r\n  memUnitSizeBytes)\r\n{\r\n  CodeInstrServiceData_T* pCodeInstrServiceData = (CodeInstrServiceData_T*)\r\n    mxCalloc(1, sizeof(CodeInstrServiceData_T));\r\n  char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n  if (simulinkBlockPath == NULL) {\r\n    ssSetErrorStatus(S,\r\n                     \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n    return NULL;\r\n  }\r\n\r\n  if (pCodeInstrServiceData == NULL) {\r\n    ssSetErrorStatus( S,\r\n                     \"Error in allocating memory for code instrumentation data through mxCalloc.\");\r\n    return NULL;\r\n  }                                    /* if */\r\n\r\n  char * pXilAppDir = (char *) ssGetPWorkValue(S, 12);\r\n  if (pXilAppDir == NULL) {\r\n    ssSetErrorStatus( S,\"pXilAppDir is NULL.\");\r\n    return NULL;\r\n  }                                    /* if */\r\n\r\n  pCodeInstrServiceData->infoPath = pXilAppDir;\r\n  pCodeInstrServiceData->blockPath = simulinkBlockPath;\r\n  pCodeInstrServiceData->rootModel = ssGetPath(ssGetRootSS(S));\r\n  pCodeInstrServiceData->memUnitSize = memUnitSizeBytes;\r\n  pCodeInstrServiceData->isTimeProfilingEnabled = true;\r\n  pCodeInstrServiceData->isStackProfilingEnabled = false;\r\n  pCodeInstrServiceData->inTheLoopType = 1;\r\n  pCodeInstrServiceData->silPilInterfaceFcn =\r\n    \"@coder.connectivity.SimulinkInterface.getSILPILInterface\";\r\n  return pCodeInstrServiceData;\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S)\r\n{\r\n  closeAndFreeTargetIOFd(S);\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted != NULL) && (*pIsXILApplicationStarted == 1))\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (pXILUtils) {\r\n          mxArray *rhs[3];\r\n          char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n          if (simulinkBlockPath == NULL) {\r\n            ssSetErrorStatus(S,\r\n                             \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n            return;\r\n          }\r\n\r\n          rhs[ 0 ] = mxCreateString(\r\n            \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n          rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n          rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n          xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionPILStopHook\");\r\n          mxFree((void *) simulinkBlockPath);\r\n        }                              /* if */\r\n      }\r\n    }                                  /* if */\r\n\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      *pIsXILApplicationStarted = 0;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    XIL_IOBuffer_T* IOBufferPtr;\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    if (rtIOStreamDataPtr != NULL) {\r\n      {\r\n        int errorStatus = rtIOStreamUnloadLib(&rtIOStreamDataPtr->libH);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamUnloadLib failed.\");\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree(rtIOStreamDataPtr->lib);\r\n      mxDestroyArray(rtIOStreamDataPtr->MATLABObject);\r\n      mxFree(rtIOStreamDataPtr);\r\n      ssSetPWorkValue(S, 0, NULL);\r\n    }                                  /* if */\r\n\r\n    if (silDebuggingDataPtr != NULL) {\r\n      mxFree(silDebuggingDataPtr->componentBlockPath);\r\n      mxFree(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n      mxFree(silDebuggingDataPtr);\r\n      ssSetPWorkValue(S, 2, NULL);\r\n    }                                  /* if */\r\n\r\n    IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      mxFree(IOBufferPtr->data);\r\n      mxFree(IOBufferPtr);\r\n      ssSetPWorkValue(S, 1, NULL);\r\n    }                                  /* if */\r\n\r\n    closeAndFreeTargetIOFd(S);\r\n    if (ssGetPWork(S) != NULL) {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n      void * pCoderAssumptionsApp = (void *) ssGetPWorkValue(S, 13);\r\n      if (pCodeInstrService != NULL) {\r\n        uint8_T memUnitSizeBytes = 1;\r\n        CodeInstrServiceData_T* pCodeInstrServiceData = codeInstrServiceData(S,\r\n          memUnitSizeBytes);\r\n        codeInstrHostAppSvcDestroy(pCodeInstrService, pCodeInstrServiceData);\r\n        mxFree((void *)pCodeInstrServiceData->blockPath);\r\n        mxFree(pCodeInstrServiceData);\r\n      }                                /* if */\r\n\r\n      ssSetPWorkValue(S, 10, NULL);\r\n      if (pCoderAssumptionsApp != NULL) {\r\n        coderAssumpHostAppSvcDestroy(pCoderAssumptionsApp);\r\n        ssSetPWorkValue(S, 13, NULL);\r\n      }                                /* if */\r\n\r\n      if (pXILService != NULL) {\r\n        xilHostAppSvcDestroy(pXILService);\r\n        ssSetPWorkValue(S, 9, NULL);\r\n      }                                /* if */\r\n\r\n      if (pComms != NULL) {\r\n        xilCommsDestroy(pComms);\r\n        ssSetPWorkValue(S, 7, NULL);\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T processResponseError(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  uint8_T errorId = **mxMemUnitPtrPtr;\r\n  (*mxMemUnitPtrPtr)++;\r\n  if (errorId) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pilverification:PILError\");\r\n      rhs[1] = mxCreateDoubleScalar(errorId);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponsePrintf(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T PRINTF_ERROR;\r\n  uint16_T PRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint8_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(PRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    uint8_T *pPrintBuff;\r\n    pPrintBuff = *mxMemUnitPtrPtr;\r\n    if (pPrintBuff[PRINTF_SIZE-1] == '\\0') {\r\n      mexPrintf(\"%s\", pPrintBuff);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + PRINTF_SIZE;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFopen(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  uint16_T FOPEN_FID;\r\n  uint16_T FOPEN_NAME_SIZE;\r\n  targetIOFd_T *targetIOFdPtr;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_NAME_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n  if (targetIOFdPtr != NULL) {\r\n    /* check fid increments by 1 */\r\n    if (targetIOFdPtr->fidOffset + 1 == FOPEN_FID) {\r\n      targetIOFdPtr->fidOffset = FOPEN_FID;\r\n      growTargetIOFd(S, targetIOFdPtr, targetIOFdPtr->fidOffset + 1);\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        uint8_T *pFopenBuff;\r\n        targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = NULL;\r\n        pFopenBuff = (*mxMemUnitPtrPtr);\r\n        if (pFopenBuff[FOPEN_NAME_SIZE-1] == '\\0') {\r\n          FILE * tmpFd = NULL;\r\n          tmpFd = fopen((char *) pFopenBuff,\"w\");\r\n          if (tmpFd != NULL) {\r\n            /* save the file descriptor */\r\n            targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = tmpFd;\r\n          } else {\r\n            {\r\n              void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n              mxArray * rhs[ 2 ];\r\n              rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenError\");\r\n              rhs[1] = mxCreateString((char *) pFopenBuff);\r\n              xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n              return XILHOSTAPPSVC_ERROR;\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    } else {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenFidError\");\r\n        rhs[1] = mxCreateDoubleScalar(FOPEN_FID);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + FOPEN_NAME_SIZE;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFprintf(SimStruct * S, uint8_T\r\n  ** mxMemUnitPtrPtr)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T FPRINTF_ERROR;\r\n  uint16_T FPRINTF_FID;\r\n  uint16_T FPRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint8_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (FPRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(FPRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->size > FPRINTF_FID) {\r\n        if (targetIOFdPtr->Fd[FPRINTF_FID] != NULL) {\r\n          uint8_T *pFprintfBuff;\r\n          pFprintfBuff = (*mxMemUnitPtrPtr);\r\n          if (pFprintfBuff[FPRINTF_SIZE-1] == '\\0') {\r\n            fprintf(targetIOFdPtr->Fd[FPRINTF_FID], \"%s\", pFprintfBuff);\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + FPRINTF_SIZE ;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseSignalRaised(SimStruct * S, uint8_T\r\n  ** mxMemUnitPtrPtr)\r\n{\r\n  const char *signalStr[5] = { \"SIGFPE\", \"SIGILL\", \"SIGABRT\", \"SIGSEGV\",\r\n    \"Unknown Signal\" };\r\n\r\n  uint8_T errorId = **mxMemUnitPtrPtr;\r\n  (*mxMemUnitPtrPtr)++;\r\n\r\n  {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    mxArray * rhs[ 3 ];\r\n    rhs[0] = mxCreateString(\"Connectivity:target:CaughtTargetSignal\");\r\n    rhs[1] = mxCreateString(signalStr[errorId]);\r\n    rhs[2] = mxCreateDoubleScalar(ssGetT(S));\r\n    xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }\r\n}\r\n\r\nstatic boolean_T processErrorAndTargetIOResponseCases(SimStruct * S, const int\r\n  responseId, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  switch (responseId) {\r\n   case RESPONSE_ERROR:\r\n    {\r\n      return processResponseError(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_PRINTF:\r\n    {\r\n      return processResponsePrintf(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_FOPEN:\r\n    {\r\n      return processResponseFopen(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_FPRINTF:\r\n    {\r\n      return processResponseFprintf(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_SIGNAL_RAISED:\r\n    {\r\n      return processResponseSignalRaised(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   default:\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n        rhs[1] = mxCreateDoubleScalar(responseId);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }\r\n  }                                    /* switch */\r\n}\r\n\r\nstatic size_t getBusElementDimension(SimStruct * S, DTypeId dType, int_T\r\n  offsetIdx, const int_T ** dimsOut, int_T * numDims)\r\n{\r\n  int_T numDimensions = ssGetBusElementNumDimensions(S, dType, offsetIdx);\r\n  const int_T *dims = ssGetBusElementDimensions(S, dType, offsetIdx);\r\n  size_t numElements = 1;\r\n  int j = 0;\r\n  for (j = 0; j< numDimensions; j++) {\r\n    numElements *= dims[j];\r\n  }                                    /* for */\r\n\r\n  *dimsOut = dims;\r\n  *numDims = numDimensions;\r\n  return numElements;\r\n}\r\n\r\n/* Process params function shared between mdlStart and mdlProcessParams */\r\nstatic void processParams(SimStruct * S)\r\n{\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted!=NULL) && (*pIsXILApplicationStarted==1)) {\r\n      /* update run time params */\r\n      ssUpdateAllTunableParamsAsRunTimeParams(S);\r\n\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_PROCESS_PARAMS_COMMAND;\r\n              mxMemUnitPtr++;\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                                 num_elements, sizeof(uint32_T));\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              mwSize dataInSize = 0;\r\n              if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (dataInSize>0) {\r\n                size_t dataInMemUnitSize = dataInSize;\r\n                uint8_T responseId = 0;\r\n                uint8_T * mxMemUnitPtrEnd;\r\n                mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n                mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n                while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                  /* read response id */\r\n                  responseId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                           &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T startAndSetupApplication(SimStruct *S)\r\n{\r\n  {\r\n    {\r\n      mxArray *rhs[4];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      rhs[3] = mxCreateString(\"uint8\");\r\n\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, 0, 4, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILStartHook\")\r\n            !=XIL_UTILS_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    {                                  /* record that the XIL application has started */\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      *pIsXILApplicationStarted = 1;\r\n      ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n    }\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[3];\r\n    mxArray *lhs[5];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 5, lhs, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionGetRtIOStreamInfoHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n    }\r\n\r\n    mxFree((void *) simulinkBlockPath);\r\n\r\n    {\r\n      XIL_RtIOStreamData_T* rtIOStreamDataPtr = (XIL_RtIOStreamData_T*) mxCalloc\r\n        (1, sizeof(XIL_RtIOStreamData_T));\r\n      if (rtIOStreamDataPtr == NULL) {\r\n        ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n        return false;\r\n      }                                /* if */\r\n\r\n      rtIOStreamDataPtr->lib = mxArrayToString(lhs[0]);\r\n      rtIOStreamDataPtr->MATLABObject = mxDuplicateArray(lhs[1]);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr->lib);\r\n      mexMakeArrayPersistent(rtIOStreamDataPtr->MATLABObject);\r\n      rtIOStreamDataPtr->streamID = *mxGetPr(lhs[2]);\r\n      rtIOStreamDataPtr->recvTimeout = *mxGetPr(lhs[3]);\r\n      rtIOStreamDataPtr->sendTimeout = *mxGetPr(lhs[4]);\r\n      rtIOStreamDataPtr->isRtIOStreamCCall = 1;\r\n      rtIOStreamDataPtr->ioMxClassID = mxUINT8_CLASS;\r\n      rtIOStreamDataPtr->ioDataSize = sizeof(uint8_T);\r\n      rtIOStreamDataPtr->targetRecvBufferSizeBytes = 128;\r\n      rtIOStreamDataPtr->targetSendBufferSizeBytes = 128;\r\n\r\n      {\r\n        int errorStatus = rtIOStreamLoadLib(&rtIOStreamDataPtr->libH,\r\n          rtIOStreamDataPtr->lib);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamLoadLib failed.\");\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      ssSetPWorkValue(S, 0, rtIOStreamDataPtr);\r\n    }\r\n\r\n    {\r\n      int i;\r\n      for (i=0; i<5; i++) {\r\n        mxDestroyArray(lhs[i]);\r\n      }                                /* for */\r\n    }\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T* IOBufferPtr = (XIL_IOBuffer_T *) mxCalloc(1, sizeof\r\n      (XIL_IOBuffer_T));\r\n    if (IOBufferPtr == NULL) {\r\n      ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(IOBufferPtr);\r\n    ssSetPWorkValue(S, 1, IOBufferPtr);\r\n  }\r\n\r\n  {\r\n    SIL_DEBUGGING_DATA_T* silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T*) mxCalloc\r\n      (1, sizeof(SIL_DEBUGGING_DATA_T));\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    if (silDebuggingDataPtr == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory through mxCalloc for SIL_DEBUGGING_DATA_T.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    silDebuggingDataPtr->componentBlockPath = strcpy((char *) mxCalloc(strlen\r\n      (simulinkBlockPath)+1, sizeof(char)), simulinkBlockPath);\r\n    silDebuggingDataPtr->SILPILInterfaceFcnStr = strcpy((char*) mxCalloc(57,\r\n      sizeof(char)), \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    silDebuggingDataPtr->inTheLoopType = 1;\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->componentBlockPath);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n    ssSetPWorkValue(S, 2, silDebuggingDataPtr);\r\n    mxFree((void *) simulinkBlockPath);\r\n  }\r\n\r\n  {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) mxCalloc(1, sizeof\r\n      (targetIOFd_T));\r\n    if (targetIOFdPtr == NULL) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(targetIOFdPtr);\r\n    targetIOFdPtr->size = 0;\r\n    targetIOFdPtr->Fd = NULL;\r\n    targetIOFdPtr->fidOffset = -1;\r\n    ssSetPWorkValue(S, 3, targetIOFdPtr);\r\n  }\r\n\r\n  {\r\n    void* pConnectionOptions = NULL;\r\n    void* pComms = NULL;\r\n    void* pXILService = NULL;\r\n    void* pMemUnitTransformer = NULL;\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    uint8_T memUnitSizeBytes = 1;\r\n    uint8_T ioDataTypeSizeBytes = sizeof(uint8_T);\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    void* pCodeInstrService = NULL;\r\n    CodeInstrServiceData_T* pCodeInstrServiceData = codeInstrServiceData(S,\r\n      memUnitSizeBytes);\r\n    void * pCoderAssumptionsApp = NULL;\r\n    if (xilCommsCreate(&pComms, rtIOStreamDataPtr, silDebuggingDataPtr,\r\n                       memUnitSizeBytes, pMemUnitTransformer, pXILUtils, 0) !=\r\n        XILCOMMS_RTIOSTREAM_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    if (xilHostAppSvcCreate(&pXILService, pComms, pXILUtils, IOBufferPtr,\r\n                            memUnitSizeBytes, ioDataTypeSizeBytes, 0) !=\r\n        XILHOSTAPPSVC_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    {\r\n      void * pCodeInstrMultiRunData = NULL;\r\n      pCodeInstrMultiRunData = (void *) ssGetPWorkValue(S, 11);\r\n      if (codeInstrHostAppSvcCreate(&pCodeInstrService, pCodeInstrServiceData,\r\n           pComms, pMemUnitTransformer, 32, pXILUtils, memUnitSizeBytes, 0,\r\n           pCodeInstrMultiRunData) != CODEINSTRHOSTAPPSVC_SUCCESS) {\r\n        mxFree((void *)pCodeInstrServiceData->blockPath);\r\n        mxFree(pCodeInstrServiceData);\r\n        return false;\r\n      }                                /* if */\r\n\r\n      mxFree((void *)pCodeInstrServiceData->blockPath);\r\n      mxFree(pCodeInstrServiceData);\r\n    }\r\n\r\n    {\r\n      mxArray * codeGenComponent = mxCreateString(\"TestPilAdc\");\r\n      mxArray *rhs[3];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      if (coderAssumpHostAppSvcCreate(&pCoderAssumptionsApp, pComms, pXILUtils,\r\n           0, 1, codeGenComponent, rhs[0], rhs[1], rhs[2], 1, 0, 0) !=\r\n          CODERASSUMPHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    xilCommsRegisterApplication(pComms, pXILService);\r\n    xilCommsRegisterApplication(pComms, pCodeInstrService);\r\n    xilCommsRegisterApplication(pComms, pCoderAssumptionsApp);\r\n    ssSetPWorkValue(S, 9, pXILService);\r\n    ssSetPWorkValue(S, 7, pComms);\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n    ssSetPWorkValue(S, 10, pCodeInstrService);\r\n    ssSetPWorkValue(S, 13, pCoderAssumptionsApp);\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_INIT_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return false;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n\r\n#define RESPONSE_TYPE_SIZE             7\r\n\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return false;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_TYPE_SIZE:\r\n                {\r\n                  uint8_T typeBytes;\r\n                  uint8_T typeId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  typeBytes = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (typeId) {\r\n                   case SS_SINGLE:\r\n                    {\r\n                      if (typeBytes != 4) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:SingleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(4);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   case SS_DOUBLE:\r\n                    {\r\n                      if (typeBytes != 8) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:DoubleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(8);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownTypeId\");\r\n                        rhs[1] = mxCreateDoubleScalar(typeId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        return false;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return false;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n\r\n  /* initialize parameters */\r\n  processParams(S);\r\n  return true;\r\n}\r\n\r\nstatic void sendInitializeCommand(SimStruct *S)\r\n{\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_INITIALIZE_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_PRE_DATA:\r\n                {\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_DATA:\r\n                {\r\n                  {\r\n                    /* DataInterface: output, 1 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      0);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 1 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          copyIOData(simDataMemUnitPtr, mxMemUnitPtr,\r\n                                     &mxMemUnitPtr, num_elements, sizeof\r\n                                     (real32_T));\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstatic void initializeInfAndMinusInf(void)\r\n{\r\n  typedef struct {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  } LittleEndianIEEEDouble;\r\n\r\n  rtInf = 0.0;\r\n  rtMinusInf = 0.0;\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal1;\r\n\r\n    tmpVal1.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal1.bitVal.words.wordL = 0x00000000U;\r\n    rtInf = tmpVal1.fltVal;\r\n  }\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal2;\r\n\r\n    tmpVal2.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal2.bitVal.words.wordL = 0x00000000U;\r\n    rtMinusInf = tmpVal2.fltVal;\r\n  }\r\n}\r\n\r\nstatic void mdlSystemInitialize(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    int * pIsXILApplicationStartedLocal = (int *) ssGetPWorkValue(S, 5);\r\n    if (pIsXILApplicationStartedLocal == NULL || (*pIsXILApplicationStartedLocal)\r\n        == 0) {\r\n      boolean_T applicationStarted = startAndSetupApplication(S);\r\n      if (!applicationStarted) {\r\n        return;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n\r\n    sendInitializeCommand(S);\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_SYSTEM_INITIALIZE_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        time_T simTime = ssGetT(S);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstatic void mdlSystemReset(SimStruct *S)\r\n{\r\n  {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    mxArray * prhs[ 1 ];\r\n    prhs[0] = mxCreateString(\"PIL:pil:InitCondOptimCallbackError\");\r\n    if (xilUtilsCallMATLAB(pXILUtils, 0, NULL, 1, prhs, \"DAStudio.error\") !=\r\n        XIL_UTILS_SUCCESS) {\r\n      return;\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\nstatic void mdlPeriodicOutputUpdate(SimStruct *S, int_T tid);\r\n\r\n/* This function checks the attributes of tunable parameters. */\r\n#define MDL_CHECK_PARAMETERS\r\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlCheckParameters(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSFcnParams(S, 0);            /* Number of expected parameters */\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif\r\n\r\n    if (ssGetErrorStatus(S) != (NULL))\r\n      return;\r\n  } else {\r\n    /* Parameter mismatch will be reported by Simulink */\r\n    return;\r\n  }\r\n\r\n  ssSetNumContStates(S, 0);\r\n  ssSetNumDiscStates(S, 0);\r\n\r\n  /* no support for SimState */\r\n  ssSetSimStateCompliance(S, DISALLOW_SIM_STATE);\r\n\r\n  /* Allow signal dimensions greater than 2 */\r\n  ssAllowSignalsWithMoreThan2D(S);\r\n\r\n  /* Allow fixed-point data types with 33 or more bits */\r\n  ssFxpSetU32BitRegionCompliant(S,1);\r\n  initializeInfAndMinusInf();\r\n  ssSetRTWGeneratedSFcn(S, 2);\r\n  if ((S->mdlInfo->genericFcn != (NULL)) && (!(S->mdlInfo->genericFcn)(S,\r\n        GEN_FCN_CHK_MODELREF_SFUN_HAS_MODEL_BLOCK, -1, (NULL)))) {\r\n    return;\r\n  }\r\n\r\n  slmrInitializeIOPortDataVectors(S, 1, 1);\r\n  if (!ssSetNumInputPorts(S, 1))\r\n    return;\r\n  if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  ssSetInputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);\r\n  ssSetInputPortFrameData(S, 0, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetInputPortDataType(S, 0, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetInputPortUnit(S, 0, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n  ssSetInputPortRequiredContiguous(S, 0, 1);\r\n  ssSetInputPortOverWritable(S, 0, false);\r\n  ssSetInputPortSampleTime(S, 0, 0.2);\r\n  ssSetInputPortOffsetTime(S, 0, 0.0);\r\n  if (!ssSetNumOutputPorts(S, 1))\r\n    return;\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  ssSetOutputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);\r\n  ssSetOutputPortFrameData(S, 0, FRAME_NO);\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_SINGLE);\r\n  }\r\n\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\n    UnitId unitIdReg;\r\n    ssRegisterUnitFromExpr(\r\n      S,\r\n      \"\",\r\n      &unitIdReg);\r\n    if (unitIdReg == INVALID_UNIT_ID)\r\n      return;\r\n    ssSetOutputPortUnit(S, 0, unitIdReg);\r\n\r\n#endif\r\n\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 0, 0.2);\r\n  ssSetOutputPortOffsetTime(S, 0, 0.0);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetOutputPortOkToMerge(S, 0, SS_OK_TO_MERGE_CONDITIONAL);\r\n  }                                    /* if */\r\n\r\n  ssSetOutputPortICAttributes(S, 0, false, false, false);\r\n\r\n  {\r\n    int_T zcsIdx = 0;\r\n  }\r\n\r\n  ssSetOutputPortIsNonContinuous(S, 0, 0);\r\n  ssSetOutputPortIsFedByBlockWithModesNoZCs(S, 0, 0);\r\n  ssSetInputPortIsNotDerivPort(S, 0, 1);\r\n  ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n    DISALLOW_SAMPLE_TIME_INHERITANCE);\r\n  ssSupportsMultipleExecInstances(S, false);\r\n  ssRegisterMsgForNotSupportingMultiExecInst(S,\r\n    \"<diag_root><diag id=\\\"Simulink:blocks:UserSFcnBlockDoesNotSupportMultiExecInstances\\\" pr=\\\"d\\\"><arguments><arg type=\\\"encoded\\\">VABlAHMAdABQAGkAbABBAGQAYwAvAFMAVABNADMAMgBfAEMAbwBuAGYAaQBnAAAA</arg><arg type=\\\"encoded\\\">PABfAF8AaQBpAFMAUwBfAF8APgA8AC8AXwBfAGkAaQBTAFMAXwBfAD4AAAA=</arg><arg type=\\\"encoded\\\">PABfAF8AaQB0AGUAcgBCAGwAawBfAF8APgA8AC8AXwBfAGkAdABlAHIAQgBsAGsAXwBfAD4AAAA=</arg></arguments><hs><h>AAAAqAACvEBb</h></hs></diag></diag_root>\");\r\n  ssSetAcceptsFcnCallInputs(S);\r\n  ssSetNumSampleTimes(S, 2);\r\n  ssSetParameterTuningCompliance(S, true);\r\n  ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n    DISALLOW_SAMPLE_TIME_INHERITANCE);\r\n  ssSetOptions(S, SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED |\r\n               SS_OPTION_SUPPORTS_ALIAS_DATA_TYPES |\r\n               SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME |\r\n               SS_OPTION_CALL_TERMINATE_ON_EXIT);\r\n  slmrRegisterSystemInitializeMethod(S, mdlSystemInitialize);\r\n  slmrRegisterSystemResetMethod(S, mdlSystemReset);\r\n  slmrRegisterPeriodicOutputUpdateMethod(S, mdlPeriodicOutputUpdate);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetNumPWork(S, 0);\r\n  } else {\r\n    ssSetNumPWork(S, 14);\r\n  }                                    /* if */\r\n\r\n  ssSetNumRWork(S, 0);\r\n  ssSetNumIWork(S, 0);\r\n  ssSetNumModes(S, 0);\r\n  ssSetNumNonsampledZCs(S, 0);\r\n  ssSetModelReferenceNormalModeSupport(S, MDL_START_AND_MDL_PROCESS_PARAMS_OK);\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  if (S->mdlInfo->genericFcn != (NULL) &&\r\n      ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssRegModelRefMdlInfo(S, (char *)\"TestPilAdc\", rtMdlInfo_TestPilAdc, 0);\r\n  }\r\n\r\n#endif\r\n\r\n  /* DWork */\r\n  if (!ssRTWGenIsAccelerator(S)) {\r\n    ssSetNumDWork(S, 0);\r\n  }                                    /* if */\r\n}\r\n\r\n#define MDL_SET_INPUT_PORT_SAMPLE_TIME                           /* Change to #undef to remove function */\r\n#if defined(MDL_SET_INPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetInputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* sample times are fully specified, not inherited */\r\n}\r\n\r\n#endif                                 /* MDL_SET_INPUT_PORT_SAMPLE_TIME */\r\n\r\n#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME                          /* Change to #undef to remove function */\r\n#if defined(MDL_SET_OUTPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetOutputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* sample times are fully specified, not inherited */\r\n}\r\n\r\n#endif                                 /* MDL_SET_OUTPUT_PORT_SAMPLE_TIME */\r\n\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  ssSetSampleTime(S, 0, 0.001);\r\n  ssSetOffsetTime(S, 0, 0);\r\n  ssSetSampleTime(S, 1, 0.2);\r\n  ssSetOffsetTime(S, 1, 0);\r\n  return;\r\n}\r\n\r\n#define MDL_SETUP_RUNTIME_RESOURCES                              /* Change to #undef to remove function */\r\n#if defined(MDL_SETUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlSetupRuntimeResources(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    mxArray * error = NULL;\r\n    error = mexCallMATLABWithTrap( 0, NULL, 0, NULL,\r\n      \"rtw.pil.checkEmbeddedCoderInstalled\");\r\n    if (error != NULL) {\r\n      mexCallMATLAB( 0, NULL, 1, &error, \"throw\");\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    mxArray * lhs[1];\r\n    mxArray * error = NULL;\r\n    char * installVersion;\r\n    error = mexCallMATLABWithTrap(1, lhs, 0, NULL, \"rtw.pil.getPILVersion\");\r\n    if (error != NULL) {\r\n      mxDestroyArray(error);\r\n      ssSetErrorStatus( S,\r\n                       \"Failed to determine the installed In-the-Loop version for comparison against the In-the-Loop s-function version (release 9.12 (R2022a)_15). To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory).\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (mxIsEmpty(lhs[0])) {\r\n      ssSetErrorStatus( S,\"rtw.pil.getPILVersion returned empty!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    installVersion = mxArrayToString(lhs[0]);\r\n    mxDestroyArray(lhs[0]);\r\n    if (installVersion == NULL) {\r\n      ssSetErrorStatus( S,\"Failed to determine installed In-the-Loop version.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (strcmp(installVersion, \"9.12 (R2022a)_15\") != 0) {\r\n      ssSetErrorStatus( S,\r\n                       \"The In-the-Loop s-function is incompatible with the installed In-the-Loop version (see ver('matlab')); it was generated for release 9.12 (R2022a)_15. To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory)\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    mxFree(installVersion);\r\n  }\r\n\r\n  {\r\n    int retValXILUtils = XIL_UTILS_SUCCESS;\r\n    void* pXILUtils = NULL;\r\n    retValXILUtils = xilSimulinkUtilsCreate(&pXILUtils, S);\r\n    if (retValXILUtils!=XIL_UTILS_SUCCESS) {\r\n      ssSetErrorStatus( S,\"Error instantiating XIL Utils!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n  }\r\n\r\n  {\r\n    int * pCommErrorOccurred = (int *) mxCalloc(1, sizeof(int));\r\n    if (pCommErrorOccurred == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pCommErrorOccurred through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pCommErrorOccurred = 0;\r\n    mexMakeMemoryPersistent(pCommErrorOccurred);\r\n    ssSetPWorkValue(S, 4, pCommErrorOccurred);\r\n  }\r\n\r\n  {\r\n    int * pIsXILApplicationStarted = (int *) mxCalloc(1, sizeof(int));\r\n    if (pIsXILApplicationStarted == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pIsXILApplicationStarted through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pIsXILApplicationStarted = 0;\r\n    mexMakeMemoryPersistent(pIsXILApplicationStarted);\r\n    ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[4];\r\n    mxArray *lhs[2];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n    rhs[3] = mxCreateString(ssGetPath(ssGetRootSS(S)));\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 2, lhs, 4, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionInitializeHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      char * rootLoggingPath;\r\n      rootLoggingPath = mxArrayToString(lhs[1]);\r\n      mxFree((void *) simulinkBlockPath);\r\n      mxFree(rootLoggingPath);\r\n    }\r\n\r\n    {\r\n      void * multiRunDataPtr = xilSimulinkUtilsStaticInitMultiRunInstrData();\r\n      ssSetPWorkValue(S, 11, multiRunDataPtr);\r\n    }\r\n\r\n    char * pXilAppDir;\r\n    pXilAppDir = mxArrayToString(lhs[0]);\r\n    mexMakeMemoryPersistent(pXilAppDir);\r\n    ssSetPWorkValue(S, 12, pXilAppDir);\r\n    mxDestroyArray(lhs[0]);\r\n    mxDestroyArray(lhs[1]);\r\n  }\r\n}\r\n\r\n#endif                                 /* MDL_SETUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_SIM_STATUS_CHANGE                                    /* Change to #undef to remove function */\r\n#if defined(MDL_SIM_STATUS_CHANGE)\r\n\r\nstatic void mdlSimStatusChange(SimStruct *S, ssSimStatusChangeType simStatus)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  if (simStatus == SIM_PAUSE) {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n        if (pXILService != NULL) {\r\n          if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return ;\r\n          }                            /* if */\r\n\r\n          if (IOBufferPtr->data != NULL) {\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n            /* write command id */\r\n            *mxMemUnitPtr = (uint8_T) XIL_PAUSE_COMMAND;\r\n            mxMemUnitPtr++;\r\n\r\n            {\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n                uint32_T commandDataFcnid = 0;\r\n                simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                               num_elements, sizeof(uint32_T));\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n        /* provide the time information to the code instrumentation service */\r\n        {\r\n          void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n          time_T simTime = ssGetT(S);\r\n          if (pCodeInstrService != NULL) {\r\n            codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n          }                            /* if */\r\n        }\r\n\r\n        /* dispatch command to the target */\r\n        if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        {\r\n          XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n          while (commandResponseType != XIL_STEP_COMPLETE) {\r\n            /* receive command from the target */\r\n            mwSize dataInSize = 0;\r\n            if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return ;\r\n            }                          /* if */\r\n\r\n            if (dataInSize>0) {\r\n              size_t dataInMemUnitSize = dataInSize;\r\n              uint8_T responseId = 0;\r\n              uint8_T * mxMemUnitPtrEnd;\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n              mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n              while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                /* read response id */\r\n                responseId = *mxMemUnitPtr;\r\n                mxMemUnitPtr++;\r\n                switch (responseId) {\r\n                 case RESPONSE_ERROR:\r\n                 case RESPONSE_PRINTF:\r\n                 case RESPONSE_FOPEN:\r\n                 case RESPONSE_FPRINTF:\r\n                 case RESPONSE_SIGNAL_RAISED:\r\n                  {\r\n                    if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                         &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                      return ;\r\n                    }                  /* if */\r\n                    break;\r\n                  }\r\n\r\n                 default:\r\n                  {\r\n                    {\r\n                      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                      mxArray * rhs[ 2 ];\r\n                      rhs[0] = mxCreateString(\r\n                        \"PIL:pilverification:UnknownResponseId\");\r\n                      rhs[1] = mxCreateDoubleScalar(responseId);\r\n                      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                      return ;\r\n                    }\r\n                    break;\r\n                  }\r\n                }                      /* switch */\r\n              }                        /* while */\r\n            }                          /* if */\r\n          }                            /* while */\r\n        }\r\n      }\r\n    }\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (pXILUtils) {\r\n        mxArray *rhs[3];\r\n        char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n        if (simulinkBlockPath == NULL) {\r\n          ssSetErrorStatus(S,\r\n                           \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n          return;\r\n        }\r\n\r\n        rhs[ 0 ] = mxCreateString(\r\n          \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n        rhs[ 1 ] = mxCreateDoubleScalar( 1 );\r\n        rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILPauseHook\")\r\n            != XIL_UTILS_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        mxFree((void *) simulinkBlockPath);\r\n      }                                /* if */\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SIM_STATUS_CHANGE */\r\n\r\nstatic void XILoutputTID01(SimStruct *S, int tid)\r\n{\r\n  time_T taskTime = ssGetTaskTime(S, 0);\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 9, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_OUTPUT_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnidTID[2] = { 0, 1 };\r\n\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnidTID[0];\r\n\r\n              {\r\n                size_t num_elements = 2;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, taskTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 9)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n    if (dataInSize>0) {\r\n      size_t dataInMemUnitSize = dataInSize;\r\n      uint8_T responseId = 0;\r\n      uint8_T * mxMemUnitPtrEnd;\r\n      mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n      mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n      while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n        /* read response id */\r\n        responseId = *mxMemUnitPtr;\r\n        mxMemUnitPtr++;\r\n        switch (responseId) {\r\n         case RESPONSE_ERROR:\r\n         case RESPONSE_PRINTF:\r\n         case RESPONSE_FOPEN:\r\n         case RESPONSE_FPRINTF:\r\n         case RESPONSE_SIGNAL_RAISED:\r\n          {\r\n            if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                 &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n              return;\r\n            }                          /* if */\r\n            break;\r\n          }\r\n\r\n         default:\r\n          {\r\n            {\r\n              void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n              mxArray * rhs[ 2 ];\r\n              rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n              rhs[1] = mxCreateDoubleScalar(responseId);\r\n              xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        }                              /* switch */\r\n      }                                /* while */\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\nstatic void XILoutputTID02(SimStruct *S, int tid)\r\n{\r\n  time_T taskTime = ssGetTaskTime(S, 1);\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 13, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_OUTPUT_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnidTID[2] = { 0, 2 };\r\n\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnidTID[0];\r\n\r\n              {\r\n                size_t num_elements = 2;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          {\r\n            /* DataInterface: input, 1 */\r\n            void * dataInterfacePtr = (void *) ssGetInputPortSignal(S, 0);\r\n\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n\r\n              /* DataInterface: input, 1 */\r\n              simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(real32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* provide the time information to the code instrumentation service */\r\n      {\r\n        void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n        if (pCodeInstrService != NULL) {\r\n          codeInstrHostAppSvcSetTime(pCodeInstrService, taskTime);\r\n        }                              /* if */\r\n      }\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 13)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_PRE_DATA:\r\n                {\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_OUTPUT_DATA:\r\n                {\r\n                  {\r\n                    /* DataInterface: output, 1 */\r\n                    void * dataInterfacePtr = (void *) ssGetOutputPortSignal(S,\r\n                      0);\r\n\r\n                    {\r\n                      uint8_T * simDataMemUnitPtr;\r\n\r\n                      /* DataInterface: output, 1 */\r\n                      simDataMemUnitPtr = ( uint8_T *) dataInterfacePtr;\r\n\r\n                      {\r\n                        size_t num_elements = 1;\r\n\r\n                        {\r\n                          copyIOData(simDataMemUnitPtr, mxMemUnitPtr,\r\n                                     &mxMemUnitPtr, num_elements, sizeof\r\n                                     (real32_T));\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n    if (dataInSize>0) {\r\n      size_t dataInMemUnitSize = dataInSize;\r\n      uint8_T responseId = 0;\r\n      uint8_T * mxMemUnitPtrEnd;\r\n      mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n      mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n      while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n        /* read response id */\r\n        responseId = *mxMemUnitPtr;\r\n        mxMemUnitPtr++;\r\n        switch (responseId) {\r\n         case RESPONSE_ERROR:\r\n         case RESPONSE_PRINTF:\r\n         case RESPONSE_FOPEN:\r\n         case RESPONSE_FPRINTF:\r\n         case RESPONSE_SIGNAL_RAISED:\r\n          {\r\n            if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                 &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n              return;\r\n            }                          /* if */\r\n            break;\r\n          }\r\n\r\n         default:\r\n          {\r\n            {\r\n              void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n              mxArray * rhs[ 2 ];\r\n              rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n              rhs[1] = mxCreateDoubleScalar(responseId);\r\n              xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        }                              /* switch */\r\n      }                                /* while */\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\n#define MDL_PROCESS_PARAMETERS\r\n#if defined(MDL_PROCESS_PARAMETERS)\r\n\r\nstatic void mdlProcessParameters(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  processParams(S);\r\n}\r\n\r\n#endif                                 /* MDL_PROCESS_PARAMETERS */\r\n\r\n#define MDL_SET_WORK_WIDTHS                                      /* Change to #undef to remove function */\r\n#if defined(MDL_SET_WORK_WIDTHS)\r\n\r\nstatic void mdlSetWorkWidths(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    if (S->mdlInfo->genericFcn != (NULL)) {\r\n      _GenericFcn fcn = S->mdlInfo->genericFcn;\r\n      ssSetSignalSizesComputeType(S, SS_VARIABLE_SIZE_FROM_INPUT_VALUE_AND_SIZE);\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SET_WORK_WIDTHS */\r\n\r\nstatic void mdlPeriodicOutputUpdate(SimStruct *S, int_T tid)\r\n{\r\n  /* Periodic Output Update sample time matching */\r\n  /* check for sample time hit associated with task 1 */\r\n  if (tid == 0) {\r\n    XILoutputTID01(S, tid);\r\n  }                                    /* if */\r\n\r\n  /* check for sample time hit associated with task 2 */\r\n  if (tid == 1) {\r\n    XILoutputTID02(S, tid);\r\n  }                                    /* if */\r\n}\r\n\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  /* Multirate, multitasking scheduling */\r\n  /* check for sample time hit associated with task 1 */\r\n  if (ssIsSampleHit(S, 0, tid)) {\r\n    XILoutputTID01(S, tid);\r\n  }                                    /* if */\r\n\r\n  /* Multirate, multitasking scheduling */\r\n  /* check for sample time hit associated with task 2 */\r\n  if (ssIsSampleHit(S, 1, tid)) {\r\n    XILoutputTID02(S, tid);\r\n  }                                    /* if */\r\n}\r\n\r\n#define MDL_UPDATE\r\n#if defined(MDL_UPDATE)\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n}\r\n\r\n#endif\r\n\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n  int commErrorOccurred = 0;\r\n  int isXILApplicationStarted = 0;\r\n\r\n  {\r\n    if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (ssGetPWork(S) != NULL) {\r\n      int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      if (pCommErrorOccurred != NULL) {\r\n        commErrorOccurred = *pCommErrorOccurred;\r\n      }                                /* if */\r\n\r\n      if (pIsXILApplicationStarted != NULL) {\r\n        isXILApplicationStarted = *pIsXILApplicationStarted;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  if (isXILApplicationStarted) {\r\n    if (!commErrorOccurred) {\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_TERMINATE_COMMAND;\r\n              mxMemUnitPtr++;\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                                 num_elements, sizeof(uint32_T));\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              mwSize dataInSize = 0;\r\n              if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                callStopHookAndFreeSFcnMemory(S);\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (dataInSize>0) {\r\n                size_t dataInMemUnitSize = dataInSize;\r\n                uint8_T responseId = 0;\r\n                uint8_T * mxMemUnitPtrEnd;\r\n                mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n                mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n                while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                  /* read response id */\r\n                  responseId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                           &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }\r\n      }\r\n\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 1, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_SHUTDOWN_COMMAND;\r\n              mxMemUnitPtr++;\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* provide the time information to the code instrumentation service */\r\n          {\r\n            void * pCodeInstrService = (void *) ssGetPWorkValue(S, 10);\r\n            time_T simTime = ssGetT(S);\r\n            if (pCodeInstrService != NULL) {\r\n              codeInstrHostAppSvcSetTime(pCodeInstrService, simTime);\r\n            }                          /* if */\r\n          }\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 1)!=XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  callStopHookAndFreeSFcnMemory(S);\r\n}\r\n\r\n#define MDL_CLEANUP_RUNTIME_RESOURCES                            /* Change to #undef to remove function */\r\n#if defined(MDL_CLEANUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlCleanupRuntimeResources(SimStruct *S)\r\n{\r\n  mdlTerminate(S);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    void * pCodeInstrMultiRunData = NULL;\r\n    pCodeInstrMultiRunData = (void *) ssGetPWorkValue(S, 11);\r\n    xilSimulinkUtilsStaticFreeMultiRunInstrData(pCodeInstrMultiRunData);\r\n  }\r\n\r\n  {\r\n    char * pXilAppDir = NULL;\r\n    pXilAppDir = (char *) ssGetPWorkValue(S, 12);\r\n    if (pXilAppDir != NULL) {\r\n      mxFree(pXilAppDir);\r\n      ssSetPWorkValue(S, 12, NULL);\r\n    }                                  /* if */\r\n  }\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      mxFree(pIsXILApplicationStarted);\r\n      ssSetPWorkValue(S, 5, NULL);\r\n    }                                  /* if */\r\n\r\n    if (pCommErrorOccurred != NULL) {\r\n      mxFree(pCommErrorOccurred);\r\n      ssSetPWorkValue(S, 4, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    if (pXILUtils != NULL) {\r\n      xilUtilsDestroy(pXILUtils);\r\n      ssSetPWorkValue(S, 6, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_CLEANUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_ENABLE\r\n#if defined(MDL_ENABLE)\r\n\r\nstatic void mdlEnable(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_ENABLE */\r\n\r\n#define MDL_DISABLE\r\n#if defined(MDL_DISABLE)\r\n\r\nstatic void mdlDisable(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_DISABLE */\r\n\r\n/* Required S-function trailer */\r\n#ifdef MATLAB_MEX_FILE                 /* Is this file being compiled as a MEX-file? */\r\n#include \"simulink.c\"                  /* MEX-file interface mechanism */\r\n#include \"fixedpoint.c\"\r\n#else\r\n#error Assertion failed: file must be compiled as a MEX-file\r\n#endif\r\n"},{"name":"XILTgtAppSvc.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_h\n#define XILTgtAppSvc_h\n\n#include \"XILTgtAppSvc_spec.h\"\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_XILTGTAPPSVC)\n       \n    typedef uint8_T IOUnit_T;   \n#else\n   \n    #include \"xilcomms_rtiostream.h\"\n#endif\n       \n#ifdef USE_XILTGTAPPSVC_ERROR\n    static const boolean_T XILTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_XILTGTAPPSVC_SUCCESS\n    static const boolean_T XILTGTAPPSVC_SUCCESS = 1;\n#endif\n\n#define XIL_RTIOSTREAM_BASED_SERVICE_ID 1\ntypedef enum {XIL_COMMAND_NOT_COMPLETE=0,\n              XIL_COMMAND_COMPLETE,\n              XIL_STEP_COMPLETE} XILCommandResponseType;\n             \n#endif\n"},{"name":"XILTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_CInterface_h\n#define XILTgtAppSvc_CInterface_h\n\n#include \"XILTgtAppSvc.h\"\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcCreate(void);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcDestroy(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T* xilTgtAppSvcGetReceivedData(uint16_T* size);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcFreeLastReceivedData(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nXILTGTAPPSVC_API_EXTERN_C IOUnit_T* xilTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nXILTGTAPPSVC_API_EXTERN_C uint16_T xilTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"codeinstr_data_stream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2015 The MathWorks, Inc. */\n\n#include \"codeinstr_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"CodeInstrTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API    \n    #define CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE codeInstrTgtAppSvcGetMaxPayloadCapacity()\n    #define BUFFER_HEADER_SIZE 0    \n#else\n    #include \"rx_tx_buffer_sizes.h\"    \n#endif\n\n#define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n#define COMMAND_COMPLETE_IDX 0\n#define WRITE_DATA_BUFFER_IDX (COMMAND_COMPLETE_IDX + COMMAND_COMPLETE_SIZE)\n#define USED_WRITE_BUFFER_SIZE (COMMAND_COMPLETE_SIZE + codeInstrWriteDataAvail)\n#define WRITE_BUFFER_SIZE (CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE - COMMAND_COMPLETE_SIZE - BUFFER_HEADER_SIZE)\n\nstatic void* pBuffer;\nstatic IOUnit_T* codeInstrWriteBuffer;\nstatic IOUnit_T* codeInstrWriteDataPtr;\nstatic uint16_T codeInstrWriteDataAvail;\nstatic MemUnit_T* commandComplete;\n\n/* reset the write buffer */\nstatic XIL_INTERFACE_LIB_ERROR_CODE resetCodeInstrWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the CodeInstr app service will \n     * use for transmission\n     */\n    if (!codeInstrTgtAppSvcAllocBuffer(&pBuffer, CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    codeInstrWriteBuffer = codeInstrTgtAppSvcGetBufferDataPtr(pBuffer);\n    \n    /* set commandComplete and codeInstrWriteDataPtr pointer */\n    commandComplete = (MemUnit_T *) &codeInstrWriteBuffer[COMMAND_COMPLETE_IDX];\n    codeInstrWriteDataPtr = &codeInstrWriteBuffer[WRITE_DATA_BUFFER_IDX];\n    \n    /* ready for next command */\n    codeInstrWriteDataAvail = 0;\n    *commandComplete = 0;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE codeInstrInit(void) {\n    /* Create code instrumentation app service */\n    if (codeInstrTgtAppSvcCreate() != CODEINSTRTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* Reset write buffer */\n    return resetCodeInstrWriteBuffer();\n}\n\nvoid codeInstrTerminate(void) {\n    codeInstrTgtAppSvcDestroy();\n}\n\n/* send pending writes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendWriteBuffer(void) {\n   /* send */\n   if (codeInstrTgtAppSvcSend(pBuffer, USED_WRITE_BUFFER_SIZE) == CODEINSTRTGTAPPSVC_ERROR) {             \n      return XIL_DATA_FLUSH_ERROR;\n   }   \n   \n   /* reset */\n   if (resetCodeInstrWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_DATA_FLUSH_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\n\nXIL_DATA_STREAM_ERROR_CODE codeInstrWriteData(const MemUnit_T * src, uint32_T size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   const IOUnit_T * srcPtr = (const IOUnit_T *) src;   \n   size_t transferAmount;\n   uint16_T bufferAvail;\n  \n   /* block until all data is processed */\n   while (size > 0) {      \n      /* send if we have a full message worth of data */   \n      if (codeInstrWriteDataAvail == WRITE_BUFFER_SIZE) {\n         errorCode = sendWriteBuffer();\n         if (errorCode != XIL_DATA_STREAM_SUCCESS) {\n            return errorCode;\n         }\n      }\n      bufferAvail = WRITE_BUFFER_SIZE - codeInstrWriteDataAvail;\n      transferAmount = (uint16_T) MIN(bufferAvail, size);\n      /* copy data into write buffer */\n      memcpy((void *) codeInstrWriteDataPtr, srcPtr, transferAmount);\n      size -= (uint32_T) transferAmount;\n      codeInstrWriteDataAvail += (uint16_T) transferAmount;\n      srcPtr += transferAmount;\n      codeInstrWriteDataPtr += transferAmount;\n   }\n   return errorCode;\n}\n\n\nXIL_DATA_STREAM_ERROR_CODE codeInstrDataFlush(void) {   \n\n    /* final part of command */\n    *commandComplete = 1;\n\n    /* send the write buffer */\n    if (sendWriteBuffer() == XIL_DATA_FLUSH_ERROR){\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n    return XIL_DATA_STREAM_SUCCESS;\n\n}\n"},{"name":"codeinstr_data_stream.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n/* \n * File: codeInstr_data_stream.h\n *\n */\t\t\t\t\t \n\n/* need error codes */\n#include \"xil_interface_lib.h\"\n\n/* initialize code instrumentation service */\nextern XIL_INTERFACE_LIB_ERROR_CODE codeInstrInit(void);\n/* terminate code instrumentation service */\nextern void codeInstrTerminate(void);\n/* copy specified amount of data from the address specified to the output stream */\nextern XIL_DATA_STREAM_ERROR_CODE codeInstrWriteData(const MemUnit_T *, uint32_T);\n/* flush any buffered writes */\nextern XIL_DATA_STREAM_ERROR_CODE codeInstrDataFlush(void);\n"},{"name":"codeinstr_rtiostream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"CodeInstrTgtAppSvc_CInterface.h\"\n\n/* code instrumentation buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T codeInstrWriteBuffer[CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T codeInstrTgtAppSvcCreate(void) {\n    return CODEINSTRTGTAPPSVC_SUCCESS;\n}\n\nextern void codeInstrTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T codeInstrTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &codeInstrWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return CODEINSTRTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to the code instrumentation buffer data */\nextern IOUnit_T * codeInstrTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &codeInstrWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T codeInstrTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, CODEINSTR_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"coder_assumptions_app.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"coder_assumptions_app.h\"\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n\n/*\n * Include coder_assumptions.h for Hardware Implementation setting\n * preprocessor validation checks.\n * These checks verify fundamental data types that the comms \n * stack relies on, e.g. uint8_T, uint16_T, uint32_T.\n *\n * Also access the global results variables and the entry point\n * function for running coder assumptions tests.\n */\n#include \"coder_assumptions.h\" \n\n/* combine arguments (after expanding arguments) */\n#define CA_EXP_CONCAT(a,b) CA_CONCAT(a,b)\n#define CA_CONCAT(a,b) a ## b\n\n/* Compile time static assert for checking fundamental assumptions such \n * as sizeof values for specific data types. */\n#define CA_STATIC_ASSERT(expr, msg) typedef char CA_EXP_CONCAT(assert_failed__, msg) [(expr) ? (+1) : (-1)]\n\n#define CA_RETURN_IF_ERROR(errCode) if((errCode) != XIL_DATA_STREAM_SUCCESS) return (errCode)\n\n#include \"coder_assumptions_hwimpl.h\"\n\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* MemUnit_T can be any of uint8_T, uint16_T, uint32_T\n    * Just check it is consistent with MEM_UNIT_BYTES */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == MEM_UNIT_BYTES, INVALID_MEMUNIT_T);\n#else\n   /* Verify MemUnit_T: sizeof must be 1 */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == 1, MEMUNIT_T_NOT_SIZEOF_1);\n   /* Verify MEM_UNIT_BYTES: must match the size of the largest integer that has sizeof == 1 \n    * Only word addressable targets up to 32-bits are supported. */\n   CA_STATIC_ASSERT((sizeof(uint32_T) == 1) ? MEM_UNIT_BYTES == 4 : \n                 (sizeof(uint16_T) == 1) ? MEM_UNIT_BYTES == 2 :\n                 (sizeof(uint8_T) == 1) ? MEM_UNIT_BYTES == 1 : 0, INVALID_MEM_UNIT_BYTES);\n#endif\n                 \n#include \"coder_assumptions_shared_enums.h\"\n\nstatic MemUnit_T pwsEnabled;\n\n\nstatic XIL_DATA_STREAM_ERROR_CODE sendResult(const CA_TestResult result, \n                                             const MemUnit_T resultType, \n                                             const MemUnit_T actual, \n                                             const MemUnit_T assumed) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode;\n   MemUnit_T tmp;\n   /* send result type */\n   errorCode = coderAssumptionsWriteData(&resultType, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send result status */\n   tmp = (MemUnit_T) result.status;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* send result msg id */\n   tmp = (MemUnit_T) result.msg;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send actual */\n   errorCode = coderAssumptionsWriteData(&actual, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send assumed */\n   errorCode = coderAssumptionsWriteData(&assumed, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* final return */\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE transmitMemUnitBytes(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode; \n   const MemUnit_T memUnitBytes = MEM_UNIT_BYTES;\n\n   /* send memUnitBytes */\n   errorCode = coderAssumptionsWriteData(&memUnitBytes, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n    \n   errorCode = coderAssumptionsSendWriteBuffer();  \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   return errorCode;\n}\n\n/* portable word sizes specified checks */\nstatic XIL_DATA_STREAM_ERROR_CODE sendPWS(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode; \n    MemUnit_T commandId;  \n   \n    /* send CA_PWS */\n    commandId = CA_PWS;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    \n    /* PWS enabled in build */\n    commandId = CA_PWS_ENABLED;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    pwsEnabled = (MemUnit_T) CA_Actual_HWImpl.portableWordSizes;\n    errorCode = coderAssumptionsWriteData(&pwsEnabled, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* extended PWS checks */\n    if (pwsEnabled) {\n       /* config setting mismatch */\n       errorCode = sendResult(CA_PortableWordSizes_Results.configSetting, \n                                    (MemUnit_T) CA_PWS_CONFIG_SETTING,  \n                                    (MemUnit_T) CA_Actual_HWImpl.portableWordSizes, \n                                    (MemUnit_T) CA_Expected_HWImpl.portableWordSizes);\n       CA_RETURN_IF_ERROR(errorCode);\n    }\n\n\n    errorCode = coderAssumptionsSendWriteBuffer();  \n    CA_RETURN_IF_ERROR(errorCode);\n\n    return errorCode;\n}\n\n/* hardware implementation checks message 1 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl1(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;    \n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_1 */    \n   commandId = CA_HW_IMPL_SIZES_1;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per char */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerChar, \n         (MemUnit_T) CA_HW_IMPL_BIT_CHAR,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerChar, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerChar);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per short */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerShort, \n         (MemUnit_T) CA_HW_IMPL_BIT_SHORT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerShort, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerShort);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per int */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerInt, \n         (MemUnit_T) CA_HW_IMPL_BIT_INT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerInt, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerInt);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 2 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl2(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n   \n   /* send CA_HW_IMPL_SIZES_2 */    \n   commandId = CA_HW_IMPL_SIZES_2;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* support long long */\n   errorCode = sendResult(CA_HWImpl_Results.supportLongLong, \n         (MemUnit_T) CA_HW_IMPL_SUPPORT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.supportLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.supportLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLongLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per float */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerFloat, \n         (MemUnit_T) CA_HW_IMPL_BIT_FLOAT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerFloat, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerFloat);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per double */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerDouble, \n         (MemUnit_T) CA_HW_IMPL_BIT_DOUBLE,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerDouble, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerDouble);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 3 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl3(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_3 */    \n   commandId = CA_HW_IMPL_SIZES_3;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per pointer */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPointer, \n         (MemUnit_T) CA_HW_IMPL_BIT_POINTER,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPointer, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPointer);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per size_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerSizeT, \n         (MemUnit_T) CA_HW_IMPL_BIT_SIZE_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerSizeT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerSizeT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per ptrdiff_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPtrDiffT, \n         (MemUnit_T) CA_HW_IMPL_BIT_PTRDIFF_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPtrDiffT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPtrDiffT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n\n/* hardware implementation checks message 4 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl4(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_4 */\n   commandId = CA_HW_IMPL_SIZES_4;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* byte order */\n   errorCode = sendResult(CA_HWImpl_Results.byteOrder, \n         (MemUnit_T) CA_HW_IMPL_BYTE_ORDER,  \n         (MemUnit_T) CA_Actual_HWImpl.byteOrder, \n         (MemUnit_T) CA_Expected_HWImpl.byteOrder);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* integer division rounding */\n   errorCode = sendResult(CA_HWImpl_Results.intDivRoundTo, \n         (MemUnit_T) CA_HW_IMPL_INT_DIV_ROUND,  \n         (MemUnit_T) CA_Actual_HWImpl.intDivRoundTo, \n         (MemUnit_T) CA_Expected_HWImpl.intDivRoundTo);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* shift right on a signed integer */\n   errorCode = sendResult(CA_HWImpl_Results.shiftRightBehavior, \n         (MemUnit_T) CA_HW_IMPL_SHIFT_RIGHT,  \n         (MemUnit_T) CA_Actual_HWImpl.shiftRightBehavior, \n         (MemUnit_T) CA_Expected_HWImpl.shiftRightBehavior);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation, checks unrelated to sizes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHardwareChecks(void){\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n    MemUnit_T commandId;\n\n    commandId = CA_CHECKS_1;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n   /* memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.memoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_MEMORY_STARTUP,\n         (MemUnit_T) CA_Actual_HWImpl.memoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.memoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* dynamic memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_DYNAMIC_MEMORY,\n         (MemUnit_T) CA_Actual_HWImpl.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.dynamicMemoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal flush to zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalFlushToZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_FTZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalFlushToZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalFlushToZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal as zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalAsZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_DAZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalAsZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalAsZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE runChecks(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode;\n    MemUnit_T endTransmission = CA_END_TRANSMIT;\n\n     /* first, run the coder assumptions checks */\n    CA_Run_Tests();\n\n    /* now send the results to the host */\n    errorCode = transmitMemUnitBytes();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendPWS();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendHWImpl1();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl2();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl3();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl4();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* send results of miscellaneous checks */\n    errorCode = sendHardwareChecks();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* let host know all tests have completed */\n    errorCode = coderAssumptionsWriteData(&endTransmission, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = coderAssumptionsSendWriteBuffer();\n    \n    /* final return */\n    return errorCode;\n}\n\n\n/* \n * XIL interface entry points \n *\n */\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void) {\n   if (runChecks() != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;\n   }\n   else {\n      return XIL_INTERFACE_LIB_SUCCESS;\n   }\n}\n"},{"name":"coder_assumptions_app.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_app.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void);\n"},{"name":"coder_assumptions_data_stream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_ERROR\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API    \n   #define CA_TX_BUFFER_MEMUNIT_SIZE coderAssumpTgtAppSvcGetMaxPayloadCapacity()\n   #define BUFFER_HEADER_SIZE 0    \n#else\n   #include \"rx_tx_buffer_sizes.h\"    \n#endif\n\nstatic void* pBuffer;\nstatic IOUnit_T* coderAssumptionsWriteDataPtr;\nstatic uint16_T coderAssumptionsWriteDataAvail;\n\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n\n   const size_t WRITE_BUFFER_SIZE = CA_TX_BUFFER_MEMUNIT_SIZE - BUFFER_HEADER_SIZE;\n   size_t sizeToTransfer = size;\n\n   /* check to see if buffer will overflow */\n   if ((coderAssumptionsWriteDataAvail + sizeToTransfer) > WRITE_BUFFER_SIZE) {\n      errorCode = XIL_WRITE_DATA_ERROR;\n      return errorCode;\n   }\n\n   /* copy data into write buffer */\n   memcpy((void *) coderAssumptionsWriteDataPtr, src, sizeToTransfer);\n   coderAssumptionsWriteDataAvail += (uint16_T) sizeToTransfer;\n   coderAssumptionsWriteDataPtr += sizeToTransfer;\n\n   return errorCode;\n}\n\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the app will \n     * use for transmission\n     */\n    if (!coderAssumpTgtAppSvcAllocBuffer(&pBuffer, CA_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* set coderAssumptionsWriteDataPtr pointer */\n    coderAssumptionsWriteDataPtr = coderAssumpTgtAppSvcGetBufferDataPtr(pBuffer); \n    \n    /* ready for next command */\n    coderAssumptionsWriteDataAvail = 0;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* send pending writes */\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void) {\n   /* send */\n   if (coderAssumpTgtAppSvcSend(pBuffer, coderAssumptionsWriteDataAvail) == CODERASSUMPTGTAPPSVC_ERROR) {             \n      return XIL_WRITE_DATA_ERROR;\n   }   \n   \n   /* reset */\n   if (resetCoderAssumptionsWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_WRITE_DATA_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void) {    \n    /* Create coder assumptions app service */\n    if (coderAssumpTgtAppSvcCreate() != CODERASSUMPTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n\n   /* Reset write buffer */\n   return resetCoderAssumptionsWriteBuffer();\n}\n\nvoid coderAssumptionsTerminate(void) {      \n   coderAssumpTgtAppSvcDestroy();\n}\n"},{"name":"coder_assumptions_data_stream.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2017 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_data_stream.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n#include <stddef.h>\n\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size);\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void);\nextern void coderAssumptionsTerminate(void);\n"},{"name":"coder_assumptions_rtiostream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n/* coder assumptions buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T coderAssumpWriteBuffer[CA_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T coderAssumpTgtAppSvcCreate(void) {\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\nextern void coderAssumpTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T coderAssumpTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &coderAssumpWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to the coder assumptions buffer data */\nextern IOUnit_T * coderAssumpTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &coderAssumpWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T coderAssumpTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"coder_assumptions_shared_enums.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2017-2020 The MathWorks, Inc. */\n\n#ifndef __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n#define __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n\ntypedef enum {\n   CA_LITTLE_ENDIAN = 0, \n   CA_BIG_ENDIAN, \n   CA_UNSPECIFIED,\n   CA_UNABLE_TO_DETERMINE_ON_TARGET\n} CA_EndianessValue;\n\ntypedef enum {\n   CA_FLOOR = 0,\n   CA_ZERO, \n   CA_UNDEFINED\n} CA_IntDivRoundToValue;\n\ntypedef enum {\n   CA_NOT_RUN = 0,\n   CA_FAIL,\n   CA_PASS, \n   CA_WARN,\n   CA_INFO,\n   CA_SKIP\n} CA_TestResultStatus;\n\ntypedef enum {\n   CA_NO_MSG = 0,\n   CA_WARN_INT_DIV_UNDEFINED,\n   CA_WARN_BYTE_ORDER_UNSPECIFIED,\n   CA_ERROR_PWS_CONFIG_SETTING\n} CA_TestResultMsgId;\n\ntypedef enum {\n   CA_HW_IMPL_SIZES_1=0,\n   CA_HW_IMPL_SIZES_2, \n   CA_HW_IMPL_SIZES_3,\n   CA_HW_IMPL_SIZES_4,\n   CA_CHECKS_1,     /* Results of checks unrelated to hardware sizes. */\n   CA_PWS,\n   CA_END_TRANSMIT  /* Sent when CA transmissions have finished. */\n} CODERASSUMPTIONS_COMMAND;\n\ntypedef enum {\n   CA_HW_IMPL_BIT_CHAR = 0,\n   CA_HW_IMPL_BIT_SHORT,\n   CA_HW_IMPL_BIT_INT, \n   CA_HW_IMPL_BIT_LONG, \n   CA_HW_IMPL_BIT_LONGLONG, \n   CA_HW_IMPL_BIT_FLOAT, \n   CA_HW_IMPL_BIT_DOUBLE, \n   CA_HW_IMPL_BIT_POINTER, \n   CA_HW_IMPL_BIT_SIZE_T, \n   CA_HW_IMPL_BIT_PTRDIFF_T, \n   CA_HW_IMPL_SUPPORT_LONGLONG,\n   CA_HW_IMPL_SHIFT_RIGHT,\n   CA_HW_IMPL_INT_DIV_ROUND,\n   CA_HW_IMPL_BYTE_ORDER,\n   CA_HW_IMPL_MEMORY_STARTUP,\n   CA_HW_IMPL_DYNAMIC_MEMORY,\n   CA_HW_IMPL_DENORMAL_FTZ,\n   CA_HW_IMPL_DENORMAL_DAZ\n} CA_HW_IMPL_RESULT;\n\ntypedef enum {\n   CA_PWS_ENABLED = 0,\n   CA_PWS_CONFIG_SETTING\n} CA_PWS_RESULT;\n\n#endif\n\n"},{"name":"comms_interface.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n#ifndef comms_interface_h\n#define comms_interface_h\n\n/* error codes */\n#ifdef USE_COMMS_ERROR\n    static const int COMMS_ERROR = 0;\n#endif\n#ifdef USE_COMMS_SUCCESS\n    static const int COMMS_SUCCESS = 1;\n#endif\n\n/* initialize comm service */\nextern int commsInit(const int argc, void * argv[]);\n\n/* terminate comm service */\nextern int commsTerminate(void);\n\n#endif\n"},{"name":"rtiostream.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\coder\\rtiostream\\src","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\n * Copyright 2007-2012 The MathWorks, Inc.\n *\n * File: rtiostream.h     \n *\n * Abstract:\n *  Function prototypes and defines for rtIOStream API.\n */\n\n#ifndef RTIOSTREAM_H\n#define RTIOSTREAM_H\n\n#include <stddef.h>\n\n#define RTIOSTREAM_ERROR (-1)\n#define RTIOSTREAM_NO_ERROR (0)\n\n/* Note: if the functions declared in this file should be compiled into a shared\n * library (e.g. a .dll file on Windows), you must ensure that the functions are\n * externally visible. The procedure to achieve this depends on the compiler and\n * linker you are using. For example, on Windows, you may need to provide an\n * exports definition .def file that lists all of the functions to be\n * exported; see ./rtiostream/rtiostream_pc.def for a suitable .def file.\n */\n\n#ifndef RTIOSTREAMAPI\n#define RTIOSTREAMAPI \n#endif \n\nRTIOSTREAMAPI int rtIOStreamOpen(\n    int    argc,\n    void * argv[]\n);\n\nRTIOSTREAMAPI int rtIOStreamSend(\n    int          streamID,\n    const void * src, \n    size_t       size,\n    size_t     * sizeSent\n    );\n\nRTIOSTREAMAPI int rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd\n    );\n\nRTIOSTREAMAPI int rtIOStreamClose(\n    int streamID\n    );\n\n\n#endif /* #ifndef RTIOSTREAM_H */\n"},{"name":"rtiostream_utils.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"rtiostream_utils.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012 The MathWorks, Inc. */\n\n#ifndef _RTIOSTREAM_UTILS_H_\n#define _RTIOSTREAM_UTILS_H_\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* Target-side rtIOStream utility APIs */\n\n#include \"rtwtypes.h\" /* include definition of uint32_T */\n#include <stddef.h>   /* include definition of size_t */\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n          \n/* Blocks until all requested outgoing data is sent. */\nextern int rtIOStreamBlockingSend(const int streamID,\n                                  const void * const src,\n                                  uint32_T size);\n\n/* Blocks until all requested incoming data is received. */\nextern int rtIOStreamBlockingRecv(const int streamID,\n                                  void * const dst,\n                                  uint32_T size);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _RTIOSTREAM_UTILS_H_ */\n"},{"name":"rx_tx_buffer_sizes.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2016 The MathWorks, Inc. */\n\n/* \n * File: rx_tx_buffer_sizes.h\n *\n * Defines the buffer sizes for the various XIL services.\n * Make sure we are backwards compatible with PIL implementations that \n * define RTIOSTREAM_TX_BUFFER_BYTE_SIZE and RTIOSTREAM_RX_BUFFER_BYTE_SIZE\n * in their connectivity config. We will use these preprocessor defines to\n * derive both the RX and TX buffer sizes for the various XIL services and\n * make sure we don't incur more memory requirements.\n */\t\t\n\n#ifndef __RX_TX_BUFFER_SIZES_H__\n#define __RX_TX_BUFFER_SIZES_H__\n\n#include \"rtwtypes.h\"\n\n/* transmit buffer size in mem units - no need to worry about fractions \n * as division in C always floors the result. \n */\n#define RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES)\n\n/* Receive buffer size */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n#define RTIOSTREAM_RX_BUFFER_SIZE (RTIOSTREAM_RX_BUFFER_BYTE_SIZE)\n#else\n#define RTIOSTREAM_RX_BUFFER_SIZE (RTIOSTREAM_RX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES)\n#endif\n\n/* # app services sharing the TX buffer allocation */\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define NUM_APPS_SHARING_TX 2\n#else\n   /* XIL */\n   #define NUM_APPS_SHARING_TX 1\n#endif\n\n/* send buffer sizes for applications */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so use BYTE_SIZE to make sure we have the same effective \n    * buffer size during PWS */\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_BYTE_SIZE / NUM_APPS_SHARING_TX)\n#else\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE / NUM_APPS_SHARING_TX)\n#endif\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE XIL_TX_BUFFER_MEMUNIT_SIZE\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n/* buffer includes space for BUFFER_HEADER_SIZE */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so multiply up to make sure we have the same effective \n    * buffer size during PWS */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE (32 * MEM_UNIT_BYTES)\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_BYTE_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#else\n   /* simply reserve a 32 memunit buffer */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE 32\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#endif\n\n#endif\n\n#define APPLICATION_ID_SIZE (sizeof(MemUnit_T))\n#define WRITE_DATA_AVAIL_SIZE (sizeof(uint32_T))\n#define BUFFER_HEADER_SIZE  (APPLICATION_ID_SIZE + WRITE_DATA_AVAIL_SIZE)\n#define APPLICATION_ID_IDX 0\n#define PAYLOAD_SIZE_IDX (APPLICATION_ID_IDX + APPLICATION_ID_SIZE)\n#define PAYLOAD_IDX (PAYLOAD_SIZE_IDX + WRITE_DATA_AVAIL_SIZE)\n\n#endif /*__RX_TX_BUFFER_SIZES_H__ */\n\n"},{"name":"xil_common.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2011-2013 The MathWorks, Inc. */\n\n/*\n * File: xil_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_COMMON_H__\n#define __XIL_COMMON_H__\n\n#include \"rtwtypes.h\"\n#include <string.h> /* include definition of size_t */\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)                                   /* do nothing */\n# else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x)         (void) (x)\n# endif\n#endif\n\n/* MIN is typically used in data stream implementations */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#endif\n"},{"name":"xil_data_stream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2020 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_ERROR\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"comms_interface.h\"\n#ifndef USING_CS_API    \n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#endif\n#include \"xil_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API\n    #define XIL_TX_BUFFER_MEMUNIT_SIZE xilTgtAppSvcGetMaxPayloadCapacity()\n    #define BUFFER_HEADER_SIZE 0\n#else\n    #include \"rx_tx_buffer_sizes.h\"\n#endif\n\n#define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n#define COMMAND_COMPLETE_IDX 0\n#define WRITE_DATA_BUFFER_IDX (COMMAND_COMPLETE_IDX + COMMAND_COMPLETE_SIZE)\n#define USED_WRITE_BUFFER_SIZE (COMMAND_COMPLETE_SIZE + xilWriteDataAvail)\n#define WRITE_BUFFER_SIZE (XIL_TX_BUFFER_MEMUNIT_SIZE - COMMAND_COMPLETE_SIZE - BUFFER_HEADER_SIZE)\n\n\nstatic void* pBuffer;\nstatic IOUnit_T* xilWriteBuffer;\nstatic IOUnit_T* xilWriteDataPtr;\nstatic uint16_T xilWriteDataAvail;\nstatic MemUnit_T* commandResponseType;\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the XIL app service will use for\n     * transmission\n     */\n    if (!xilTgtAppSvcAllocBuffer(&pBuffer, XIL_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    xilWriteBuffer = xilTgtAppSvcGetBufferDataPtr(pBuffer);\n    \n    /* set commandResponseType and xilWriteDataPtr pointer */\n    commandResponseType = (MemUnit_T *) &xilWriteBuffer[COMMAND_COMPLETE_IDX];\n    xilWriteDataPtr = &xilWriteBuffer[WRITE_DATA_BUFFER_IDX];\n    \n    /* ready for next command */\n    xilWriteDataAvail = 0;\n    *commandResponseType = XIL_COMMAND_NOT_COMPLETE;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void) {\n    \n    /* Create XIL service */\n    if (xilTgtAppSvcCreate() != XILTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* Reset write buffer */\n    return resetXILWriteBuffer();\n}\n\n/* send pending writes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendWriteBuffer(void) {\n       \n    if (xilTgtAppSvcSend(pBuffer, USED_WRITE_BUFFER_SIZE) == XILTGTAPPSVC_ERROR) {\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n   /* reset */\n   if (resetXILWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_DATA_FLUSH_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T * src, uint32_T size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   const IOUnit_T * srcPtr = (const IOUnit_T *) src;   \n   size_t transferAmount;\n   uint16_T bufferAvail;\n  \n   /* block until all data is processed */\n   while (size > 0) {      \n      /* send if we have a full message worth of data */   \n      if (xilWriteDataAvail == WRITE_BUFFER_SIZE) {\n         errorCode = sendWriteBuffer();\n         if (errorCode != XIL_DATA_STREAM_SUCCESS) {\n            return errorCode;\n         }\n      }\n      bufferAvail = WRITE_BUFFER_SIZE - xilWriteDataAvail;\n      transferAmount = (uint16_T) MIN(bufferAvail, size);\n      /* copy data into write buffer */\n      memcpy((void *) xilWriteDataPtr, srcPtr, transferAmount);\n      size -= (uint32_T) transferAmount;\n      xilWriteDataAvail += (uint16_T) transferAmount;\n      srcPtr += transferAmount;\n      xilWriteDataPtr += transferAmount;\n   }\n   return errorCode;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T * dst, uint32_T size) {\n\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n     \n    static IOUnit_T* currentBufferPosition = NULL;\n    static uint16_T currentBufSize = 0;\n    uint16_T readAmount;\n    int32_T index = 0;\n    int rtIOStreamErrorStatus;\n    IOUnit_T * dstPtr = (IOUnit_T *) dst;\n\n    while (size > 0)\n    {\n        if (currentBufSize > 0) {\n\n            readAmount = (uint16_T) MIN(currentBufSize, size);\n            memcpy(dstPtr+index, currentBufferPosition, (size_t)readAmount);\n\n            currentBufSize -= readAmount;\n            currentBufferPosition +=readAmount;\n            size -= (uint32_T)readAmount;\n\n            if (size == 0) {\n                /* If we've satisfied the data request we're done, return */\n                return errorCode;\n            }\n\n            /*Buffer empty and more data needed get new data*/\n            index += (int32_T)readAmount;\n        }\n\n        /* Get NEW DATA */\n#ifdef USING_CS_API\n        {\n            uint16_T tmpSize = 0;\n            static uint8_T * tmpData;\n            static boolean_T firstTime = true;\n\n            /*If we've previously read a message free it before getting the next*/\n            if (!firstTime)\n            {\n                xilTgtAppSvcFreeLastReceivedData();\n            }\n            \n            /*Block until a message has been received*/\n            while (tmpSize == 0)\n            {\n                tmpData = xilTgtAppSvcGetReceivedData(&tmpSize);\n            }\n\n            /*Update first time flag*/\n            firstTime = false;\n\n            /*Setup buffer position and size from message data*/\n            currentBufSize = tmpSize;\n            currentBufferPosition = (IOUnit_T *)tmpData;\n        }\n#else\n        rtIOStreamErrorStatus = rtiostreamReadMessage(&currentBufferPosition, &currentBufSize);\n\n        if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    \treturn XIL_READ_DATA_ERROR;\n\n    \n#endif\n    }\n\n    return errorCode;\n}\n\n\n\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep) {\n    \n    /* final part of command */\n    if (isEndOfXILStep) {\n        *commandResponseType = XIL_STEP_COMPLETE;\n    } else {\n        *commandResponseType = XIL_COMMAND_COMPLETE;\n    }\n\n    /* send the write buffer */\n    if (sendWriteBuffer() == XIL_DATA_FLUSH_ERROR){\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n    return XIL_DATA_STREAM_SUCCESS;\n\n}\n\nvoid silpilTerminate(void) {\n    xilTgtAppSvcDestroy();\n}\n\n\n"},{"name":"xil_data_stream.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2016 The MathWorks, Inc. */\n\n/* \n * File: xil_data_stream.h\n */\n\n#ifndef XIL_DATA_STREAM_H\n#define XIL_DATA_STREAM_H\n\n#include \"xil_common.h\"\n#include \"xil_error_codes.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void);\n/* copy specified amount of data from the address specified to the output stream */\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T *, uint32_T);\n/* copy specified amount of data from the input stream to address specified */\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T *, uint32_T );\n/* flush any buffered writes */\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep);\n/* initialize SIL/PIL service */ \nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void);\n/* terminate SIL/PIL service */\nvoid silpilTerminate(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_instrumentation.c","type":"source","group":"SILPIL","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_instrumentation.c\r\n *\r\n * Code generated for instrumentation.\r\n *\r\n */\r\n\r\n#include \"xil_instrumentation.h\"\r\n\r\n/* Code instrumentation offset(s) for model TestPilAdc */\r\n#define taskTimeStart_TestPilAdc_offset 0\r\n#define taskTimeEnd_TestPilAdc_offset  0\r\n\r\n/* A function parameter may be intentionally unused */\r\n#ifndef UNUSED_PARAMETER\r\n# if defined(__LCC__)\r\n#   define UNUSED_PARAMETER(x)\r\n# else\r\n#   define UNUSED_PARAMETER(x)         (void) (x)\r\n# endif\r\n#endif\r\n\r\n#define SIZEOF_TIMER_TYPE              sizeof(uint32_T)\r\n\r\nstatic uint32_T xsd_xil_timer_corrected = 0;\r\nstatic uint32_T xsd_xil_timer_unfreeze = 0;\r\nstatic uint32_T xsd_xil_freezing_busy = 0;\r\nvoid xilUploadProfilingData(uint32_T sectionId)\r\n{\r\n  xilUploadCodeInstrData((void *)(&xsd_xil_timer_corrected), (uint32_T)\r\n    (SIZEOF_TIMER_TYPE), sectionId);\r\n}\r\n\r\n/* The internal freeze and unfreeze methods cannot be nested. The customer-visible implementation avoids nesting problems */\r\nvoid xilProfilingTimerFreezeInternal(void)\r\n{\r\n  /* Update the value of the corrected timer to exclude time spent in the\r\n   * instrumentation code.\r\n   *\r\n   * Using a timer that decrements on each tick.\r\n   */\r\n  xsd_xil_timer_corrected = xsd_xil_timer_corrected - (((uint32_T)\r\n    (profileTimerRead(xsd_xil_timer_unfreeze))) - xsd_xil_timer_unfreeze);\r\n}\r\n\r\nvoid xilProfilingTimerUnFreezeInternal(void)\r\n{\r\n  xsd_xil_timer_unfreeze = ( uint32_T ) (profileTimerRead(xsd_xil_timer_unfreeze));\r\n}\r\n\r\nvoid xilProfilingTimerFreeze(void)\r\n{\r\n  if (xsd_xil_freezing_busy == 0) {\r\n    xilProfilingTimerFreezeInternal();\r\n  }                                    /* if */\r\n}\r\n\r\nvoid xilProfilingTimerUnFreeze(void)\r\n{\r\n  if (xsd_xil_freezing_busy == 0) {\r\n    xilProfilingTimerUnFreezeInternal();\r\n  }                                    /* if */\r\n}\r\n\r\nvoid taskTimeStart(uint32_T sectionId)\r\n{\r\n  /* Send execution profiling data to host */\r\n  xilUploadProfilingData(sectionId);\r\n  xilProfilingTimerUnFreezeInternal();\r\n}\r\n\r\nvoid taskTimeEnd(uint32_T sectionId)\r\n{\r\n  uint32_T sectionIdNeg = ~sectionId;\r\n  xilProfilingTimerFreezeInternal();\r\n\r\n  /* Send execution profiling data to host */\r\n  xilUploadProfilingData(sectionIdNeg);\r\n}\r\n\r\n/* Code instrumentation method(s) for model TestPilAdc */\r\nvoid taskTimeStart_TestPilAdc(uint32_T sectionId)\r\n{\r\n  taskTimeStart(taskTimeStart_TestPilAdc_offset + sectionId);\r\n}\r\n\r\nvoid taskTimeEnd_TestPilAdc(uint32_T sectionId)\r\n{\r\n  taskTimeEnd(taskTimeEnd_TestPilAdc_offset + sectionId);\r\n}\r\n"},{"name":"xil_instrumentation.h","type":"header","group":"SILPIL","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_instrumentation.h\r\n *\r\n * Code generated for instrumentation.\r\n *\r\n */\r\n\r\n/* Functions with a C call interface */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#include \"STM32SerialRtiostream-ProfilerTimer.h\"\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n\r\n/* Upload code instrumentation data point */\r\nvoid xilUploadCodeInstrData(\r\n  void* pData, uint32_T numMemUnits, uint32_T sectionId);\r\n\r\n/* Called before starting a profiled section of code */\r\nvoid taskTimeStart(uint32_T);\r\n\r\n/* Called on finishing a profiled section of code */\r\nvoid taskTimeEnd(uint32_T);\r\n\r\n/* Uploads data */\r\nvoid xilUploadProfilingData(uint32_T sectionId);\r\n\r\n/* Pause the timer while running code associated with storing and uploading the data. */\r\nvoid xilProfilingTimerFreeze(void);\r\n\r\n/* Restart the timer after a pause */\r\nvoid xilProfilingTimerUnFreeze(void);\r\n\r\n/* Code instrumentation method(s) for model TestPilAdc */\r\nvoid taskTimeStart_TestPilAdc(uint32_T sectionId);\r\nvoid taskTimeEnd_TestPilAdc(uint32_T sectionId);\r\n"},{"name":"xil_interface.c","type":"source","group":"SILPIL","path":"E:\\STM32CUBEMX\\mat\\slprj\\stm32\\TestPilAdc\\pil","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_interface.c\r\n *\r\n * PIL generated interface for code: \"TestPilAdc\"\r\n *\r\n */\r\n\r\n#include \"TestPilAdc.h\"\r\n#include \"TestPilAdc_private.h\"\r\n#include \"xil_interface.h\"\r\n#include \"xil_instrumentation.h\"\r\n\r\n/* Functions with a C call interface */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#include \"xil_data_stream.h\"\r\n#include \"codeinstr_data_stream.h\"\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n/* interface data */\r\nreal32_T Vin;\r\n\r\n/* interface data */\r\nreal32_T o_Vout;\r\n\r\n/* initialize error status as a null pointer */\r\nstatic const char_T * rt_errorStatus_tgt_var = ((const char_T *) 0);\r\nstatic const char_T ** rt_errorStatus = &rt_errorStatus_tgt_var;\r\n\r\n/* interface data */\r\nRT_MODEL_TestPilAdc tgt_var_TestPilAdc_M_;\r\n\r\n/* interface (pointer) data */\r\nRT_MODEL_TestPilAdc * TestPilAdc_M = &tgt_var_TestPilAdc_M_;\r\nstatic XILIOData xil_fcnid0_task2_output_u[2];\r\nstatic XILIOData xil_fcnid0_task2_y[2];\r\nstatic XILIOData xil_fcnid0_init_y[2];\r\n\r\n/* In-the-Loop Interface functions - see xil_interface.h */\r\nXIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T xilFcnId)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nvoid xilUploadCodeInstrData(void * pData, uint32_T numMemUnits, uint32_T\r\n  sectionId)\r\n{\r\n  /* Send code instrumentation data to host */\r\n  if (codeInstrWriteData((MemUnit_T *) &numMemUnits, sizeof(numMemUnits)) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n\r\n  if (codeInstrWriteData((MemUnit_T *) &sectionId, sizeof(uint32_T)) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n\r\n  if (codeInstrWriteData((MemUnit_T *) pData, numMemUnits) !=\r\n      XIL_DATA_STREAM_SUCCESS) {\r\n    for (;;) ;\r\n  }\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void)\r\n{\r\n  {\r\n    /* send response id code */\r\n    MemUnit_T memUnitData = XIL_RESPONSE_TYPE_SIZE;\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n\r\n    /* send type id */\r\n    memUnitData = 1;\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n\r\n    /* PIL_FLOAT_SIZE should only be already defined for MathWorks testing */\r\n#ifndef PIL_FLOAT_SIZE\r\n#define PIL_FLOAT_SIZE                 sizeof(float)\r\n#endif\r\n\r\n    /* send size in bytes */\r\n    memUnitData = (MemUnit_T) PIL_FLOAT_SIZE;\r\n\r\n#ifndef HOST_WORD_ADDRESSABLE_TESTING\r\n\r\n    /* convert MemUnits to bytes */\r\n    memUnitData *= MEM_UNIT_BYTES;\r\n\r\n#endif\r\n\r\n    if (xilWriteData(&memUnitData, sizeof(memUnitData)) !=\r\n        XIL_DATA_STREAM_SUCCESS) {\r\n      return XIL_INTERFACE_COMMS_FAILURE;\r\n    }\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  {\r\n  }\r\n\r\n  /* initialize output storage owned by In-the-Loop */\r\n  {\r\n    o_Vout = 0;\r\n  }\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* Call all Set class methods */\r\n    taskTimeStart_TestPilAdc(1U);\r\n    TestPilAdc_initialize(rt_errorStatus);\r\n    taskTimeEnd_TestPilAdc(1U);\r\n\r\n    /* Call all Get class methods */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilPause(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  if (xilFcnId == 0) {\r\n    /* Nothing to do */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  switch (xilCommandType) {\r\n   case XIL_OUTPUT_COMMAND:\r\n    {\r\n      switch (xilCommandIdx) {\r\n       case 2:\r\n        {\r\n          static int initComplete = 0;\r\n          if (!initComplete) {\r\n            uint32_T tableIdx = 0;\r\n\r\n            {\r\n              void * dataAddress = (void *) &(Vin);\r\n              xil_fcnid0_task2_output_u[tableIdx].memUnitLength = 1 * sizeof\r\n                (real32_T);\r\n              xil_fcnid0_task2_output_u[tableIdx++].address = (MemUnit_T *)\r\n                dataAddress;\r\n            }\r\n\r\n            xil_fcnid0_task2_output_u[tableIdx].memUnitLength = 0;\r\n            xil_fcnid0_task2_output_u[tableIdx++].address = (MemUnit_T *) 0;\r\n            initComplete = 1;\r\n          }                            /* if */\r\n\r\n          *xilIOData = &xil_fcnid0_task2_output_u[0];\r\n          break;\r\n        }\r\n\r\n       default:\r\n        errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n        break;\r\n      }\r\n      break;\r\n    }\r\n\r\n   default:\r\n    errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n    break;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }                                    /* if */\r\n\r\n  errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n  UNUSED_PARAMETER(xilCommandType);\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  UNUSED_PARAMETER(responseId);\r\n  UNUSED_PARAMETER(serverFcnId);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilOutput(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  switch (xilTID) {\r\n   case 1:\r\n    /* Call all Set class methods */\r\n    taskTimeStart_TestPilAdc(2U);\r\n    TestPilAdcTID0();\r\n    taskTimeEnd_TestPilAdc(2U);\r\n\r\n    /* Call all Get class methods */\r\n    break;\r\n\r\n   case 2:\r\n    /* Call all Set class methods */\r\n    taskTimeStart_TestPilAdc(3U);\r\n    TestPilAdcTID1(&(o_Vout));\r\n    taskTimeEnd_TestPilAdc(3U);\r\n\r\n    /* Call all Get class methods */\r\n    break;\r\n\r\n   default:\r\n    return XIL_INTERFACE_UNKNOWN_TID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  /* No Update Function */\r\n  UNUSED_PARAMETER(xilTID);\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  switch (xilCommandType) {\r\n   case XIL_INITIALIZE_COMMAND:\r\n    {\r\n      static int initComplete = 0;\r\n      if (!initComplete) {\r\n        uint32_T tableIdx = 0;\r\n\r\n        {\r\n          void * dataAddress = (void *) &(o_Vout);\r\n          xil_fcnid0_init_y[tableIdx].memUnitLength = 1 * sizeof(real32_T);\r\n          xil_fcnid0_init_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n        }\r\n\r\n        xil_fcnid0_init_y[tableIdx].memUnitLength = 0;\r\n        xil_fcnid0_init_y[tableIdx++].address = (MemUnit_T *) 0;\r\n        initComplete = 1;\r\n      }                                /* if */\r\n\r\n      {\r\n        if (xilWriteData(&responseId, sizeof(responseId)) !=\r\n            XIL_DATA_STREAM_SUCCESS) {\r\n          return XIL_INTERFACE_COMMS_FAILURE;\r\n        }                              /* if */\r\n\r\n        if (responseId == XIL_RESPONSE_CS_REQUEST_SERVICE) {\r\n          if (xilWriteData((MemUnit_T *) &serverFcnId, sizeof(serverFcnId)) !=\r\n              XIL_DATA_STREAM_SUCCESS) {\r\n            return XIL_INTERFACE_COMMS_FAILURE;\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      *xilIOData = &xil_fcnid0_init_y[0];\r\n      break;\r\n    }\r\n\r\n   case XIL_OUTPUT_COMMAND:\r\n    {\r\n      switch (xilCommandIdx) {\r\n       case 2:\r\n        {\r\n          static int initComplete = 0;\r\n          if (!initComplete) {\r\n            uint32_T tableIdx = 0;\r\n\r\n            {\r\n              void * dataAddress = (void *) &(o_Vout);\r\n              xil_fcnid0_task2_y[tableIdx].memUnitLength = 1 * sizeof(real32_T);\r\n              xil_fcnid0_task2_y[tableIdx++].address = (MemUnit_T *) dataAddress;\r\n            }\r\n\r\n            xil_fcnid0_task2_y[tableIdx].memUnitLength = 0;\r\n            xil_fcnid0_task2_y[tableIdx++].address = (MemUnit_T *) 0;\r\n            initComplete = 1;\r\n          }                            /* if */\r\n\r\n          {\r\n            if (xilWriteData(&responseId, sizeof(responseId)) !=\r\n                XIL_DATA_STREAM_SUCCESS) {\r\n              return XIL_INTERFACE_COMMS_FAILURE;\r\n            }                          /* if */\r\n\r\n            if (responseId == XIL_RESPONSE_CS_REQUEST_SERVICE) {\r\n              if (xilWriteData((MemUnit_T *) &serverFcnId, sizeof(serverFcnId))\r\n                  != XIL_DATA_STREAM_SUCCESS) {\r\n                return XIL_INTERFACE_COMMS_FAILURE;\r\n              }                        /* if */\r\n            }                          /* if */\r\n          }\r\n\r\n          *xilIOData = &xil_fcnid0_task2_y[0];\r\n          break;\r\n        }\r\n\r\n       default:\r\n        errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n        break;\r\n      }\r\n      break;\r\n    }\r\n\r\n   default:\r\n    errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n    break;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T xilFcnId)\r\n{\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  /* Invoke any terminate Function */\r\n  /* No Function to Call */\r\n\r\n  /* Free Opaque Region Based Data */\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilInitTargetData()\r\n{\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilEnable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Enable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilDisable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Disable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n"},{"name":"xil_interface.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface.h\n *\n * SIL/PIL interface functions\n */\n\n#ifndef __XIL_INTERFACE_H__\n#define __XIL_INTERFACE_H__\n\n/* include rtwtypes.h & XILIOData */\n#include \"xil_interface_common.h\"\n\n/* Generated xil_interface.c may use xilCommandDispatchAndResponse for client/server */\n#include \"xil_interface_lib.h\"\n\n/* xil_interface.c|cpp always presents a C \n * function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {  /* sbcheck:ok:extern_c needed to ensure correct linking*/\n#endif\n\n/* Get data type information - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void);\n\n/* Process Parameters - called from mdlProcessParameters / mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T);\n\n/* Initialize - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T);\n\n/* System Initialize - called from mdlSystemInitialize (or mdlInitializeConditions) */\nextern XIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T);\n\n/* System Reset - called from mdlSystemReset */\nextern XIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T);\n\n/* Initialize input XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **);\n\n/* Output - called from mdlOutputs */\nextern XIL_INTERFACE_ERROR_CODE xilOutput(uint32_T, uint32_T);\n\n/* Update - called from mdlOutputs (not mdlUpdate) */\nextern XIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T, uint32_T);\n\n/* Initialize output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Initialize state output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Initialize complex data objects */\nextern XIL_INTERFACE_ERROR_CODE xilInitTargetData(void);\n\n/* Terminate - called from mdlTerminate */\nextern XIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T);\n\n/* Enable - called from mdlEnable */\nextern XIL_INTERFACE_ERROR_CODE xilEnable(uint32_T, uint32_T);\n\n/* Disable - called from mdlDisable */\nextern XIL_INTERFACE_ERROR_CODE xilDisable(uint32_T, uint32_T);\n\n/* Pause - called from mdlSimStatusChange */\nextern XIL_INTERFACE_ERROR_CODE xilPause(uint32_T);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_common.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/*\n * File: xil_interface_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_INTERFACE_COMMON_H__\n#define __XIL_INTERFACE_COMMON_H__\n\n#include \"xil_common.h\"\n\n/* define some error codes */\ntypedef enum {XIL_INTERFACE_SUCCESS=0, \n              XIL_INTERFACE_UNKNOWN_TID,\n              XIL_INTERFACE_UNKNOWN_FCNID,\n              XIL_INTERFACE_COMMS_FAILURE,\n              XIL_INTERFACE_MEMORY_ALLOCATION_ERROR,\n              XIL_INTERFACE_OFFLOADED_PROCESSING} XIL_INTERFACE_ERROR_CODE;\n\ntypedef enum {XIL_INIT_COMMAND = 0, \n              XIL_INITIALIZE_COMMAND,\n              XIL_SYSTEM_INITIALIZE_COMMAND,\n              XIL_OUTPUT_COMMAND, \n              XIL_TERMINATE_COMMAND, \n              XIL_ENABLE_COMMAND,\n              XIL_DISABLE_COMMAND, \n              XIL_CONST_OUTPUT_COMMAND, \n              XIL_PROCESS_PARAMS_COMMAND,\n              XIL_CLIENT_SERVER_COMMAND,\n              XIL_SHUTDOWN_COMMAND,\n              XIL_UPDATE_COMMAND,\n              XIL_SYSTEM_RESET_COMMAND,\n              XIL_PAUSE_COMMAND} XIL_COMMAND_TYPE_ENUM;\n\n/* define response ids */\ntypedef enum {XIL_RESPONSE_ERROR=0, \n              XIL_RESPONSE_OUTPUT_PRE_DATA,\n              XIL_RESPONSE_OUTPUT_DATA,              \n              XIL_RESPONSE_PRINTF,\n              XIL_RESPONSE_FOPEN,\n              XIL_RESPONSE_FPRINTF,\n              XIL_RESPONSE_SIGNAL_RAISED,\n              XIL_RESPONSE_TYPE_SIZE,\n              XIL_RESPONSE_CS_REQUEST_SERVICE              \n              } XIL_RESPONSE_ID;\n\n/* define receive states */\ntypedef enum {XIL_INVALID_STATE=-1,\n              XIL_READ_COMMAND_CODE,\n              XIL_READ_FCNID,\n              XIL_READ_XILTID,\n              XIL_PROCESS_TARGET_TO_HOST_PRE_DATA,\n              XIL_PROCESS_HOST_TO_TARGET_DATA,\n              XIL_CALL_XILINTERFACE,\n              XIL_PROCESS_TARGET_TO_HOST_DATA,\n              XIL_COMPLETE} XIL_HANDLE_RECV_STATE;\n\n/* Defines what states we need to save to make xilProcessMsg re-entrant. \n * This is used by client/server commands which could happen in the middle \n * of a step */\ntypedef struct xilProcessMsgContextSwitch {\n\tXIL_HANDLE_RECV_STATE state;\n\tXIL_COMMAND_TYPE_ENUM command;\n\tuint32_T commandIdx;\n\tuint32_T fcnId;\n} XIL_PROCESS_MSG_CONTEXT_SWITCH;\n\n/* XILIOData is defined as a start address\n * and length in MemUnits */\ntypedef struct xilIOData {\n   uint32_T memUnitLength;\n   MemUnit_T * address;\n} XILIOData;\n\n#endif\n"},{"name":"xil_interface_lib.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.c\n *\n * SIL/PIL support library\n *\n */\n\n#include \"xil_interface_lib.h\"\n#include \"xil_interface_lib_private.h\"\n#include \"xil_data_stream.h\"\n#include \"codeinstr_data_stream.h\"\n#include \"xil_interface.h\"\n#include \"coder_assumptions_app.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef LDRA_ENABLED\n#include \"code_coverage_utils.h\"\n#endif /* LDRA_ENABLED */\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    void swapBytes(MemUnit_T * const buffer, uint32_T size);\n    static XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* Internal state variable holding information about the\n * XILIOData currently being processed. \n *\n * Note: this variable is shared by UDATA processing code\n * and YDATA processing code and used for all IO.\n *\n */\nstatic XILIOData * xilIODataPtr;\nstatic int isShutdownCommand = 0;\nstatic int processMsgSuccess = 1;\n\n/* xilProcessMsg current context (cc)*/\nstatic XIL_PROCESS_MSG_CONTEXT_SWITCH cc = {XIL_READ_COMMAND_CODE, XIL_INIT_COMMAND, 0, 0};\n\n/* static functions */\nstatic void restoreProcessMsgContext(XIL_PROCESS_MSG_CONTEXT_SWITCH cachedCtx) {\n    cc.state      = cachedCtx.state;\n    cc.command    = cachedCtx.command;\n    cc.commandIdx = cachedCtx.commandIdx;\n    cc.fcnId      = cachedCtx.fcnId;\n}\n\nstatic void getNextXILIOData(void) {\n   /* increment xilIOData ptr if we have not reached the end */\n   if (xilIODataPtr->memUnitLength!=0) {\n      xilIODataPtr++;\n   }\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processHostToTargetData(uint32_T fcnId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n    \n    /* this function receives some arbitrary data size that needs to be \n     * into the appropriate memory addresses. Since it is not guaranteed \n     * that we will copy all the required data in one go, we need to keep \n     * track of which address (and size) in xilIODataPtr we last copied \n     * to so we can continue copying the remaining data the next time we \n     * receive them.\n     */\n    static MemUnit_T * uDataAddress = NULL;\n    static uint32_T uDataLength = 0;\n    int processingComplete = 0;\n        \n\t/* initialize uDataAddress and uDataLength if necessary*/\n    if (uDataAddress == NULL) {\n\t\t/* initialise xilIODataPtr before beginning to process data */\n\t\tif (xilGetHostToTargetData(fcnId, command, commandIdx, &xilIODataPtr)) {\n\t\t\t/* no udata processing to be done - we're complete */\n\t\t\tprocessingComplete = 1;\t\t\t\n\t\t\treturn XIL_PROCESSDATA_SUCCESS;\n\t\t}\n\n        uDataAddress = xilIODataPtr->address;\n        uDataLength = xilIODataPtr->memUnitLength;\n    }\n    \n    while(!(processingComplete)) {\n        xilReadData(uDataAddress, uDataLength);\n        getNextXILIOData();\n            \n        if (xilIODataPtr->memUnitLength == 0) {\n            /* done processing all xilIOData */                \n            processingComplete = 1;\n            uDataAddress = NULL;\n        } else {\n            /* reset our pointer to next xilIOData */\n            uDataAddress = xilIODataPtr->address;\n            uDataLength = xilIODataPtr->memUnitLength;\n        }\n    }\n\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx,\n        uint32_T serverFcnId)  {\n        \n    int moreXILData = 1;\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n\n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostPreData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n        \n    int moreXILData = 1;\n    uint32_T serverFcnId = 0; /*Default server function ID*/\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostPreData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n    \n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_INTERFACE_LIB_ERROR_CODE finalizeCommandResponse(XIL_RESPONSE_ERROR_ID errorId, MemUnit_T isEndOfXILStep)  {\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n    /* flush the output stream\n     * before beginning next command */\n    if (codeInstrDataFlush() != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n   /* only send the error id if necessary */\n   if (errorId != XIL_RESPONSE_ERROR_SUCCESS) {\n      /* send response id code */\n      MemUnit_T memUnitData = XIL_RESPONSE_ERROR;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;      \n      }\n      /* send error id */\n\t  memUnitData = (MemUnit_T) errorId;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n         return XIL_INTERFACE_LIB_ERROR;      \n      }\t  \n   }\n   /* flush the output stream \n    * before beginning next command */\n   if (xilDataFlush(isEndOfXILStep) != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;      \n   }   \n   return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Given current state and command, compute the next state for handleReceive */\nstatic XIL_HANDLE_RECV_STATE computeNextState(XIL_HANDLE_RECV_STATE state, XIL_COMMAND_TYPE_ENUM command) {\n    \n    XIL_HANDLE_RECV_STATE nextState;\n    \n    switch(state) {\n        case XIL_READ_COMMAND_CODE:\n            switch(command) {\n                case XIL_INIT_COMMAND:                    \n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                case XIL_SHUTDOWN_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_READ_FCNID:\n            switch(command) {\n                case XIL_INIT_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_CONST_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:  \n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_READ_XILTID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;            \n        case XIL_READ_XILTID:\n            switch(command) {\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_HOST_TO_TARGET_DATA:\n            switch(command) {\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:                \n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_PRE_DATA;\n                    break;\n                case XIL_CLIENT_SERVER_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_PRE_DATA:\n            switch(command) {\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_CALL_XILINTERFACE:\n            switch(command) {\n                case XIL_UPDATE_COMMAND:\n                case XIL_INIT_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:                \n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                case XIL_TERMINATE_COMMAND:   \n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_DATA:\n            /* done */\n            nextState = XIL_COMPLETE;\n            break;\n        default:\n            nextState = XIL_INVALID_STATE;\n            break;\n    }\n    return nextState;\n}\n\n#define XIL_COMMAND_TYPE_SIZE sizeof(MemUnit_T)\n#define XIL_COMMAND_CODE_IDX 0\n#define XIL_COMMAND_FCNID_IDX (XIL_COMMAND_CODE_IDX + XIL_COMMAND_TYPE_SIZE)\n#define XIL_COMMAND_FCNID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_XILTID_IDX (XIL_COMMAND_FCNID_IDX + XIL_COMMAND_FCNID_SIZE)\n#define XIL_COMMAND_XILTID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_ERROR_STATUS_SIZE sizeof(MemUnit_T)\n\n#define XIL_RUN_EXIT_ERROR processMsgSuccess = 0;      \\\n                           return\n#define XIL_RUN_EXIT return\n\n#define XIL_EXIT_ERROR_IF_INVALID_STATE if (cc.state == XIL_INVALID_STATE) {      \\\n                                         XIL_RUN_EXIT_ERROR;                   \\\n                                      }                                                                                           \n\nstatic void xilReadCommandCode(void) {\n    MemUnit_T commandCode;    \n    if (cc.state==XIL_READ_COMMAND_CODE) {\n        /* read commandCode */\n\n        xilReadData(&(commandCode), XIL_COMMAND_TYPE_SIZE);\n\n        /* cast from the MemUnit commandCode to the enumeration commandCode */\n        cc.command = (XIL_COMMAND_TYPE_ENUM) commandCode;\n            \n        if (cc.command == XIL_SHUTDOWN_COMMAND) {\n\t\t\t/* Terminate this process when XIL simulation is complete */\n            isShutdownCommand = 1;             \n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        } else {\n            /* compute next state */\n            cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n        }\n    }\n}\n                           \nvoid xilProcessMsg(void) { \n    /* read commandCode */\n    xilReadCommandCode();\n    \n    if (cc.state==XIL_READ_FCNID) {\n        /* read fcnId */\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n        \n\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n        \n    if (cc.state==XIL_READ_XILTID) {\n        /* read commandIdx */\n        \n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n    if (cc.state == XIL_PROCESS_HOST_TO_TARGET_DATA) {\n        /* process inputs if required by command */\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from host */\n        processDataError = processHostToTargetData(cc.fcnId, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_UDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE\n    }\n        \n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_PRE_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from target */\n        processDataError = processTargetToHostPreData(cc.fcnId, XIL_RESPONSE_OUTPUT_PRE_DATA, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n\n    if (cc.state == XIL_CALL_XILINTERFACE) {\n        /* call xilInterface function */\n        switch(cc.command) {\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_INIT_COMMAND:\n            {\n#if CODER_ASSUMPTIONS_ENABLED == 1\n                /* run validation of coder assumptions */\n                if (coderAssumptionsRun() != XIL_INTERFACE_LIB_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                } \n#endif\n                if (xilGetDataTypeInfo() != XIL_INTERFACE_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                }\n                if (xilInitTargetData() != XIL_INTERFACE_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                }\n                break;\n            }\n            case XIL_CONST_OUTPUT_COMMAND:\n                /* no function */\n                break;\n            case XIL_PROCESS_PARAMS_COMMAND:\n                if (xilProcessParams(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_PARAMS, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_INITIALIZE_COMMAND:\n                if (xilInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_PAUSE_COMMAND:\n                if (xilPause(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_SYSTEM_INITIALIZE_COMMAND:\n                if (xilSystemInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_TERMINATE_COMMAND:\n                if (xilTerminate(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_ENABLE_COMMAND:\n                if (xilEnable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_ENABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_DISABLE_COMMAND:\n                if (xilDisable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_DISABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_UPDATE_COMMAND:\n                if (xilUpdate(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_UPDATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    } else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#endif\n            case XIL_OUTPUT_COMMAND:\n                if (xilOutput(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_OUTPUT, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_SYSTEM_RESET_COMMAND:\n                if (xilSystemReset(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_RESET, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }                     \n                break;\n#endif\n            default:\n                XIL_RUN_EXIT_ERROR;\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        uint32_T serverFcnId = 0; /* Default server function ID */\n        /* process data from target */\n        processDataError = processTargetToHostData(cc.fcnId, XIL_RESPONSE_OUTPUT_DATA, cc.command, cc.commandIdx, serverFcnId);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n        /*break;*/\n    }\n        \n\n#ifdef LDRA_ENABLED\n    /* upload code coverage execution history from target*/\n    if (cc.command == XIL_TERMINATE_COMMAND) {\n        callTargetUploadFcns();\n    }\n#endif /* LDRA_ENABLED */\n                \n    /* client/server commands could be executed in the middle of a step */\n    if ((cc.state == XIL_COMPLETE) && (cc.command != XIL_CLIENT_SERVER_COMMAND)) { \n        /* finalize the response */\n        MemUnit_T isEndOfXILStep = 1;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) != XIL_INTERFACE_LIB_SUCCESS) {\n            XIL_RUN_EXIT_ERROR;\n        }\n        \n        /* reset state */\n        cc.state = XIL_READ_COMMAND_CODE;\n    }\n\n    XIL_RUN_EXIT;\n    \n}\n\nXIL_INTERFACE_LIB_ERROR_CODE xilRun(void) {\n    XIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\n\n    /* read one msg and pass to owning application */\n    xilProcessMsg();\n    \n    if (processMsgSuccess) {        \n        if (isShutdownCommand) {\n            errorCode = XIL_INTERFACE_LIB_TERMINATE;\n        } else {\n            errorCode = XIL_INTERFACE_LIB_SUCCESS;\n        }\n        \n    } else {\n        errorCode = XIL_INTERFACE_LIB_ERROR;\n    }\n    return errorCode;\n}\n\n/* Dispatch and receive client/server commands within a step */\nvoid xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                   uint32_T xilCommandIdx, uint32_T xilFcnId, \n                                   uint32_T svrFcnId, MemUnit_T xilResponseId,\n                                   XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx) {\n\n    /* define a binary flag, each CS command needs to process a response */\n    int needToProcessCSResponse = 1;\n    \n    /* send input data to the host */\n    if (processTargetToHostData(xilFcnId, xilResponseId, xilCommandType, \n            xilCommandIdx, svrFcnId) == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n        restoreProcessMsgContext(callerCtx);\n        XIL_RUN_EXIT_ERROR;\n    }\n    \n    /* finalize the response */\n    {\n        MemUnit_T isEndOfXILStep = 0;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) !=\n                XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    /* reset state for new context, recursive calls are safe because all\n     * the caller contexts (callerCtx) are cached in the stack */\n    cc.state = XIL_READ_COMMAND_CODE;\n    \n    while(needToProcessCSResponse) {\n        /* read next command requested by the host */\n        xilReadCommandCode();\n        if (cc.command == XIL_CLIENT_SERVER_COMMAND) {\n            /* if the host sent a response to the server call, process it\n             * and then exit the loop. Otherwise, process the current \n             * command and read the next one */\n            needToProcessCSResponse = 0;\n        }\n        /* process response data sent by host */\n        if (xilRun() != XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    restoreProcessMsgContext(callerCtx);\n    \n}\n\nXIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void) {\n    /* return the current context (cc) */\n    return cc;\n}\n\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n\nvoid swapBytes(MemUnit_T * const buffer, uint32_T size) {\n    MemUnit_T tmp;\n    MemUnit_T *headPtr;\n    MemUnit_T *tailPtr;\n    uint32_T idx;\n\n    for(idx = 0; idx < size/2; idx ++) {\n        headPtr = buffer + idx; \n        tailPtr = buffer + size -1 - idx;\n        tmp = *headPtr;\n        *headPtr = *tailPtr;\n        *tailPtr = tmp;\n    }\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size) {\n    XIL_DATA_STREAM_ERROR_CODE readDataVal = xilReadData(dst, size);\n\n    if (readDataVal == XIL_DATA_STREAM_SUCCESS) {\n        swapBytes(dst, size);\n    }\n    return readDataVal;\n}\n\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n"},{"name":"xil_interface_lib.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2018 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_H__\n#define __XIL_INTERFACE_LIB_H__\n\n#include \"xil_error_codes.h\"\n#include \"xil_common.h\"\n#include \"xil_interface_common.h\" \n\n/* always present a C function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* xil interface functions to be called from main */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, \n                                            void *argv[]);\nextern XIL_INTERFACE_LIB_ERROR_CODE xilRun(void);\n\n/* terminate XIL communications */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void);\n\n/* Dispatch and receive client/server commands within a step */\nextern void xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                          uint32_T xilCommandIdx, uint32_T xilFcnId,\n                                          uint32_T serverFcnId, MemUnit_T xilResponseId,\n                                          XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx);\n\n/* return the current context (cc) */\nextern XIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_lib_private.h","type":"header","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2017 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib_private.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_PRIVATE_H__\n#define __XIL_INTERFACE_LIB_PRIVATE_H__\n\n#include \"xil_interface_common.h\"\n\n/* Enumeration to denote UDATA or YDATA processing */\ntypedef enum {XIL_UDATA_IO = 0, XIL_YDATA_IO} XIL_IO_TYPE;\n\n/* define some error codes */\ntypedef enum {XIL_PROCESSDATA_SUCCESS=0, \n              XIL_PROCESSDATA_DATA_STREAM_ERROR, \n              XIL_PROCESSDATA_IO_TYPE_ERROR} XIL_PROCESSDATA_ERROR_CODE;\n\n/* define error response error ids */\ntypedef enum {XIL_RESPONSE_ERROR_SUCCESS=0,\n              XIL_RESPONSE_ERROR_PROCESS_UDATA,\n              XIL_RESPONSE_ERROR_PROCESS_YDATA, \n              XIL_RESPONSE_ERROR_PROCESS_PARAMS, \n              XIL_RESPONSE_ERROR_INITIALIZE,\n              XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, \n              XIL_RESPONSE_ERROR_OUTPUT, \n              XIL_RESPONSE_ERROR_UPDATE,\n              XIL_RESPONSE_ERROR_TERMINATE,\n              XIL_RESPONSE_ERROR_ENABLE, \n              XIL_RESPONSE_ERROR_DISABLE, \n              XIL_RESPONSE_ERROR_SYSTEM_RESET} XIL_RESPONSE_ERROR_ID;\n\n/* static functions */\nstatic void getNextXILIOData(void);\n  \nstatic XIL_HANDLE_RECV_STATE computeNextState(\n        XIL_HANDLE_RECV_STATE currentState,\n        XIL_COMMAND_TYPE_ENUM command);\n\n\n#endif\n"},{"name":"xil_rtiostream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n/* XIL buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T xilWriteBuffer[XIL_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T xilTgtAppSvcCreate(void) {\n    return XILTGTAPPSVC_SUCCESS;\n}\n\nextern void xilTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T xilTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &xilWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return XILTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to XIL buffer data */\nextern IOUnit_T * xilTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &xilWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T xilTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, XIL_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"xil_services.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#ifdef XIL_SIGNAL_HANDLER\n#include <signal.h>\n#include <stdio.h>\n#if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n        #include <execinfo.h>\n        #define MAX_STACKTRACE 12\n    #endif\n#endif\n\n#ifdef SIL_DISABLE_SUBNORMAL_SUPPORT\n    #if SIL_DISABLE_SUBNORMAL_SUPPORT >= 1 \n#include <immintrin.h>\n    #endif\n#endif\n\n#define USE_COMMS_SUCCESS\n#include \"xil_error_codes.h\"\n#include \"xil_interface_lib.h\"\n#include \"xil_data_stream.h\"\n#include \"comms_interface.h\"\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n#include \"codeinstr_data_stream.h\"\n#endif\n\n#ifndef CODER_ASSUMPTIONS_ENABLED\n   #error \"CODER_ASSUMPTIONS_ENABLED should always be defined!\"\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n#include \"coder_assumptions_data_stream.h\"\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n/* define signal handler codes */\ntypedef enum {XIL_SIGNAL_SIGFPE=0, \n              XIL_SIGNAL_SIGILL, \n              XIL_SIGNAL_ABRT,\n              XIL_SIGNAL_SEGV,\n              XIL_SIGNAL_UNKNOWN} XIL_SIGNAL_RAISED;\n\nstatic void XILSigHandler(int32_T sigNo)\n{\n  MemUnit_T memUnitData = XIL_RESPONSE_SIGNAL_RAISED;\n\n  fflush(stderr);\n  \n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  switch (sigNo)\n  {\n    case SIGFPE:\n    {\n        /* Erroneous arithmetic operation, such as division by zero */\n        memUnitData = XIL_SIGNAL_SIGFPE;\n        break;\n    }\n    case SIGILL:\n    {\n        /* Illegal, malformed, unknown or privileged instruction */\n        memUnitData = XIL_SIGNAL_SIGILL;\n        break;\n    }\n    case SIGABRT:\n    {\n        /* Signal abort */\n        memUnitData = XIL_SIGNAL_ABRT;\n        break;\n    }\n    case SIGSEGV:\n    {\n        /* Segmentation violation */\n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            void *array[MAX_STACKTRACE];\n            int bt_size = 0;\n        #endif\n            \n        memUnitData = XIL_SIGNAL_SEGV;\n            \n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            bt_size = backtrace(array, MAX_STACKTRACE);\n            backtrace_symbols_fd(array, bt_size, 2);\n        #endif\n        break;\n    }\n    default:\n    {\n        memUnitData = XIL_SIGNAL_UNKNOWN;\n        break;\n    }\n  }\n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  \n  xilDataFlush((MemUnit_T)1);\n  xilTerminateComms();\n}\n#endif\n\n/* Entry point (called from sil_main.c & pil_main.c) to initialize services */\nXIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, void *argv[]) {\n    \n    if (commsInit(argc, argv) != COMMS_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    if (silpilInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    if (codeInstrInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    if (coderAssumptionsInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n    /* register signals to catch */\n    signal(SIGFPE, XILSigHandler);  /* Erroneous arithmetic operation */\n    signal(SIGILL, XILSigHandler);  /* Illegal operation */\n    signal(SIGABRT, XILSigHandler); /* Abort signal */\n    signal(SIGSEGV, XILSigHandler); /* Segmentation violation */\n#endif\n\n#ifdef SIL_DISABLE_SUBNORMAL_SUPPORT\n    #if SIL_DISABLE_SUBNORMAL_SUPPORT == 1\n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n    #elif SIL_DISABLE_SUBNORMAL_SUPPORT == 2\n    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n    #endif\n#endif\n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Entry point (called from sil_main.c & pil_main.c) to terminate services */\nXIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void) {\n    \n    silpilTerminate();\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    codeInstrTerminate();\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    coderAssumptionsTerminate();\n#endif\n    \n    commsTerminate();\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n"},{"name":"xilcomms_rtiostream.c","type":"source","group":"SILPIL","path":"D:\\MATLAB\\R2022a\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:PIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_COMMS_ERROR\n#define USE_COMMS_SUCCESS\n#include \"xilcomms_rtiostream.h\"\n#include \"comms_interface.h\"\n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc.h\"\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include \"xil_data_stream.h\"\n#endif\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    extern void swapBytes(MemUnit_T * const buffer, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* call xilProcessMsg */\nextern void xilProcessMsg(void);\n\n/* store stream handle */\nstatic int streamID;\n\n/* allocate the buffers */\nstatic IOUnit_T xilCommsBuffer[RTIOSTREAM_RX_BUFFER_SIZE];\n\n\n/* open rtiostream */\nint commsInit(const int argc, void * argv[]){\n    \n    streamID = rtIOStreamOpen(argc, argv);\n    if (streamID == RTIOSTREAM_ERROR) {\n        return COMMS_ERROR;\n    }\n    return COMMS_SUCCESS;\n}\n\n/* close rtiostream */\nint commsTerminate(void) {    \n    if (rtIOStreamClose(streamID) == RTIOSTREAM_NO_ERROR) {\n        return COMMS_SUCCESS;\n    } else {\n        return COMMS_ERROR;\n    }\n}\n\n/* call rtIOStreamBlockingSend to send data*/\nint commsEnqueueBuffer(        \n        void* const pBuf,\n        const uint8_T appId,\n        const uint16_T dataSize) {\n    \n    int rtIOStreamErrorStatus;\n    IOUnit_T* appBuffer;\n    MemUnit_T appIdMemUnit = (MemUnit_T)appId;\n    uint32_T writeDataAvail = (uint32_T)dataSize;   \n    uint32_T transferSize = writeDataAvail + BUFFER_HEADER_SIZE;           \n\n    /* write size and application id before sending the buffer */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    /* writeDataAvail is in terms of IOUnit_T (uint8_T) - convert to MemUnit_T's\n     * abort if writeDataAvail does not divide exactly */\n    uint32_T writeDataAvailMemUnits = writeDataAvail / MEM_UNIT_BYTES;\n    uint32_T memUnitsRemainder = writeDataAvail % MEM_UNIT_BYTES;\n    if (memUnitsRemainder != 0) {\n        fprintf(stderr,\"Target application aborted: the number of available Bytes in the \" \\\n            \"TargetToHost TX Buffer (%d B) does not divide exactly by the number of \" \\\n            \"Bytes per MemUnit (%d B).\\n\", writeDataAvail, MEM_UNIT_BYTES);\n        /* this condition can happen only when the buffer is full with the first\n         * chunk of outgoing data, at this point the host will not be midway through\n         * receiving a response. Therefore, it is ok to drop the pending data. */\n        resetXILWriteBuffer();\n        /* send the abort message */\n        abort();\n    }\n    \n#else\n    uint32_T writeDataAvailMemUnits = writeDataAvail;\n#endif\n    \n    /* get the pointer for the application buffer of the given app id */\n    appBuffer = (IOUnit_T*) pBuf;\n\tif (appBuffer == NULL) {\n\t\t/* early return */\n\t\treturn COMMS_ERROR;\n\t}\n        \n    UNUSED_PARAMETER(pBuf);\n    \n    memcpy((void *) &appBuffer[APPLICATION_ID_IDX], &appIdMemUnit, sizeof(appIdMemUnit));        \n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the playload size that will be sent to the host */\n    swapBytes((MemUnit_T*)(&writeDataAvailMemUnits), sizeof(writeDataAvailMemUnits));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    memcpy((void *) &appBuffer[PAYLOAD_SIZE_IDX], &writeDataAvailMemUnits, sizeof(writeDataAvailMemUnits));    \n    \n   /* Blocks until all requested outgoing data is sent */\n   rtIOStreamErrorStatus = rtIOStreamBlockingSend(streamID,\n                                                 (const void *) appBuffer,\n                                                 transferSize);\n                                                      \n   if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n         return COMMS_ERROR;\n   \n   return COMMS_SUCCESS;\n}\n\nint rtiostreamReadMessage(IOUnit_T ** currentBufferPosition, uint16_T *currentBufSize) {\n    \n    int rtIOStreamErrorStatus;\n    uint32_T dataSize = 0;\n    MemUnit_T appId;\n\n\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &appId,\n        sizeof(appId));\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    return COMMS_ERROR;\n\n    \n    /* receive size of data contained in the buffer */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &dataSize,\n        sizeof(dataSize));\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the dataSize sent from the host */\n    swapBytes((MemUnit_T*)(&dataSize), sizeof(dataSize));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t\treturn COMMS_ERROR;\n\n    \n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n\t/* dataSize is in terms of MemUnit_T - convert to IOUnit_T (uint8_T). Note\n     * that dataSize will not overflow since the host already divided dataSize \n\t * by memUnit_T before transmission, so this multiplication should be safe\n     * and won't overflow.\n\t */\n    dataSize *= MEM_UNIT_BYTES;\n#endif\n\n    /* receive the data */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &(xilCommsBuffer[0]),\n        dataSize);\n\n    *currentBufferPosition = &(xilCommsBuffer[0]);\n    *currentBufSize = (uint16_T)dataSize;\n\n    return COMMS_SUCCESS;\n}\n\n"}]};